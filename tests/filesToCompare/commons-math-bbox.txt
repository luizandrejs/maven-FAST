/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import junit.framework.Assert; import junit.framework.AssertionFailedError; import org.apache.commons.math.complex.Complex; import org.apache.commons.math.complex.ComplexFormat; /** * @version $Revision$ $Date$ */ public class TestUtils { /** * Collection of static methods used in math unit tests. */ private TestUtils() { super(); } /** * Verifies that expected and actual are within delta, or are both NaN or * infinities of the same sign. */ public static void assertEquals(double expected, double actual, double delta) { assertEquals(null, expected, actual, delta); } /** * Verifies that expected and actual are within delta, or are both NaN or * infinities of the same sign. */ public static void assertEquals(String msg, double expected, double actual, double delta) { // check for NaN if(Double.isNaN(expected)){ Assert.assertTrue("" + actual + " is not NaN.", Double.isNaN(actual)); } else { Assert.assertEquals(msg, expected, actual, delta); } } /** * Verifies that the two arguments are exactly the same, either * both NaN or infinities of same sign, or identical floating point values. */ public static void assertSame(double expected, double actual) { assertEquals(expected, actual, 0); } /** * Verifies that real and imaginary parts of the two complex arguments * are exactly the same. Also ensures that NaN / infinite components match. */ public static void assertSame(Complex expected, Complex actual) { assertSame(expected.getReal(), actual.getReal()); assertSame(expected.getImaginary(), actual.getImaginary()); } /** * Verifies that real and imaginary parts of the two complex arguments * differ by at most delta. Also ensures that NaN / infinite components match. */ public static void assertEquals(Complex expected, Complex actual, double delta) { assertEquals(expected.getReal(), actual.getReal(), delta); assertEquals(expected.getImaginary(), actual.getImaginary(), delta); } /** * Verifies that two double arrays have equal entries, up to tolerance */ public static void assertEquals(double a[], double b[], double tolerance) { Assert.assertEquals(a.length, b.length); for (int i = 0; i < a.length; i++) { Assert.assertEquals(a[i], b[i], tolerance); } } /** * Serializes an object to a bytes array and then recovers the object from the bytes array. * Returns the deserialized object. * * @param o object to serialize and recover * @return the recovered, deserialized object */ public static Object serializeAndRecover(Object o) { try { // serialize the Object ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream so = new ObjectOutputStream(bos); so.writeObject(o); // deserialize the Object ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream si = new ObjectInputStream(bis); return si.readObject(); } catch (IOException ioe) { return null; } catch (ClassNotFoundException cnfe) { return null; } } /** * Verifies that serialization preserves equals and hashCode. * Serializes the object, then recovers it and checks equals and hash code. * * @param object the object to serialize and recover */ public static void checkSerializedEquality(Object object) { Object object2 = serializeAndRecover(object); Assert.assertEquals("Equals check", object, object2); Assert.assertEquals("HashCode check", object.hashCode(), object2.hashCode()); } /** * Verifies that the relative error in actual vs. expected is less than or * equal to relativeError. If expected is infinite or NaN, actual must be * the same (NaN or infinity of the same sign). * * @param expected expected value * @param actual observed value * @param relativeError maximum allowable relative error */ public static void assertRelativelyEquals(double expected, double actual, double relativeError) { assertRelativelyEquals(null, expected, actual, relativeError); } /** * Verifies that the relative error in actual vs. expected is less than or * equal to relativeError. If expected is infinite or NaN, actual must be * the same (NaN or infinity of the same sign). * * @param msg message to return with failure * @param expected expected value * @param actual observed value * @param relativeError maximum allowable relative error */ public static void assertRelativelyEquals(String msg, double expected, double actual, double relativeError) { if (Double.isNaN(expected)) { Assert.assertTrue(msg, Double.isNaN(actual)); } else if (Double.isNaN(actual)) { Assert.assertTrue(msg, Double.isNaN(expected)); } else if (Double.isInfinite(actual) || Double.isInfinite(expected)) { Assert.assertEquals(expected, actual, relativeError); } else if (expected == 0.0) { Assert.assertEquals(msg, actual, expected, relativeError); } else { double x = Math.abs((expected - actual) / expected); Assert.assertEquals(msg, 0.0, x, relativeError); } } /** * Fails iff values does not contain a number within epsilon of z. * * @param msg message to return with failure * @param values complex array to search * @param z value sought * @param epsilon tolerance */ public static void assertContains(String msg, Complex[] values, Complex z, double epsilon) { int i = 0; boolean found = false; while (!found && i < values.length) { try { assertEquals(values[i], z, epsilon); found = true; } catch (AssertionFailedError er) { // no match } i++; } if (!found) { Assert.fail(msg + " Unable to find " + ComplexFormat.formatComplex(z)); } } /** * Fails iff values does not contain a number within epsilon of z. * * @param values complex array to search * @param z value sought * @param epsilon tolerance */ public static void assertContains(Complex[] values, Complex z, double epsilon) { assertContains(null, values, z, epsilon); } /** * Fails iff values does not contain a number within epsilon of x. * * @param msg message to return with failure * @param values double array to search * @param x value sought * @param epsilon tolerance */ public static void assertContains(String msg, double[] values, double x, double epsilon) { int i = 0; boolean found = false; while (!found && i < values.length) { try { assertEquals(values[i], x, epsilon); found = true; } catch (AssertionFailedError er) { // no match } i++; } if (!found) { Assert.fail(msg + " Unable to find" + x); } } /** * Fails iff values does not contain a number within epsilon of x. * * @param values double array to search * @param x value sought * @param epsilon tolerance */ public static void assertContains(double[] values, double x, double epsilon) { assertContains(null, values, x, epsilon); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.inference; import java.util.ArrayList; import java.util.List; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * Test cases for the TestUtils class. * * @version $Revision$ $Date$ */ public class TestUtilsTest extends TestCase { public TestUtilsTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(TestUtilsTest.class); suite.setName("TestUtils Tests"); return suite; } public void testChiSquare() throws Exception { // Target values computed using R version 1.8.1 // Some assembly required ;-) // Use sum((obs - exp)^2/exp) for the chi-square statistic and // 1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; assertEquals("chi-square statistic", 0.2, TestUtils.chiSquare(expected, observed), 10E-12); assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10); long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; assertEquals( "chi-square test statistic", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10); assertEquals("chi-square p-value", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9); assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.07)); assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.05)); try { TestUtils.chiSquareTest(expected1, observed1, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { TestUtils.chiSquare(tooShortEx, tooShortObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // unmatched arrays long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { TestUtils.chiSquare(unMatchedEx, unMatchedObs); fail("arrays have different lengths, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // 0 expected count expected[0] = 0; try { TestUtils.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // negative observed count expected[0] = 1; observed[0] = -1; try { TestUtils.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testChiSquareIndependence() throws Exception { // Target values computed using R version 1.8.1 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}}; assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9); assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9); assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002)); assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001)); long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} }; assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9); assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9); assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1)); // ragged input array long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}}; try { TestUtils.chiSquare(counts3); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // insufficient data long[][] counts4 = {{40, 22, 43}}; try { TestUtils.chiSquare(counts4); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } long[][] counts5 = {{40}, {40}, {30}, {10}}; try { TestUtils.chiSquare(counts5); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // negative counts long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} }; try { TestUtils.chiSquare(counts6); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // bad alpha try { TestUtils.chiSquareTest(counts, 0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } public void testChiSquareLargeTestStatistic() throws Exception { double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); double cst = csti.chiSquareTest(exp, obs); assertEquals("chi-square p-value", 0.0, cst, 1E-3); assertEquals( "chi-square test statistic", 114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9); } /** Contingency table containing zeros - PR # 32531 */ public void testChiSquareZeroCount() throws Exception { // Target values computed using R version 1.8.1 long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}}; assertEquals( "chi-square test statistic", 9.67444662263, TestUtils.chiSquare(counts), 1E-9); assertEquals("chi-square p-value", 0.0462835770603, TestUtils.chiSquareTest(counts), 1E-9); } private double[] tooShortObs = { 1.0 }; private double[] emptyObs = {}; private SummaryStatistics emptyStats = new SummaryStatistics(); public void testOneSampleT() throws Exception { double[] observed = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0, 88.0, 98.0, 94.0, 101.0, 92.0, 95.0 }; double mu = 100.0; SummaryStatistics sampleStats = null; sampleStats = new SummaryStatistics(); for (int i = 0; i < observed.length; i++) { sampleStats.addValue(observed[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("t statistic", -2.81976445346, TestUtils.t(mu, observed), 10E-10); assertEquals("t statistic", -2.81976445346, TestUtils.t(mu, sampleStats), 10E-10); assertEquals("p value", 0.0136390585873, TestUtils.tTest(mu, observed), 10E-10); assertEquals("p value", 0.0136390585873, TestUtils.tTest(mu, sampleStats), 10E-10); try { TestUtils.t(mu, (double[]) null); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, (SummaryStatistics) null); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, emptyObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, emptyStats); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, tooShortObs); fail("insufficient data to compute t statistic, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(mu, tooShortObs); fail("insufficient data to perform t test, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, (SummaryStatistics) null); fail("insufficient data to compute t statistic, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(mu, (SummaryStatistics) null); fail("insufficient data to perform t test, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testOneSampleTTest() throws Exception { double[] oneSidedP = {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d }; SummaryStatistics oneSidedPStats = new SummaryStatistics(); for (int i = 0; i < oneSidedP.length; i++) { oneSidedPStats.addValue(oneSidedP[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("one sample t stat", 3.86485535541, TestUtils.t(0d, oneSidedP), 10E-10); assertEquals("one sample t stat", 3.86485535541, TestUtils.t(0d, oneSidedPStats),1E-10); assertEquals("one sample p value", 0.000521637019637, TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10); assertEquals("one sample p value", 0.000521637019637, TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5); assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01)); assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01)); assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001)); assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001)); try { TestUtils.tTest(0d, oneSidedP, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(0d, oneSidedPStats, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testTwoSampleTHeterscedastic() throws Exception { double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d }; double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d }; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("two sample heteroscedastic t stat", 1.60371728768, TestUtils.t(sample1, sample2), 1E-10); assertEquals("two sample heteroscedastic t stat", 1.60371728768, TestUtils.t(sampleStats1, sampleStats2), 1E-10); assertEquals("two sample heteroscedastic p value", 0.128839369622, TestUtils.tTest(sample1, sample2), 1E-10); assertEquals("two sample heteroscedastic p value", 0.128839369622, TestUtils.tTest(sampleStats1, sampleStats2), 1E-10); assertTrue("two sample heteroscedastic t-test reject", TestUtils.tTest(sample1, sample2, 0.2)); assertTrue("two sample heteroscedastic t-test reject", TestUtils.tTest(sampleStats1, sampleStats2, 0.2)); assertTrue("two sample heteroscedastic t-test accept", !TestUtils.tTest(sample1, sample2, 0.1)); assertTrue("two sample heteroscedastic t-test accept", !TestUtils.tTest(sampleStats1, sampleStats2, 0.1)); try { TestUtils.tTest(sample1, sample2, .95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sampleStats1, sampleStats2, .95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sample1, tooShortObs, .01); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sample1, tooShortObs); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sampleStats1, (SummaryStatistics) null); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(sample1, tooShortObs); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(sampleStats1, (SummaryStatistics) null); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testTwoSampleTHomoscedastic() throws Exception { double[] sample1 ={2, 4, 6, 8, 10, 97}; double[] sample2 = {4, 6, 8, 10, 16}; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("two sample homoscedastic t stat", 0.73096310086, TestUtils.homoscedasticT(sample1, sample2), 10E-11); assertEquals("two sample homoscedastic p value", 0.4833963785, TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10); assertTrue("two sample homoscedastic t-test reject", TestUtils.homoscedasticTTest(sample1, sample2, 0.49)); assertTrue("two sample homoscedastic t-test accept", !TestUtils.homoscedasticTTest(sample1, sample2, 0.48)); } public void testSmallSamples() throws Exception { double[] sample1 = {1d, 3d}; double[] sample2 = {4d, 5d}; // Target values computed using R, version 1.8.1 (linux version) assertEquals(-2.2360679775, TestUtils.t(sample1, sample2), 1E-10); assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2), 1E-10); } public void testPaired() throws Exception { double[] sample1 = {1d, 3d, 5d, 7d}; double[] sample2 = {0d, 6d, 11d, 2d}; double[] sample3 = {5d, 7d, 8d, 10d}; // Target values computed using R, version 1.8.1 (linux version) assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4); assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10); assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6); assertFalse(TestUtils.pairedTTest(sample1, sample3, .001)); assertTrue(TestUtils.pairedTTest(sample1, sample3, .002)); } private double[] classA = {93.0, 103.0, 95.0, 101.0}; private double[] classB = {99.0, 92.0, 102.0, 100.0, 102.0}; private double[] classC = {110.0, 115.0, 111.0, 117.0, 128.0}; private List<double[]> classes = new ArrayList<double[]>(); private OneWayAnova oneWayAnova = new OneWayAnovaImpl(); public void testOneWayAnovaUtils() throws Exception { classes.add(classA); classes.add(classB); classes.add(classC); assertEquals(oneWayAnova.anovaFValue(classes), TestUtils.oneWayAnovaFValue(classes), 10E-12); assertEquals(oneWayAnova.anovaPValue(classes), TestUtils.oneWayAnovaPValue(classes), 10E-12); assertEquals(oneWayAnova.anovaTest(classes, 0.01), TestUtils.oneWayAnovaTest(classes, 0.01)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.util; import org.apache.commons.math.MathRuntimeException; /** * @version $Revision$ $Date$ */ public class TestBean { private Double x = Double.valueOf(1.0); private String y = "1.0"; /** * */ public Double getX() { return x; } /** * */ public String getY() { return y; } /** * */ public void setX(Double double1) { x = double1; } /** * */ public void setY(String string) { y = string; } /** * */ public Double getZ() { throw new MathRuntimeException("?", null); } /** * */ public void setZ(Double double1) { } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.random; import java.util.Random; /** * Dummy AbstractRandomGenerator concrete subclass that just wraps a * java.util.Random instance. Used by AbstractRandomGeneratorTest to test * default implementations in AbstractRandomGenerator. * * @version $Revision:$ $Date$ */ public class TestRandomGenerator extends AbstractRandomGenerator { private static final long serialVersionUID = -9161426374178114548L; private Random random = new Random(); public void setSeed(long seed) { clear(); random.setSeed(seed); } public double nextDouble() { return random.nextDouble(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; /** * This class is used in the junit tests for the ODE integrators. * <p>This is the same as problem 1 except integration is done * backward in time</p> */ public class TestProblem5 extends TestProblem1 { /** Serializable version identifier. */ private static final long serialVersionUID = 7579233102411804237L; /** * Simple constructor. */ public TestProblem5() { super(); setFinalConditions(2 * t0 - t1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import org.apache.commons.math.ode.FirstOrderDifferentialEquations; import org.apache.commons.math.ode.events.EventHandler; /** * This class is used as the base class of the problems that are * integrated during the junit tests for the ODE integrators. */ public abstract class TestProblemAbstract implements FirstOrderDifferentialEquations, Cloneable { /** Serializable version identifier. */ private static final long serialVersionUID = -8521928974502839379L; /** Dimension of the problem. */ protected int n; /** Number of functions calls. */ protected int calls; /** Initial time */ protected double t0; /** Initial state */ protected double[] y0; /** Final time */ protected double t1; /** Error scale */ protected double[] errorScale; /** * Simple constructor. */ protected TestProblemAbstract() { n = 0; calls = 0; t0 = 0; y0 = null; t1 = 0; errorScale = null; } /** * Copy constructor. * @param problem problem to copy */ protected TestProblemAbstract(TestProblemAbstract problem) { n = problem.n; calls = problem.calls; t0 = problem.t0; if (problem.y0 == null) { y0 = null; } else { y0 = (double[]) problem.y0.clone(); } if (problem.errorScale == null) { errorScale = null; } else { errorScale = (double[]) problem.errorScale.clone(); } t1 = problem.t1; } /** * Clone operation. * @return a copy of the instance */ public abstract Object clone(); /** * Set the initial conditions * @param t0 initial time * @param y0 initial state vector */ protected void setInitialConditions(double t0, double[] y0) { calls = 0; n = y0.length; this.t0 = t0; this.y0 = (double[]) y0.clone(); } /** * Set the final conditions. * @param t1 final time */ protected void setFinalConditions(double t1) { this.t1 = t1; } /** * Set the error scale * @param errorScale error scale */ protected void setErrorScale(double[] errorScale) { this.errorScale = (double[]) errorScale.clone(); } public int getDimension() { return n; } /** * Get the initial time. * @return initial time */ public double getInitialTime() { return t0; } /** * Get the initial state vector. * @return initial state vector */ public double[] getInitialState() { return y0; } /** * Get the final time. * @return final time */ public double getFinalTime() { return t1; } /** * Get the error scale. * @return error scale */ public double[] getErrorScale() { return errorScale; } /** * Get the events handlers. * @return events handlers */ public EventHandler[] getEventsHandlers() { return new EventHandler[0]; } /** * Get the number of calls. * @return nuber of calls */ public int getCalls() { return calls; } public void computeDerivatives(double t, double[] y, double[] yDot) { ++calls; doComputeDerivatives(t, y, yDot); } abstract public void doComputeDerivatives(double t, double[] y, double[] yDot); /** * Compute the theoretical state at the specified time. * @param t time at which the state is required * @return state vector at time t */ abstract public double[] computeTheoreticalState(double t); }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; /** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> * y' = -y * </pre> * the solution of this equation is a simple exponential function : * <pre> * y (t) = y (t0) exp (t0-t) * </pre> * </p> */ public class TestProblem1 extends TestProblemAbstract { /** Serializable version identifier. */ private static final long serialVersionUID = 1977870815289373164L; /** theoretical state */ private double[] y; /** * Simple constructor. */ public TestProblem1() { super(); double[] y0 = { 1.0, 0.1 }; setInitialConditions(0.0, y0); setFinalConditions(4.0); double[] errorScale = { 1.0, 1.0 }; setErrorScale(errorScale); y = new double[y0.length]; } /** * Copy constructor. * @param problem problem to copy */ public TestProblem1(TestProblem1 problem) { super(problem); y = (double[]) problem.y.clone(); } /** * Clone operation. * @return a copy of the instance */ public Object clone() { return new TestProblem1(this); } public void doComputeDerivatives(double t, double[] y, double[] yDot) { // compute the derivatives for (int i = 0; i < n; ++i) yDot[i] = -y[i]; } public double[] computeTheoreticalState(double t) { double c = Math.exp (t0 - t); for (int i = 0; i < n; ++i) { y[i] = c * y0[i]; } return y; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; /** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> * y' = t^3 - t y * </pre> * with the initial condition y (0) = 0. The solution of this equation * is the following function : * <pre> * y (t) = t^2 + 2 (ext (- t^2 / 2) - 1) * </pre> * </p> */ public class TestProblem2 extends TestProblemAbstract { /** Serializable version identifier. */ private static final long serialVersionUID = 8330741783213512366L; /** theoretical state */ private double[] y; /** * Simple constructor. */ public TestProblem2() { super(); double[] y0 = { 0.0 }; setInitialConditions(0.0, y0); setFinalConditions(1.0); double[] errorScale = { 1.0 }; setErrorScale(errorScale); y = new double[y0.length]; } /** * Copy constructor. * @param problem problem to copy */ public TestProblem2(TestProblem2 problem) { super(problem); y = (double[]) problem.y.clone(); } /** * Clone operation. * @return a copy of the instance */ public Object clone() { return new TestProblem2(this); } public void doComputeDerivatives(double t, double[] y, double[] yDot) { // compute the derivatives for (int i = 0; i < n; ++i) yDot[i] = t * (t * t - y[i]); } public double[] computeTheoreticalState(double t) { double t2 = t * t; double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1); for (int i = 0; i < n; ++i) { y[i] = c; } return y; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import org.apache.commons.math.ode.events.EventHandler; /** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> * x'' = -x * </pre> * And when x decreases down to 0, the state should be changed as follows : * <pre> * x' -> -x' * </pre> * The theoretical solution of this problem is x = |sin(t+a)| * </p> */ public class TestProblem4 extends TestProblemAbstract { /** Serializable version identifier. */ private static final long serialVersionUID = -5910438521889015745L; /** Time offset. */ private double a; /** theoretical state */ private double[] y; /** Simple constructor. */ public TestProblem4() { super(); a = 1.2; double[] y0 = { Math.sin(a), Math.cos(a) }; setInitialConditions(0.0, y0); setFinalConditions(15); double[] errorScale = { 1.0, 0.0 }; setErrorScale(errorScale); y = new double[y0.length]; } /** * Copy constructor. * @param problem problem to copy */ public TestProblem4(TestProblem4 problem) { super(problem); a = problem.a; y = (double[]) problem.y.clone(); } /** * Clone operation. * @return a copy of the instance */ public Object clone() { return new TestProblem4(this); } public EventHandler[] getEventsHandlers() { return new EventHandler[] { new Bounce(), new Stop() }; } public void doComputeDerivatives(double t, double[] y, double[] yDot) { yDot[0] = y[1]; yDot[1] = -y[0]; } public double[] computeTheoreticalState(double t) { double sin = Math.sin(t + a); double cos = Math.cos(t + a); y[0] = Math.abs(sin); y[1] = (sin >= 0) ? cos : -cos; return y; } private static class Bounce implements EventHandler { private static final long serialVersionUID = 1356097180027801200L; private int sign; public Bounce() { sign = +1; } public double g(double t, double[] y) { return sign * y[0]; } public int eventOccurred(double t, double[] y) { // this sign change is needed because the state will be reset soon sign = -sign; return EventHandler.RESET_STATE; } public void resetState(double t, double[] y) { y[0] = -y[0]; y[1] = -y[1]; } } private static class Stop implements EventHandler { private static final long serialVersionUID = 6975050568227951931L; public Stop() { } public double g(double t, double[] y) { return t - 12.0; } public int eventOccurred(double t, double[] y) { return EventHandler.STOP; } public void resetState(double t, double[] y) { } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.ODEIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; /** * This class is used to handle steps for the test problems * integrated during the junit tests for the ODE integrators. */ class TestProblemHandler implements StepHandler { /** Serializable version identifier. */ private static final long serialVersionUID = 3589490480549900461L; /** Associated problem. */ private TestProblemAbstract problem; /** Maximal errors encountered during the integration. */ private double maxValueError; private double maxTimeError; /** Error at the end of the integration. */ private double lastError; /** Time at the end of integration. */ private double lastTime; /** ODE solver used. */ private ODEIntegrator integrator; /** Expected start for step. */ private double expectedStepStart; /** * Simple constructor. * @param problem problem for which steps should be handled * @param integrator ODE solver used */ public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) { this.problem = problem; this.integrator = integrator; reset(); } public boolean requiresDenseOutput() { return true; } public void reset() { maxValueError = 0; maxTimeError = 0; lastError = 0; expectedStepStart = Double.NaN; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { double start = integrator.getCurrentStepStart(); if (Math.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) { // multistep integrators do not handle the first steps themselves // so we have to make sure the integrator we look at has really started its work if (!Double.isNaN(expectedStepStart)) { maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart)); } expectedStepStart = start + integrator.getCurrentSignedStepsize(); } double pT = interpolator.getPreviousTime(); double cT = interpolator.getCurrentTime(); double[] errorScale = problem.getErrorScale(); // store the error at the last step if (isLast) { double[] interpolatedY = interpolator.getInterpolatedState(); double[] theoreticalY = problem.computeTheoreticalState(cT); for (int i = 0; i < interpolatedY.length; ++i) { double error = Math.abs(interpolatedY[i] - theoreticalY[i]); if (error > lastError) { lastError = error; } } lastTime = cT; } // walk through the step for (int k = 0; k <= 20; ++k) { double time = pT + (k * (cT - pT)) / 20; interpolator.setInterpolatedTime(time); double[] interpolatedY = interpolator.getInterpolatedState(); double[] theoreticalY = problem.computeTheoreticalState(interpolator.getInterpolatedTime()); // update the errors for (int i = 0; i < interpolatedY.length; ++i) { double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]); if (error > maxValueError) { maxValueError = error; } } } } /** * Get the maximal value error encountered during integration. * @return maximal value error */ public double getMaximalValueError() { return maxValueError; } /** * Get the maximal time error encountered during integration. * @return maximal time error */ public double getMaximalTimeError() { return maxTimeError; } /** * Get the error at the end of the integration. * @return error at the end of the integration */ public double getLastError() { return lastError; } /** * Get the time at the end of the integration. * @return time at the end of the integration. */ public double getLastTime() { return lastTime; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; /** * This class is used in the junit tests for the ODE integrators. */ class TestProblemFactory { /** Problems pool. */ private static TestProblemAbstract[] pool = { new TestProblem1(), new TestProblem2(), new TestProblem3(), new TestProblem4(), new TestProblem5() }; /** * Private constructor. * This is a utility class, so there are no instance at all. */ private TestProblemFactory() { } /** * Get the problems. * @return array of problems to solve */ public static TestProblemAbstract[] getProblems() { return pool; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; /** * This class is used in the junit tests for the ODE integrators. * <p>This specific problem is the following differential equation : * <pre> * y1'' = -y1/r^3 y1 (0) = 1-e y1' (0) = 0 * y2'' = -y2/r^3 y2 (0) = 0 y2' (0) =sqrt((1+e)/(1-e)) * r = sqrt (y1^2 + y2^2), e = 0.9 * </pre> * This is a two-body problem in the plane which can be solved by * Kepler's equation * <pre> * y1 (t) = ... * </pre> * </p> */ public class TestProblem3 extends TestProblemAbstract { /** Serializable version identifier. */ private static final long serialVersionUID = 8567328542728919999L; /** Eccentricity */ double e; /** theoretical state */ private double[] y; /** * Simple constructor. * @param e eccentricity */ public TestProblem3(double e) { super(); this.e = e; double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) }; setInitialConditions(0.0, y0); setFinalConditions(20.0); double[] errorScale = { 1.0, 1.0, 1.0, 1.0 }; setErrorScale(errorScale); y = new double[y0.length]; } /** * Simple constructor. */ public TestProblem3() { this(0.1); } /** * Copy constructor. * @param problem problem to copy */ public TestProblem3(TestProblem3 problem) { super(problem); e = problem.e; y = (double[]) problem.y.clone(); } /** * Clone operation. * @return a copy of the instance */ public Object clone() { return new TestProblem3(this); } public void doComputeDerivatives(double t, double[] y, double[] yDot) { // current radius double r2 = y[0] * y[0] + y[1] * y[1]; double invR3 = 1 / (r2 * Math.sqrt(r2)); // compute the derivatives yDot[0] = y[2]; yDot[1] = y[3]; yDot[2] = -invR3 * y[0]; yDot[3] = -invR3 * y[1]; } public double[] computeTheoreticalState(double t) { // solve Kepler's equation double E = t; double d = 0; double corr = 0; do { double f2 = e * Math.sin(E); double f0 = d - f2; double f1 = 1 - e * Math.cos(E); double f12 = f1 + f1; corr = f0 * f12 / (f1 * f12 - f0 * f2); d -= corr; E = t + d; } while (Math.abs(corr) > 1.0e-12); double cosE = Math.cos(E); double sinE = Math.sin(E); y[0] = cosE - e; y[1] = Math.sqrt(1 - e * e) * sinE; y[2] = -sinE / (1 - e * cosE); y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE); return y; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import junit.framework.TestCase; import java.io.ByteArrayOutputStream; import java.io.PrintStream; import java.io.PrintWriter; import java.util.Locale; /** * @version $Revision$ $Date$ */ public class MathExceptionTest extends TestCase { public void testConstructor(){ MathException ex = new MathException(); assertNull(ex.getCause()); assertNull(ex.getMessage()); assertEquals(0, ex.getMessage(Locale.FRENCH).length()); } public void testConstructorPatternArguments(){ String pattern = "a {0}x{1} matrix cannot be a rotation matrix"; Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) }; MathException ex = new MathException(pattern, arguments); assertNull(ex.getCause()); assertEquals(pattern, ex.getPattern()); assertEquals(arguments.length, ex.getArguments().length); for (int i = 0; i < arguments.length; ++i) { assertEquals(arguments[i], ex.getArguments()[i]); } assertFalse(pattern.equals(ex.getMessage())); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } public void testConstructorCause(){ String inMsg = "inner message"; Exception cause = new Exception(inMsg); MathException ex = new MathException(cause); assertEquals(cause, ex.getCause()); } public void testConstructorPatternArgumentsCause(){ String pattern = "a {0}x{1} matrix cannot be a rotation matrix"; Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) }; String inMsg = "inner message"; Exception cause = new Exception(inMsg); MathException ex = new MathException(pattern, arguments, cause); assertEquals(cause, ex.getCause()); assertEquals(pattern, ex.getPattern()); assertEquals(arguments.length, ex.getArguments().length); for (int i = 0; i < arguments.length; ++i) { assertEquals(arguments[i], ex.getArguments()[i]); } assertFalse(pattern.equals(ex.getMessage())); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } /** * Tests the printStackTrace() operation. */ public void testPrintStackTrace() { String outMsg = "outer message"; String inMsg = "inner message"; MathException cause = new MathConfigurationException(inMsg, null); MathException ex = new MathException(outMsg, null, cause); ByteArrayOutputStream baos = new ByteArrayOutputStream(); PrintStream ps = new PrintStream(baos); ex.printStackTrace(ps); String stack = baos.toString(); String outerMsg = "org.apache.commons.math.MathException: outer message"; String innerMsg = "Caused by: " + "org.apache.commons.math.MathConfigurationException: inner message"; assertTrue(stack.startsWith(outerMsg)); assertTrue(stack.indexOf(innerMsg) > 0); PrintWriter pw = new PrintWriter(ps, true); ex.printStackTrace(pw); stack = baos.toString(); assertTrue(stack.startsWith(outerMsg)); assertTrue(stack.indexOf(innerMsg) > 0); } /** * Test serialization */ public void testSerialization() { String outMsg = "outer message"; String inMsg = "inner message"; MathException cause = new MathConfigurationException(inMsg, null); MathException ex = new MathException(outMsg, null, cause); MathException image = (MathException) TestUtils.serializeAndRecover(ex); ByteArrayOutputStream baos = new ByteArrayOutputStream(); PrintStream ps = new PrintStream(baos); ex.printStackTrace(ps); String stack = baos.toString(); ByteArrayOutputStream baos2 = new ByteArrayOutputStream(); PrintStream ps2 = new PrintStream(baos2); image.printStackTrace(ps2); String stack2 = baos2.toString(); // See if JDK supports nested exceptions. If not, stack trace of // inner exception will not be serialized boolean jdkSupportsNesting = false; try { Throwable.class.getDeclaredMethod("getCause", new Class[0]); jdkSupportsNesting = true; } catch (NoSuchMethodException e) { jdkSupportsNesting = false; } if (jdkSupportsNesting) { assertEquals(stack, stack2); } else { assertTrue(stack2.indexOf(inMsg) != -1); assertTrue(stack2.indexOf("MathConfigurationException") != -1); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import java.util.Locale; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class FunctionEvaluationExceptionTest extends TestCase { public void testConstructor(){ FunctionEvaluationException ex = new FunctionEvaluationException(0.0); assertNull(ex.getCause()); assertNotNull(ex.getMessage()); assertTrue(ex.getMessage().indexOf("0") > 0); assertEquals(0.0, ex.getArgument(), 0); } public void testConstructorPatternArguments(){ String pattern = "Evaluation failed for argument = {0}"; Object[] arguments = { Double.valueOf(0.0) }; FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments); assertNull(ex.getCause()); assertEquals(pattern, ex.getPattern()); assertEquals(arguments.length, ex.getArguments().length); for (int i = 0; i < arguments.length; ++i) { assertEquals(arguments[i], ex.getArguments()[i]); } assertFalse(pattern.equals(ex.getMessage())); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } public void testConstructorPatternArgumentsCause(){ String pattern = "Evaluation failed for argument = {0}"; Object[] arguments = { Double.valueOf(0.0) }; String inMsg = "inner message"; Exception cause = new Exception(inMsg); FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause); assertEquals(cause, ex.getCause()); assertEquals(pattern, ex.getPattern()); assertEquals(arguments.length, ex.getArguments().length); for (int i = 0; i < arguments.length; ++i) { assertEquals(arguments[i], ex.getArguments()[i]); } assertFalse(pattern.equals(ex.getMessage())); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } public void testConstructorArgumentCause(){ String inMsg = "inner message"; Exception cause = new Exception(inMsg); FunctionEvaluationException ex = new FunctionEvaluationException(0.0, cause); assertEquals(cause, ex.getCause()); assertTrue(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import java.util.Locale; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class ArgumentOutsideDomainExceptionTest extends TestCase { public void testConstructor(){ ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(Math.PI, 10.0, 20.0); assertNull(ex.getCause()); assertNotNull(ex.getMessage()); assertTrue(ex.getMessage().indexOf("3.14") > 0); assertEquals(Math.PI, ex.getArgument(), 0); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import java.util.Locale; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class DuplicateSampleAbscissaExceptionTest extends TestCase { public void testConstructor(){ DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11); assertNull(ex.getCause()); assertNotNull(ex.getMessage()); assertTrue(ex.getMessage().indexOf("1.2") > 0); assertEquals(1.2, ex.getDuplicateAbscissa(), 0); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import java.util.Locale; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class MaxIterationsExceededExceptionTest extends TestCase { public void testSimpleConstructor(){ MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000); assertNull(ex.getCause()); assertNotNull(ex.getMessage()); assertTrue(ex.getMessage().indexOf("1,000,000") > 0); assertEquals(1000000, ex.getMaxIterations()); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } public void testComplexConstructor(){ MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000, "Continued fraction convergents failed to converge for value {0}", new Object[] { Double.valueOf(1234567) }); assertNull(ex.getCause()); assertNotNull(ex.getMessage()); assertTrue(ex.getMessage().indexOf("1,000,000") < 0); assertTrue(ex.getMessage().indexOf("1,234,567") > 0); assertEquals(1000000, ex.getMaxIterations()); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import junit.framework.TestCase; import java.util.Locale; /** * @version $Revision$ $Date$ */ public class ConvergenceExceptionTest extends TestCase { public void testConstructor(){ ConvergenceException ex = new ConvergenceException(); assertNull(ex.getCause()); assertNotNull(ex.getMessage()); assertNotNull(ex.getMessage(Locale.FRENCH)); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } public void testConstructorPatternArguments(){ String pattern = "a {0}x{1} matrix cannot be a rotation matrix"; Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) }; ConvergenceException ex = new ConvergenceException(pattern, arguments); assertNull(ex.getCause()); assertEquals(pattern, ex.getPattern()); assertEquals(arguments.length, ex.getArguments().length); for (int i = 0; i < arguments.length; ++i) { assertEquals(arguments[i], ex.getArguments()[i]); } assertFalse(pattern.equals(ex.getMessage())); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } public void testConstructorCause(){ String inMsg = "inner message"; Exception cause = new Exception(inMsg); ConvergenceException ex = new ConvergenceException(cause); assertEquals(cause, ex.getCause()); } public void testConstructorPatternArgumentsCause(){ String pattern = "a {0}x{1} matrix cannot be a rotation matrix"; Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) }; String inMsg = "inner message"; Exception cause = new Exception(inMsg); ConvergenceException ex = new ConvergenceException(pattern, arguments, cause); assertEquals(cause, ex.getCause()); assertEquals(pattern, ex.getPattern()); assertEquals(arguments.length, ex.getArguments().length); for (int i = 0; i < arguments.length; ++i) { assertEquals(arguments[i], ex.getArguments()[i]); } assertFalse(pattern.equals(ex.getMessage())); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import junit.framework.TestCase; import java.util.Locale; /** * @version $Revision$ $Date$ */ public class MathConfigurationExceptionTest extends TestCase { public void testConstructor(){ MathConfigurationException ex = new MathConfigurationException(); assertNull(ex.getCause()); assertNull(ex.getMessage()); assertEquals(0, ex.getMessage(Locale.FRENCH).length()); } public void testConstructorPatternArguments(){ String pattern = "a {0}x{1} matrix cannot be a rotation matrix"; Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) }; MathConfigurationException ex = new MathConfigurationException(pattern, arguments); assertNull(ex.getCause()); assertEquals(pattern, ex.getPattern()); assertEquals(arguments.length, ex.getArguments().length); for (int i = 0; i < arguments.length; ++i) { assertEquals(arguments[i], ex.getArguments()[i]); } assertFalse(pattern.equals(ex.getMessage())); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } public void testConstructorCause(){ String inMsg = "inner message"; Exception cause = new Exception(inMsg); MathConfigurationException ex = new MathConfigurationException(cause); assertEquals(cause, ex.getCause()); } public void testConstructorPatternArgumentsCause(){ String pattern = "a {0}x{1} matrix cannot be a rotation matrix"; Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) }; String inMsg = "inner message"; Exception cause = new Exception(inMsg); MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause); assertEquals(cause, ex.getCause()); assertEquals(pattern, ex.getPattern()); assertEquals(arguments.length, ex.getArguments().length); for (int i = 0; i < arguments.length; ++i) { assertEquals(arguments[i], ex.getArguments()[i]); } assertFalse(pattern.equals(ex.getMessage())); assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat; import java.io.BufferedReader; import java.io.IOException; import java.io.StringReader; import java.util.Iterator; import org.apache.commons.math.TestUtils; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test cases for the {@link Frequency} class. * * @version $Revision$ $Date$ */ public final class FrequencyTest extends TestCase { private long oneL = 1; private long twoL = 2; private long threeL = 3; private int oneI = 1; private int twoI = 2; private int threeI=3; private double tolerance = 10E-15; private Frequency f = null; public FrequencyTest(String name) { super(name); } public void setUp() { f = new Frequency(); } public static Test suite() { TestSuite suite = new TestSuite(FrequencyTest.class); suite.setName("Frequency Tests"); return suite; } /** test freq counts */ public void testCounts() { assertEquals("total count",0,f.getSumFreq()); f.addValue(oneL); f.addValue(twoL); f.addValue(1); f.addValue(oneI); assertEquals("one frequency count",3,f.getCount(1)); assertEquals("two frequency count",1,f.getCount(2)); assertEquals("three frequency count",0,f.getCount(3)); assertEquals("total count",4,f.getSumFreq()); assertEquals("zero cumulative frequency", 0, f.getCumFreq(0)); assertEquals("one cumulative frequency", 3, f.getCumFreq(1)); assertEquals("two cumulative frequency", 4, f.getCumFreq(2)); assertEquals("Integer argument cum freq",4, f.getCumFreq(Integer.valueOf(2))); assertEquals("five cumulative frequency", 4, f.getCumFreq(5)); assertEquals("foo cumulative frequency", 0, f.getCumFreq("foo")); f.clear(); assertEquals("total count",0,f.getSumFreq()); // userguide examples ------------------------------------------------------------------- f.addValue("one"); f.addValue("One"); f.addValue("oNe"); f.addValue("Z"); assertEquals("one cumulative frequency", 1 , f.getCount("one")); assertEquals("Z cumulative pct", 0.5, f.getCumPct("Z"), tolerance); assertEquals("z cumulative pct", 1.0, f.getCumPct("z"), tolerance); assertEquals("Ot cumulative pct", 0.25, f.getCumPct("Ot"), tolerance); f.clear(); f = null; Frequency f = new Frequency(); f.addValue(1); f.addValue(Integer.valueOf(1)); f.addValue(Long.valueOf(1)); f.addValue(2); f.addValue(Integer.valueOf(-1)); assertEquals("1 count", 3, f.getCount(1)); assertEquals("1 count", 3, f.getCount(Integer.valueOf(1))); assertEquals("0 cum pct", 0.2, f.getCumPct(0), tolerance); assertEquals("1 pct", 0.6, f.getPct(Integer.valueOf(1)), tolerance); assertEquals("-2 cum pct", 0, f.getCumPct(-2), tolerance); assertEquals("10 cum pct", 1, f.getCumPct(10), tolerance); f = null; f = new Frequency(String.CASE_INSENSITIVE_ORDER); f.addValue("one"); f.addValue("One"); f.addValue("oNe"); f.addValue("Z"); assertEquals("one count", 3 , f.getCount("one")); assertEquals("Z cumulative pct -- case insensitive", 1 , f.getCumPct("Z"), tolerance); assertEquals("z cumulative pct -- case insensitive", 1 , f.getCumPct("z"), tolerance); f = null; f = new Frequency(); assertEquals(0L, f.getCount('a')); assertEquals(0L, f.getCumFreq('b')); TestUtils.assertEquals(Double.NaN, f.getPct('a'), 0.0); TestUtils.assertEquals(Double.NaN, f.getCumPct('b'), 0.0); f.addValue('a'); f.addValue('b'); f.addValue('c'); f.addValue('d'); assertEquals(1L, f.getCount('a')); assertEquals(2L, f.getCumFreq('b')); assertEquals(0.25, f.getPct('a'), 0.0); assertEquals(0.5, f.getCumPct('b'), 0.0); assertEquals(1.0, f.getCumPct('e'), 0.0); } /** test pcts */ public void testPcts() { f.addValue(oneL); f.addValue(twoL); f.addValue(oneI); f.addValue(twoI); f.addValue(threeL); f.addValue(threeL); f.addValue(3); f.addValue(threeI); assertEquals("one pct",0.25,f.getPct(1),tolerance); assertEquals("two pct",0.25,f.getPct(Long.valueOf(2)),tolerance); assertEquals("three pct",0.5,f.getPct(threeL),tolerance); assertEquals("five pct",0,f.getPct(5),tolerance); assertEquals("foo pct",0,f.getPct("foo"),tolerance); assertEquals("one cum pct",0.25,f.getCumPct(1),tolerance); assertEquals("two cum pct",0.50,f.getCumPct(Long.valueOf(2)),tolerance); assertEquals("Integer argument",0.50,f.getCumPct(Integer.valueOf(2)),tolerance); assertEquals("three cum pct",1.0,f.getCumPct(threeL),tolerance); assertEquals("five cum pct",1.0,f.getCumPct(5),tolerance); assertEquals("zero cum pct",0.0,f.getCumPct(0),tolerance); assertEquals("foo cum pct",0,f.getCumPct("foo"),tolerance); } /** test adding incomparable values */ public void testAdd() { char aChar = 'a'; char bChar = 'b'; String aString = "a"; f.addValue(aChar); f.addValue(bChar); try { f.addValue(aString); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } assertEquals("a pct",0.5,f.getPct(aChar),tolerance); assertEquals("b cum pct",1.0,f.getCumPct(bChar),tolerance); assertEquals("a string pct",0.0,f.getPct(aString),tolerance); assertEquals("a string cum pct",0.0,f.getCumPct(aString),tolerance); } /** test empty table */ public void testEmptyTable() { assertEquals("freq sum, empty table", 0, f.getSumFreq()); assertEquals("count, empty table", 0, f.getCount(0)); assertEquals("count, empty table",0, f.getCount(Integer.valueOf(0))); assertEquals("cum freq, empty table", 0, f.getCumFreq(0)); assertEquals("cum freq, empty table", 0, f.getCumFreq("x")); assertTrue("pct, empty table", Double.isNaN(f.getPct(0))); assertTrue("pct, empty table", Double.isNaN(f.getPct(Integer.valueOf(0)))); assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(0))); assertTrue("cum pct, empty table", Double.isNaN(f.getCumPct(Integer.valueOf(0)))); } /** * Tests toString() */ public void testToString(){ f.addValue(oneL); f.addValue(twoL); f.addValue(oneI); f.addValue(twoI); String s = f.toString(); //System.out.println(s); assertNotNull(s); BufferedReader reader = new BufferedReader(new StringReader(s)); try { String line = reader.readLine(); // header line assertNotNull(line); line = reader.readLine(); // one's or two's line assertNotNull(line); line = reader.readLine(); // one's or two's line assertNotNull(line); line = reader.readLine(); // no more elements assertNull(line); } catch(IOException ex){ fail(ex.getMessage()); } } public void testIntegerValues() { Object obj1 = null; obj1 = Integer.valueOf(1); Integer int1 = Integer.valueOf(1); f.addValue(obj1); f.addValue(int1); f.addValue(2); f.addValue(Long.valueOf(2)); assertEquals("Integer 1 count", 2, f.getCount(1)); assertEquals("Integer 1 count", 2, f.getCount(Integer.valueOf(1))); assertEquals("Integer 1 count", 2, f.getCount(Long.valueOf(1))); assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(1), tolerance); assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Long.valueOf(1)), tolerance); assertEquals("Integer 1 cumPct", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance); Iterator it = f.valuesIterator(); while (it.hasNext()) { assertTrue(it.next() instanceof Long); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.TestUtils; /** * Test cases for the {@link StatUtils} class. * @version $Revision$ $Date$ */ public final class StatUtilsTest extends TestCase { private double one = 1; private float two = 2; private int three = 3; private double mean = 2; private double sumSq = 18; private double sum = 8; private double var = 0.666666666666666666667; private double min = 1; private double max = 3; private double tolerance = 10E-15; private double nan = Double.NaN; public StatUtilsTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(StatUtilsTest.class); suite.setName("StatUtil Tests"); return suite; } /** test stats */ public void testStats() { double[] values = new double[] { one, two, two, three }; assertEquals("sum", sum, StatUtils.sum(values), tolerance); assertEquals("sumsq", sumSq, StatUtils.sumSq(values), tolerance); assertEquals("var", var, StatUtils.variance(values), tolerance); assertEquals("var with mean", var, StatUtils.variance(values, mean), tolerance); assertEquals("mean", mean, StatUtils.mean(values), tolerance); assertEquals("min", min, StatUtils.min(values), tolerance); assertEquals("max", max, StatUtils.max(values), tolerance); } public void testN0andN1Conditions() throws Exception { double[] values = new double[0]; assertTrue( "Mean of n = 0 set should be NaN", Double.isNaN(StatUtils.mean(values))); assertTrue( "Variance of n = 0 set should be NaN", Double.isNaN(StatUtils.variance(values))); values = new double[] { one }; assertTrue( "Mean of n = 1 set should be value of single item n1", StatUtils.mean(values) == one); assertTrue( "Variance of n = 1 set should be zero", StatUtils.variance(values) == 0); } public void testArrayIndexConditions() throws Exception { double[] values = { 1.0, 2.0, 3.0, 4.0 }; assertEquals( "Sum not expected", 5.0, StatUtils.sum(values, 1, 2), Double.MIN_VALUE); assertEquals( "Sum not expected", 3.0, StatUtils.sum(values, 0, 2), Double.MIN_VALUE); assertEquals( "Sum not expected", 7.0, StatUtils.sum(values, 2, 2), Double.MIN_VALUE); try { StatUtils.sum(values, 2, 3); assertTrue("Didn't throw exception", false); } catch (Exception e) { assertTrue(true); } try { StatUtils.sum(values, -1, 2); assertTrue("Didn't throw exception", false); } catch (Exception e) { assertTrue(true); } } public void testSumSq() { double[] x = null; // test null try { StatUtils.sumSq(x); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } try { StatUtils.sumSq(x, 0, 4); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance); TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance); // test one x = new double[] {two}; TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance); TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance); // test many x = new double[] {one, two, two, three}; TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance); TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance); } public void testProduct() { double[] x = null; // test null try { StatUtils.product(x); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } try { StatUtils.product(x, 0, 4); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance); TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance); // test one x = new double[] {two}; TestUtils.assertEquals(two, StatUtils.product(x), tolerance); TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance); // test many x = new double[] {one, two, two, three}; TestUtils.assertEquals(12, StatUtils.product(x), tolerance); TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance); } public void testSumLog() { double[] x = null; // test null try { StatUtils.sumLog(x); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } try { StatUtils.sumLog(x, 0, 4); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance); TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance); // test one x = new double[] {two}; TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance); TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance); // test many x = new double[] {one, two, two, three}; TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance); TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance); } public void testMean() { double[] x = null; try { StatUtils.mean(x, 0, 4); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance); // test one x = new double[] {two}; TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance); // test many x = new double[] {one, two, two, three}; TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance); } public void testVariance() { double[] x = null; try { StatUtils.variance(x, 0, 4); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance); // test one x = new double[] {two}; TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance); // test many x = new double[] {one, two, two, three}; TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance); // test precomputed mean x = new double[] {one, two, two, three}; TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance); } public void testMax() { double[] x = null; try { StatUtils.max(x, 0, 4); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance); // test one x = new double[] {two}; TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance); // test many x = new double[] {one, two, two, three}; TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance); // test first nan is ignored x = new double[] {nan, two, three}; TestUtils.assertEquals(three, StatUtils.max(x), tolerance); // test middle nan is ignored x = new double[] {one, nan, three}; TestUtils.assertEquals(three, StatUtils.max(x), tolerance); // test last nan is ignored x = new double[] {one, two, nan}; TestUtils.assertEquals(two, StatUtils.max(x), tolerance); // test all nan returns nan x = new double[] {nan, nan, nan}; TestUtils.assertEquals(nan, StatUtils.max(x), tolerance); } public void testMin() { double[] x = null; try { StatUtils.min(x, 0, 4); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance); // test one x = new double[] {two}; TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance); // test many x = new double[] {one, two, two, three}; TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance); // test first nan is ignored x = new double[] {nan, two, three}; TestUtils.assertEquals(two, StatUtils.min(x), tolerance); // test middle nan is ignored x = new double[] {one, nan, three}; TestUtils.assertEquals(one, StatUtils.min(x), tolerance); // test last nan is ignored x = new double[] {one, two, nan}; TestUtils.assertEquals(one, StatUtils.min(x), tolerance); // test all nan returns nan x = new double[] {nan, nan, nan}; TestUtils.assertEquals(nan, StatUtils.min(x), tolerance); } public void testPercentile() { double[] x = null; // test null try { StatUtils.percentile(x, .25); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } try { StatUtils.percentile(x, 0, 4, 0.25); fail("null is not a valid data array."); } catch (IllegalArgumentException ex) { // success } // test empty x = new double[] {}; TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance); TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance); // test one x = new double[] {two}; TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance); TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance); // test many x = new double[] {one, two, two, three}; TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance); TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance); } public void testDifferenceStats() throws Exception { double sample1[] = {1d, 2d, 3d, 4d}; double sample2[] = {1d, 3d, 4d, 2d}; double diff[] = {0d, -1d, -1d, 2d}; double small[] = {1d, 4d}; double meanDifference = StatUtils.meanDifference(sample1, sample2); assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance); assertEquals(meanDifference, StatUtils.mean(diff), tolerance); assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference), StatUtils.variance(diff), tolerance); try { StatUtils.meanDifference(sample1, small); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { StatUtils.varianceDifference(sample1, small, meanDifference); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { double[] single = {1.0}; StatUtils.varianceDifference(single, single, meanDifference); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } public void testGeometricMean() throws Exception { double[] test = null; try { StatUtils.geometricMean(test); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } test = new double[] {2, 4, 6, 8}; assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)), StatUtils.geometricMean(test), Double.MIN_VALUE); assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)), StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import java.io.BufferedReader; import java.io.InputStreamReader; import org.apache.commons.math.stat.descriptive.SummaryStatistics; import org.apache.commons.math.stat.descriptive.DescriptiveStatistics; /** * Certified data test cases. * @version $Revision$ $Date$ */ public class CertifiedDataTest extends TestCase { protected double mean = Double.NaN; protected double std = Double.NaN; /** * Certified Data Test Constructor * @param name */ public CertifiedDataTest(String name) { super(name); } /* (non-Javadoc) * @see junit.framework.TestCase#setUp() */ public void setUp() { } /** * @return The test suite */ public static Test suite() { TestSuite suite = new TestSuite(CertifiedDataTest.class); suite.setName("Certified Tests"); return suite; } /** * Test SummaryStatistics - implementations that do not store the data * and use single pass algorithms to compute statistics */ public void testSummaryStatistics() throws Exception { SummaryStatistics u = new SummaryStatistics(); loadStats("data/PiDigits.txt", u); assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-13); assertEquals("PiDigits: mean", mean, u.getMean(), 1E-13); loadStats("data/Mavro.txt", u); assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14); assertEquals("Mavro: mean", mean, u.getMean(), 1E-14); loadStats("data/Michelso.txt", u); assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-13); assertEquals("Michelso: mean", mean, u.getMean(), 1E-13); loadStats("data/NumAcc1.txt", u); assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14); assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14); loadStats("data/NumAcc2.txt", u); assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14); assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14); } /** * Test DescriptiveStatistics - implementations that store full array of * values and execute multi-pass algorithms */ public void testDescriptiveStatistics() throws Exception { DescriptiveStatistics u = new DescriptiveStatistics(); loadStats("data/PiDigits.txt", u); assertEquals("PiDigits: std", std, u.getStandardDeviation(), 1E-14); assertEquals("PiDigits: mean", mean, u.getMean(), 1E-14); loadStats("data/Mavro.txt", u); assertEquals("Mavro: std", std, u.getStandardDeviation(), 1E-14); assertEquals("Mavro: mean", mean, u.getMean(), 1E-14); loadStats("data/Michelso.txt", u); assertEquals("Michelso: std", std, u.getStandardDeviation(), 1E-14); assertEquals("Michelso: mean", mean, u.getMean(), 1E-14); loadStats("data/NumAcc1.txt", u); assertEquals("NumAcc1: std", std, u.getStandardDeviation(), 1E-14); assertEquals("NumAcc1: mean", mean, u.getMean(), 1E-14); loadStats("data/NumAcc2.txt", u); assertEquals("NumAcc2: std", std, u.getStandardDeviation(), 1E-14); assertEquals("NumAcc2: mean", mean, u.getMean(), 1E-14); } /** * loads a DescriptiveStatistics off of a test file * @param file * @param statistical summary */ private void loadStats(String resource, Object u) throws Exception { DescriptiveStatistics d = null; SummaryStatistics s = null; if (u instanceof DescriptiveStatistics) { d = (DescriptiveStatistics) u; } else { s = (SummaryStatistics) u; } u.getClass().getDeclaredMethod( "clear", new Class[]{}).invoke(u, new Object[]{}); mean = Double.NaN; std = Double.NaN; BufferedReader in = new BufferedReader( new InputStreamReader( CertifiedDataTest.class.getResourceAsStream(resource))); String line = null; for (int j = 0; j < 60; j++) { line = in.readLine(); if (j == 40) { mean = Double.parseDouble( line.substring(line.lastIndexOf(":") + 1).trim()); } if (j == 41) { std = Double.parseDouble( line.substring(line.lastIndexOf(":") + 1).trim()); } } line = in.readLine(); while (line != null) { if (d != null) { d.addValue(Double.parseDouble(line.trim())); } else { s.addValue(Double.parseDouble(line.trim())); } line = in.readLine(); } in.close(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.regression; import org.apache.commons.math.TestUtils; import org.junit.Before; import org.junit.Test; public class OLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest { private double[] y; private double[][] x; @Before public void setUp(){ y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0}; x = new double[6][]; x[0] = new double[]{1.0, 0, 0, 0, 0, 0}; x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0}; x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0}; x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0}; x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0}; x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0}; super.setUp(); } protected OLSMultipleLinearRegression createRegression() { OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression(); regression.newSampleData(y, x); return regression; } protected int getNumberOfRegressors() { return x[0].length; } protected int getSampleSize() { return y.length; } @Test(expected=IllegalArgumentException.class) public void cannotAddXSampleData() { createRegression().newSampleData(new double[]{}, null); } @Test(expected=IllegalArgumentException.class) public void cannotAddNullYSampleData() { createRegression().newSampleData(null, new double[][]{}); } @Test(expected=IllegalArgumentException.class) public void cannotAddSampleDataWithSizeMismatch() { double[] y = new double[]{1.0, 2.0}; double[][] x = new double[1][]; x[0] = new double[]{1.0, 0}; createRegression().newSampleData(y, x); } @Test public void testPerfectFit() { double[] betaHat = regression.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{11.0,0.5,0.666666666666667,0.75,0.8,0.8333333333333333}, 1e-12); double[] residuals = regression.estimateResiduals(); TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d}, 1e-12); double[][] errors = regression.estimateRegressionParametersVariance(); // TODO: translate this into standard error vector and check } /** * Test Longley dataset against certified values provided by NIST. * Data Source: J. Longley (1967) "An Appraisal of Least Squares * Programs for the Electronic Computer from the Point of View of the User" * Journal of the American Statistical Association, vol. 62. September, * pp. 819-841. * * Certified values (and data) are from NIST: * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat */ @Test public void testLongly() { // Y values are first, then independent vars // Each row is one observation double[] design = new double[] { 60323,83.0,234289,2356,1590,107608,1947, 61122,88.5,259426,2325,1456,108632,1948, 60171,88.2,258054,3682,1616,109773,1949, 61187,89.5,284599,3351,1650,110929,1950, 63221,96.2,328975,2099,3099,112075,1951, 63639,98.1,346999,1932,3594,113270,1952, 64989,99.0,365385,1870,3547,115094,1953, 63761,100.0,363112,3578,3350,116219,1954, 66019,101.2,397469,2904,3048,117388,1955, 67857,104.6,419180,2822,2857,118734,1956, 68169,108.4,442769,2936,2798,120445,1957, 66513,110.8,444546,4681,2637,121950,1958, 68655,112.6,482704,3813,2552,123366,1959, 69564,114.2,502601,3931,2514,125368,1960, 69331,115.7,518173,4806,2572,127852,1961, 70551,116.9,554894,4007,2827,130081,1962 }; // Transform to Y and X required by interface int nobs = 16; int nvars = 6; // Estimate the model OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); model.newSampleData(design, nobs, nvars); // Check expected beta values from NIST double[] betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{-3482258.63459582, 15.0618722713733, -0.358191792925910E-01,-2.02022980381683, -1.03322686717359,-0.511041056535807E-01, 1829.15146461355}, 1E-8); // // Check expected residuals from R double[] residuals = model.estimateResiduals(); TestUtils.assertEquals(residuals, new double[]{ 267.340029759711,-94.0139423988359,46.28716775752924, -410.114621930906,309.7145907602313,-249.3112153297231, -164.0489563956039,-13.18035686637081,14.30477260005235, 455.394094551857,-17.26892711483297,-39.0550425226967, -155.5499735953195,-85.6713080421283,341.9315139607727, -206.7578251937366}, 1E-8); // Check standard errors from NIST double[][] errors = model.estimateRegressionParametersVariance(); //TODO: translate this into std error vector and check } /** * Test R Swiss fertility dataset against R. * Data Source: R datasets package */ @Test public void testSwissFertility() { double[] design = new double[] { 80.2,17.0,15,12,9.96, 83.1,45.1,6,9,84.84, 92.5,39.7,5,5,93.40, 85.8,36.5,12,7,33.77, 76.9,43.5,17,15,5.16, 76.1,35.3,9,7,90.57, 83.8,70.2,16,7,92.85, 92.4,67.8,14,8,97.16, 82.4,53.3,12,7,97.67, 82.9,45.2,16,13,91.38, 87.1,64.5,14,6,98.61, 64.1,62.0,21,12,8.52, 66.9,67.5,14,7,2.27, 68.9,60.7,19,12,4.43, 61.7,69.3,22,5,2.82, 68.3,72.6,18,2,24.20, 71.7,34.0,17,8,3.30, 55.7,19.4,26,28,12.11, 54.3,15.2,31,20,2.15, 65.1,73.0,19,9,2.84, 65.5,59.8,22,10,5.23, 65.0,55.1,14,3,4.52, 56.6,50.9,22,12,15.14, 57.4,54.1,20,6,4.20, 72.5,71.2,12,1,2.40, 74.2,58.1,14,8,5.23, 72.0,63.5,6,3,2.56, 60.5,60.8,16,10,7.72, 58.3,26.8,25,19,18.46, 65.4,49.5,15,8,6.10, 75.5,85.9,3,2,99.71, 69.3,84.9,7,6,99.68, 77.3,89.7,5,2,100.00, 70.5,78.2,12,6,98.96, 79.4,64.9,7,3,98.22, 65.0,75.9,9,9,99.06, 92.2,84.6,3,3,99.46, 79.3,63.1,13,13,96.83, 70.4,38.4,26,12,5.62, 65.7,7.7,29,11,13.79, 72.7,16.7,22,13,11.22, 64.4,17.6,35,32,16.92, 77.6,37.6,15,7,4.97, 67.6,18.7,25,7,8.65, 35.0,1.2,37,53,42.34, 44.7,46.6,16,29,50.43, 42.8,27.7,22,29,58.33 }; // Transform to Y and X required by interface int nobs = 47; int nvars = 4; // Estimate the model OLSMultipleLinearRegression model = new OLSMultipleLinearRegression(); model.newSampleData(design, nobs, nvars); // Check expected beta values from R double[] betaHat = model.estimateRegressionParameters(); TestUtils.assertEquals(betaHat, new double[]{91.05542390271397, -0.22064551045715, -0.26058239824328, -0.96161238456030, 0.12441843147162}, 1E-12); // Check expected residuals from R double[] residuals = model.estimateResiduals(); TestUtils.assertEquals(residuals, new double[]{ 7.1044267859730512,1.6580347433531366, 4.6944952770029644,8.4548022690166160,13.6547432343186212, -9.3586864458500774,7.5822446330520386,15.5568995563859289, 0.8113090736598980,7.1186762732484308,7.4251378771228724, 2.6761316873234109,0.8351584810309354,7.1769991119615177, -3.8746753206299553,-3.1337779476387251,-0.1412575244091504, 1.1186809170469780,-6.3588097346816594,3.4039270429434074, 2.3374058329820175,-7.9272368576900503,-7.8361010968497959, -11.2597369269357070,0.9445333697827101,6.6544245101380328, -0.9146136301118665,-4.3152449403848570,-4.3536932047009183, -3.8907885169304661,-6.3027643926302188,-7.8308982189289091, -3.1792280015332750,-6.7167298771158226,-4.8469946718041754, -10.6335664353633685,11.1031134362036958,6.0084032641811733, 5.4326230830188482,-7.2375578629692230,2.1671550814448222, 15.0147574652763112,4.8625103516321015,-7.1597256413907706, -0.4515205619767598,-10.2916870903837587,-15.7812984571900063}, 1E-12); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.regression; import java.util.Random; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test cases for the TestStatistic class. * * @version $Revision$ $Date$ */ public final class SimpleRegressionTest extends TestCase { /* * NIST "Norris" refernce data set from * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat * Strangely, order is {y,x} */ private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 }, {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 }, {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 }, {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 }, {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 }, {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 }, {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 }, {449.2, 448.9 }, {0.2, 0.5 } }; /* * Correlation example from * http://www.xycoon.com/correlation.htm */ private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 }, {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 }, {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 }, {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 } }; /* * From Moore and Mcabe, "Introduction to the Practice of Statistics" * Example 10.3 */ private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 }, {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 } }; /* * Points to remove in the remove tests */ private double[][] removeSingle = {infData[1]}; private double[][] removeMultiple = { infData[1], infData[2] }; private double removeX = infData[0][0]; private double removeY = infData[0][1]; /* * Data with bad linear fit */ private double[][] infData2 = { { 1, 1 }, {2, 0 }, {3, 5 }, {4, 2 }, {5, -1 }, {6, 12 } }; public SimpleRegressionTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(SimpleRegressionTest.class); suite.setName("BivariateRegression Tests"); return suite; } public void testNorris() { SimpleRegression regression = new SimpleRegression(); for (int i = 0; i < data.length; i++) { regression.addData(data[i][1], data[i][0]); } // Tests against certified values from // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat assertEquals("slope", 1.00211681802045, regression.getSlope(), 10E-12); assertEquals("slope std err", 0.429796848199937E-03, regression.getSlopeStdErr(),10E-12); assertEquals("number of observations", 36, regression.getN()); assertEquals( "intercept", -0.262323073774029, regression.getIntercept(),10E-12); assertEquals("std err intercept", 0.232818234301152, regression.getInterceptStdErr(),10E-12); assertEquals("r-square", 0.999993745883712, regression.getRSquare(), 10E-12); assertEquals("SSR", 4255954.13232369, regression.getRegressionSumSquares(), 10E-9); assertEquals("MSE", 0.782864662630069, regression.getMeanSquareError(), 10E-10); assertEquals("SSE", 26.6173985294224, regression.getSumSquaredErrors(),10E-9); // ------------ End certified data tests assertEquals( "predict(0)", -0.262323073774029, regression.predict(0), 10E-12); assertEquals("predict(1)", 1.00211681802045 - 0.262323073774029, regression.predict(1), 10E-12); } public void testCorr() { SimpleRegression regression = new SimpleRegression(); regression.addData(corrData); assertEquals("number of observations", 17, regression.getN()); assertEquals("r-square", .896123, regression.getRSquare(), 10E-6); assertEquals("r", -0.94663767742, regression.getR(), 1E-10); } public void testNaNs() { SimpleRegression regression = new SimpleRegression(); assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept())); assertTrue("slope not NaN", Double.isNaN(regression.getSlope())); assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr())); assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr())); assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError())); assertTrue("e not NaN", Double.isNaN(regression.getR())); assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare())); assertTrue( "RSS not NaN", Double.isNaN(regression.getRegressionSumSquares())); assertTrue("SSE not NaN",Double.isNaN(regression.getSumSquaredErrors())); assertTrue("SSTO not NaN", Double.isNaN(regression.getTotalSumSquares())); assertTrue("predict not NaN", Double.isNaN(regression.predict(0))); regression.addData(1, 2); regression.addData(1, 3); // No x variation, so these should still blow... assertTrue("intercept not NaN", Double.isNaN(regression.getIntercept())); assertTrue("slope not NaN", Double.isNaN(regression.getSlope())); assertTrue("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr())); assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr())); assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError())); assertTrue("e not NaN", Double.isNaN(regression.getR())); assertTrue("r-square not NaN", Double.isNaN(regression.getRSquare())); assertTrue("RSS not NaN", Double.isNaN(regression.getRegressionSumSquares())); assertTrue("SSE not NaN", Double.isNaN(regression.getSumSquaredErrors())); assertTrue("predict not NaN", Double.isNaN(regression.predict(0))); // but SSTO should be OK assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares())); regression = new SimpleRegression(); regression.addData(1, 2); regression.addData(3, 3); // All should be OK except MSE, s(b0), s(b1) which need one more df assertTrue("interceptNaN", !Double.isNaN(regression.getIntercept())); assertTrue("slope NaN", !Double.isNaN(regression.getSlope())); assertTrue ("slope std err not NaN", Double.isNaN(regression.getSlopeStdErr())); assertTrue("intercept std err not NaN", Double.isNaN(regression.getInterceptStdErr())); assertTrue("MSE not NaN", Double.isNaN(regression.getMeanSquareError())); assertTrue("r NaN", !Double.isNaN(regression.getR())); assertTrue("r-square NaN", !Double.isNaN(regression.getRSquare())); assertTrue("RSS NaN", !Double.isNaN(regression.getRegressionSumSquares())); assertTrue("SSE NaN", !Double.isNaN(regression.getSumSquaredErrors())); assertTrue("SSTO NaN", !Double.isNaN(regression.getTotalSumSquares())); assertTrue("predict NaN", !Double.isNaN(regression.predict(0))); regression.addData(1, 4); // MSE, MSE, s(b0), s(b1) should all be OK now assertTrue("MSE NaN", !Double.isNaN(regression.getMeanSquareError())); assertTrue("slope std err NaN", !Double.isNaN(regression.getSlopeStdErr())); assertTrue("intercept std err NaN", !Double.isNaN(regression.getInterceptStdErr())); } public void testClear() { SimpleRegression regression = new SimpleRegression(); regression.addData(corrData); assertEquals("number of observations", 17, regression.getN()); regression.clear(); assertEquals("number of observations", 0, regression.getN()); regression.addData(corrData); assertEquals("r-square", .896123, regression.getRSquare(), 10E-6); regression.addData(data); assertEquals("number of observations", 53, regression.getN()); } public void testInference() throws Exception { //---------- verified against R, version 1.8.1 ----- // infData SimpleRegression regression = new SimpleRegression(); regression.addData(infData); assertEquals("slope std err", 0.011448491, regression.getSlopeStdErr(), 1E-10); assertEquals("std err intercept", 0.286036932, regression.getInterceptStdErr(),1E-8); assertEquals("significance", 4.596e-07, regression.getSignificance(),1E-8); assertEquals("slope conf interval half-width", 0.0270713794287, regression.getSlopeConfidenceInterval(),1E-8); // infData2 regression = new SimpleRegression(); regression.addData(infData2); assertEquals("slope std err", 1.07260253, regression.getSlopeStdErr(), 1E-8); assertEquals("std err intercept",4.17718672, regression.getInterceptStdErr(),1E-8); assertEquals("significance", 0.261829133982, regression.getSignificance(),1E-11); assertEquals("slope conf interval half-width", 2.97802204827, regression.getSlopeConfidenceInterval(),1E-8); //------------- End R-verified tests ------------------------------- //FIXME: get a real example to test against with alpha = .01 assertTrue("tighter means wider", regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01)); try { regression.getSlopeConfidenceInterval(1); fail("expecting IllegalArgumentException for alpha = 1"); } catch (IllegalArgumentException ex) { ; } } public void testPerfect() throws Exception { SimpleRegression regression = new SimpleRegression(); int n = 100; for (int i = 0; i < n; i++) { regression.addData(((double) i) / (n - 1), i); } assertEquals(0.0, regression.getSignificance(), 1.0e-5); assertTrue(regression.getSlope() > 0.0); assertTrue(regression.getSumSquaredErrors() >= 0.0); } public void testPerfectNegative() throws Exception { SimpleRegression regression = new SimpleRegression(); int n = 100; for (int i = 0; i < n; i++) { regression.addData(- ((double) i) / (n - 1), i); } assertEquals(0.0, regression.getSignificance(), 1.0e-5); assertTrue(regression.getSlope() < 0.0); } public void testRandom() throws Exception { SimpleRegression regression = new SimpleRegression(); Random random = new Random(1); int n = 100; for (int i = 0; i < n; i++) { regression.addData(((double) i) / (n - 1), random.nextDouble()); } assertTrue( 0.0 < regression.getSignificance() && regression.getSignificance() < 1.0); } // Jira MATH-85 = Bugzilla 39432 public void testSSENonNegative() { double[] y = { 8915.102, 8919.302, 8923.502 }; double[] x = { 1.107178495E2, 1.107264895E2, 1.107351295E2 }; SimpleRegression reg = new SimpleRegression(); for (int i = 0; i < x.length; i++) { reg.addData(x[i], y[i]); } assertTrue(reg.getSumSquaredErrors() >= 0.0); } // Test remove X,Y (single observation) public void testRemoveXY() throws Exception { // Create regression with inference data then remove to test SimpleRegression regression = new SimpleRegression(); regression.addData(infData); regression.removeData(removeX, removeY); regression.addData(removeX, removeY); // Use the inference assertions to make sure that everything worked assertEquals("slope std err", 0.011448491, regression.getSlopeStdErr(), 1E-10); assertEquals("std err intercept", 0.286036932, regression.getInterceptStdErr(),1E-8); assertEquals("significance", 4.596e-07, regression.getSignificance(),1E-8); assertEquals("slope conf interval half-width", 0.0270713794287, regression.getSlopeConfidenceInterval(),1E-8); } // Test remove single observation in array public void testRemoveSingle() throws Exception { // Create regression with inference data then remove to test SimpleRegression regression = new SimpleRegression(); regression.addData(infData); regression.removeData(removeSingle); regression.addData(removeSingle); // Use the inference assertions to make sure that everything worked assertEquals("slope std err", 0.011448491, regression.getSlopeStdErr(), 1E-10); assertEquals("std err intercept", 0.286036932, regression.getInterceptStdErr(),1E-8); assertEquals("significance", 4.596e-07, regression.getSignificance(),1E-8); assertEquals("slope conf interval half-width", 0.0270713794287, regression.getSlopeConfidenceInterval(),1E-8); } // Test remove multiple observations public void testRemoveMultiple() throws Exception { // Create regression with inference data then remove to test SimpleRegression regression = new SimpleRegression(); regression.addData(infData); regression.removeData(removeMultiple); regression.addData(removeMultiple); // Use the inference assertions to make sure that everything worked assertEquals("slope std err", 0.011448491, regression.getSlopeStdErr(), 1E-10); assertEquals("std err intercept", 0.286036932, regression.getInterceptStdErr(),1E-8); assertEquals("significance", 4.596e-07, regression.getSignificance(),1E-8); assertEquals("slope conf interval half-width", 0.0270713794287, regression.getSlopeConfidenceInterval(),1E-8); } // Remove observation when empty public void testRemoveObsFromEmpty() { SimpleRegression regression = new SimpleRegression(); regression.removeData(removeX, removeY); assertEquals(regression.getN(), 0); } // Remove single observation to empty public void testRemoveObsFromSingle() { SimpleRegression regression = new SimpleRegression(); regression.addData(removeX, removeY); regression.removeData(removeX, removeY); assertEquals(regression.getN(), 0); } // Remove multiple observations to empty public void testRemoveMultipleToEmpty() { SimpleRegression regression = new SimpleRegression(); regression.addData(removeMultiple); regression.removeData(removeMultiple); assertEquals(regression.getN(), 0); } // Remove multiple observations past empty (i.e. size of array > n) public void testRemoveMultiplePastEmpty() { SimpleRegression regression = new SimpleRegression(); regression.addData(removeX, removeY); regression.removeData(removeMultiple); assertEquals(regression.getN(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.regression; import org.junit.Before; import org.junit.Test; public class GLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest { private double[] y; private double[][] x; private double[][] omega; @Before public void setUp(){ y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0}; x = new double[6][]; x[0] = new double[]{1.0, 0, 0, 0, 0, 0}; x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0}; x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0}; x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0}; x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0}; x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0}; omega = new double[6][]; omega[0] = new double[]{1.0, 0, 0, 0, 0, 0}; omega[1] = new double[]{0, 2.0, 0, 0, 0, 0}; omega[2] = new double[]{0, 0, 3.0, 0, 0, 0}; omega[3] = new double[]{0, 0, 0, 4.0, 0, 0}; omega[4] = new double[]{0, 0, 0, 0, 5.0, 0}; omega[5] = new double[]{0, 0, 0, 0, 0, 6.0}; super.setUp(); } @Test(expected=IllegalArgumentException.class) public void cannotAddXSampleData() { createRegression().newSampleData(new double[]{}, null, null); } @Test(expected=IllegalArgumentException.class) public void cannotAddNullYSampleData() { createRegression().newSampleData(null, new double[][]{}, null); } @Test(expected=IllegalArgumentException.class) public void cannotAddSampleDataWithSizeMismatch() { double[] y = new double[]{1.0, 2.0}; double[][] x = new double[1][]; x[0] = new double[]{1.0, 0}; createRegression().newSampleData(y, x, null); } @Test(expected=IllegalArgumentException.class) public void cannotAddNullCovarianceData() { createRegression().newSampleData(new double[]{}, new double[][]{}, null); } @Test(expected=IllegalArgumentException.class) public void cannotAddCovarianceDataWithSampleSizeMismatch() { double[] y = new double[]{1.0, 2.0}; double[][] x = new double[2][]; x[0] = new double[]{1.0, 0}; x[1] = new double[]{0, 1.0}; double[][] omega = new double[1][]; omega[0] = new double[]{1.0, 0}; createRegression().newSampleData(y, x, omega); } @Test(expected=IllegalArgumentException.class) public void cannotAddCovarianceDataThatIsNotSquare() { double[] y = new double[]{1.0, 2.0}; double[][] x = new double[2][]; x[0] = new double[]{1.0, 0}; x[1] = new double[]{0, 1.0}; double[][] omega = new double[3][]; omega[0] = new double[]{1.0, 0}; omega[1] = new double[]{0, 1.0}; omega[2] = new double[]{0, 2.0}; createRegression().newSampleData(y, x, omega); } protected GLSMultipleLinearRegression createRegression() { GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression(); regression.newSampleData(y, x, omega); return regression; } protected int getNumberOfRegressors() { return x[0].length; } protected int getSampleSize() { return y.length; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.regression; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue; import org.junit.Before; import org.junit.Test; public abstract class AbstractMultipleLinearRegressionTest { protected MultipleLinearRegression regression; @Before public void setUp(){ regression = createRegression(); } protected abstract MultipleLinearRegression createRegression(); protected abstract int getNumberOfRegressors(); protected abstract int getSampleSize(); @Test public void canEstimateRegressionParameters(){ double[] beta = regression.estimateRegressionParameters(); assertEquals(getNumberOfRegressors(), beta.length); } @Test public void canEstimateResiduals(){ double[] e = regression.estimateResiduals(); assertEquals(getSampleSize(), e.length); } @Test public void canEstimateRegressionParametersVariance(){ double[][] variance = regression.estimateRegressionParametersVariance(); assertEquals(getNumberOfRegressors(), variance.length); } @Test public void canEstimateRegressandVariance(){ if (getSampleSize() > getNumberOfRegressors()) { double variance = regression.estimateRegressandVariance(); assertTrue(variance > 0.0); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import java.util.ArrayList; import java.util.List; import org.apache.commons.math.TestUtils; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Revision$ $Date$ */ public final class ListUnivariateImplTest extends TestCase { private double one = 1; private float two = 2; private int three = 3; private double mean = 2; private double sumSq = 18; private double sum = 8; private double var = 0.666666666666666666667; private double std = Math.sqrt(var); private double n = 4; private double min = 1; private double max = 3; private double tolerance = 10E-15; public ListUnivariateImplTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(ListUnivariateImplTest.class); suite.setName("Frequency Tests"); return suite; } /** test stats */ public void testStats() { List<Object> externalList = new ArrayList<Object>(); DescriptiveStatistics u = new ListUnivariateImpl( externalList ); assertEquals("total count",0,u.getN(),tolerance); u.addValue(one); u.addValue(two); u.addValue(two); u.addValue(three); assertEquals("N",n,u.getN(),tolerance); assertEquals("sum",sum,u.getSum(),tolerance); assertEquals("sumsq",sumSq,u.getSumsq(),tolerance); assertEquals("var",var,u.getVariance(),tolerance); assertEquals("std",std,u.getStandardDeviation(),tolerance); assertEquals("mean",mean,u.getMean(),tolerance); assertEquals("min",min,u.getMin(),tolerance); assertEquals("max",max,u.getMax(),tolerance); u.clear(); assertEquals("total count",0,u.getN(),tolerance); } public void testN0andN1Conditions() throws Exception { List<Object> list = new ArrayList<Object>(); DescriptiveStatistics u = new ListUnivariateImpl( list ); assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) ); assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) ); assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) ); list.add( Double.valueOf(one)); assertTrue( "Mean of n = 1 set should be value of single item n1", u.getMean() == one); assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0); assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0); } public void testSkewAndKurtosis() { DescriptiveStatistics u = new DescriptiveStatistics(); double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 }; for( int i = 0; i < testArray.length; i++) { u.addValue( testArray[i]); } assertEquals("mean", 12.40455, u.getMean(), 0.0001); assertEquals("variance", 10.00236, u.getVariance(), 0.0001); assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001); assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001); } public void testProductAndGeometricMean() throws Exception { ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>()); u.setWindowSize(10); u.addValue( 1.0 ); u.addValue( 2.0 ); u.addValue( 3.0 ); u.addValue( 4.0 ); assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 ); // Now test rolling - StorelessDescriptiveStatistics should discount the contribution // of a discarded element for( int i = 0; i < 10; i++ ) { u.addValue( i + 2 ); } // Values should be (2,3,4,5,6,7,8,9,10,11) assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001 ); } /** test stats */ public void testSerialization() { DescriptiveStatistics u = new ListUnivariateImpl(); assertEquals("total count",0,u.getN(),tolerance); u.addValue(one); u.addValue(two); DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); u2.addValue(two); u2.addValue(three); assertEquals("N",n,u2.getN(),tolerance); assertEquals("sum",sum,u2.getSum(),tolerance); assertEquals("sumsq",sumSq,u2.getSumsq(),tolerance); assertEquals("var",var,u2.getVariance(),tolerance); assertEquals("std",std,u2.getStandardDeviation(),tolerance); assertEquals("mean",mean,u2.getMean(),tolerance); assertEquals("min",min,u2.getMin(),tolerance); assertEquals("max",max,u2.getMax(),tolerance); u2.clear(); assertEquals("total count",0,u2.getN(),tolerance); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import junit.framework.TestCase; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public abstract class UnivariateStatisticAbstractTest extends TestCase { protected double mean = 12.404545454545455d; protected double geoMean = 12.070589161633011d; protected double var = 10.00235930735931d; protected double std = Math.sqrt(var); protected double skew = 1.437423729196190d; protected double kurt = 2.377191264804700d; protected double min = 8.2d; protected double max = 21d; protected double median = 12d; protected double percentile5 = 8.29d; protected double percentile95 = 20.82d; protected double product = 628096400563833396009676.9200400128d; protected double sumLog = 54.7969806116451507d; protected double sumSq = 3595.250d; protected double sum = 272.90d; protected double secondMoment = 210.04954545454547d; protected double thirdMoment = 868.0906859504136; protected double fourthMoment = 9244.080993773481; protected double tolerance = 10E-12; protected double[] testArray = {12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 }; public UnivariateStatisticAbstractTest(String name) { super(name); } public abstract UnivariateStatistic getUnivariateStatistic(); public abstract double expectedValue(); public double getTolerance() { return tolerance; } public void testEvaluation() throws Exception { assertEquals( expectedValue(), getUnivariateStatistic().evaluate(testArray), getTolerance()); } public void testCopy() throws Exception { UnivariateStatistic original = getUnivariateStatistic(); UnivariateStatistic copy = original.copy(); assertEquals( expectedValue(), copy.evaluate(testArray), getTolerance()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.TestUtils; import org.apache.commons.math.stat.descriptive.moment.Mean; import org.apache.commons.math.stat.descriptive.summary.Sum; /** * Test cases for the {@link SummaryStatistics} class. * * @version $Revision$ $Date$ */ public class SummaryStatisticsTest extends TestCase { private double one = 1; private float twoF = 2; private long twoL = 2; private int three = 3; private double mean = 2; private double sumSq = 18; private double sum = 8; private double var = 0.666666666666666666667; private double std = Math.sqrt(var); private double n = 4; private double min = 1; private double max = 3; private double tolerance = 10E-15; public static Test suite() { TestSuite suite = new TestSuite(SummaryStatisticsTest.class); suite.setName("SummaryStatistics tests"); return suite; } public SummaryStatisticsTest(String name) { super(name); } protected SummaryStatistics createSummaryStatistics() { return new SummaryStatistics(); } /** test stats */ public void testStats() { SummaryStatistics u = createSummaryStatistics(); assertEquals("total count",0,u.getN(),tolerance); u.addValue(one); u.addValue(twoF); u.addValue(twoL); u.addValue(three); assertEquals("N",n,u.getN(),tolerance); assertEquals("sum",sum,u.getSum(),tolerance); assertEquals("sumsq",sumSq,u.getSumsq(),tolerance); assertEquals("var",var,u.getVariance(),tolerance); assertEquals("std",std,u.getStandardDeviation(),tolerance); assertEquals("mean",mean,u.getMean(),tolerance); assertEquals("min",min,u.getMin(),tolerance); assertEquals("max",max,u.getMax(),tolerance); u.clear(); assertEquals("total count",0,u.getN(),tolerance); } public void testN0andN1Conditions() throws Exception { SummaryStatistics u = createSummaryStatistics(); assertTrue("Mean of n = 0 set should be NaN", Double.isNaN( u.getMean() ) ); assertTrue("Standard Deviation of n = 0 set should be NaN", Double.isNaN( u.getStandardDeviation() ) ); assertTrue("Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance() ) ); /* n=1 */ u.addValue(one); assertTrue("mean should be one (n = 1)", u.getMean() == one); assertTrue("geometric should be one (n = 1) instead it is " + u.getGeometricMean(), u.getGeometricMean() == one); assertTrue("Std should be zero (n = 1)", u.getStandardDeviation() == 0.0); assertTrue("variance should be zero (n = 1)", u.getVariance() == 0.0); /* n=2 */ u.addValue(twoF); assertTrue("Std should not be zero (n = 2)", u.getStandardDeviation() != 0.0); assertTrue("variance should not be zero (n = 2)", u.getVariance() != 0.0); } public void testProductAndGeometricMean() throws Exception { SummaryStatistics u = createSummaryStatistics(); u.addValue( 1.0 ); u.addValue( 2.0 ); u.addValue( 3.0 ); u.addValue( 4.0 ); assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001 ); } public void testNaNContracts() { SummaryStatistics u = createSummaryStatistics(); assertTrue("mean not NaN",Double.isNaN(u.getMean())); assertTrue("min not NaN",Double.isNaN(u.getMin())); assertTrue("std dev not NaN",Double.isNaN(u.getStandardDeviation())); assertTrue("var not NaN",Double.isNaN(u.getVariance())); assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean())); u.addValue(1.0); assertEquals( "mean not expected", 1.0, u.getMean(), Double.MIN_VALUE); assertEquals( "variance not expected", 0.0, u.getVariance(), Double.MIN_VALUE); assertEquals( "geometric mean not expected", 1.0, u.getGeometricMean(), Double.MIN_VALUE); u.addValue(-1.0); assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean())); u.addValue(0.0); assertTrue("geom mean not NaN",Double.isNaN(u.getGeometricMean())); //FiXME: test all other NaN contract specs } public void testGetSummary() { SummaryStatistics u = createSummaryStatistics(); StatisticalSummary summary = u.getSummary(); verifySummary(u, summary); u.addValue(1d); summary = u.getSummary(); verifySummary(u, summary); u.addValue(2d); summary = u.getSummary(); verifySummary(u, summary); u.addValue(2d); summary = u.getSummary(); verifySummary(u, summary); } public void testSerialization() { SummaryStatistics u = createSummaryStatistics(); // Empty test TestUtils.checkSerializedEquality(u); SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u); StatisticalSummary summary = s.getSummary(); verifySummary(u, summary); // Add some data u.addValue(2d); u.addValue(1d); u.addValue(3d); u.addValue(4d); u.addValue(5d); // Test again TestUtils.checkSerializedEquality(u); s = (SummaryStatistics) TestUtils.serializeAndRecover(u); summary = s.getSummary(); verifySummary(u, summary); } public void testEqualsAndHashCode() { SummaryStatistics u = createSummaryStatistics(); SummaryStatistics t = null; int emptyHash = u.hashCode(); assertTrue("reflexive", u.equals(u)); assertFalse("non-null compared to null", u.equals(t)); assertFalse("wrong type", u.equals(Double.valueOf(0))); t = createSummaryStatistics(); assertTrue("empty instances should be equal", t.equals(u)); assertTrue("empty instances should be equal", u.equals(t)); assertEquals("empty hash code", emptyHash, t.hashCode()); // Add some data to u u.addValue(2d); u.addValue(1d); u.addValue(3d); u.addValue(4d); assertFalse("different n's should make instances not equal", t.equals(u)); assertFalse("different n's should make instances not equal", u.equals(t)); assertTrue("different n's should make hashcodes different", u.hashCode() != t.hashCode()); //Add data in same order to t t.addValue(2d); t.addValue(1d); t.addValue(3d); t.addValue(4d); assertTrue("summaries based on same data should be equal", t.equals(u)); assertTrue("summaries based on same data should be equal", u.equals(t)); assertEquals("summaries based on same data should have same hashcodes", u.hashCode(), t.hashCode()); // Clear and make sure summaries are indistinguishable from empty summary u.clear(); t.clear(); assertTrue("empty instances should be equal", t.equals(u)); assertTrue("empty instances should be equal", u.equals(t)); assertEquals("empty hash code", emptyHash, t.hashCode()); assertEquals("empty hash code", emptyHash, u.hashCode()); } public void testCopy() throws Exception { SummaryStatistics u = createSummaryStatistics(); u.addValue(2d); u.addValue(1d); u.addValue(3d); u.addValue(4d); SummaryStatistics v = new SummaryStatistics(u); assertEquals(u, v); assertEquals(v, u); assertTrue(v.geoMean == v.getGeoMeanImpl()); assertTrue(v.mean == v.getMeanImpl()); assertTrue(v.min == v.getMinImpl()); assertTrue(v.max == v.getMaxImpl()); assertTrue(v.sum == v.getSumImpl()); assertTrue(v.sumsq == v.getSumsqImpl()); assertTrue(v.sumLog == v.getSumLogImpl()); assertTrue(v.variance == v.getVarianceImpl()); // Make sure both behave the same with additional values added u.addValue(7d); u.addValue(9d); u.addValue(11d); u.addValue(23d); v.addValue(7d); v.addValue(9d); v.addValue(11d); v.addValue(23d); assertEquals(u, v); assertEquals(v, u); // Check implementation pointers are preserved u.clear(); u.setSumImpl(new Sum()); SummaryStatistics.copy(u,v); assertEquals(u.sum, v.sum); assertEquals(u.getSumImpl(), v.getSumImpl()); } private void verifySummary(SummaryStatistics u, StatisticalSummary s) { assertEquals("N",s.getN(),u.getN()); TestUtils.assertEquals("sum",s.getSum(),u.getSum(),tolerance); TestUtils.assertEquals("var",s.getVariance(),u.getVariance(),tolerance); TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(),tolerance); TestUtils.assertEquals("mean",s.getMean(),u.getMean(),tolerance); TestUtils.assertEquals("min",s.getMin(),u.getMin(),tolerance); TestUtils.assertEquals("max",s.getMax(),u.getMax(),tolerance); } public void testSetterInjection() throws Exception { SummaryStatistics u = createSummaryStatistics(); u.setMeanImpl(new Sum()); u.setSumLogImpl(new Sum()); u.addValue(1); u.addValue(3); assertEquals(4, u.getMean(), 1E-14); assertEquals(4, u.getSumOfLogs(), 1E-14); assertEquals(Math.exp(2), u.getGeometricMean(), 1E-14); u.clear(); u.addValue(1); u.addValue(2); assertEquals(3, u.getMean(), 1E-14); u.clear(); u.setMeanImpl(new Mean()); // OK after clear } public void testSetterIllegalState() throws Exception { SummaryStatistics u = createSummaryStatistics(); u.addValue(1); u.addValue(3); try { u.setMeanImpl(new Sum()); fail("Expecting IllegalStateException"); } catch (IllegalStateException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.TestUtils; /** * Test cases for the {@link StatisticalSummaryValues} class. * * @version $Revision$ $Date$ */ public final class StatisticalSummaryValuesTest extends TestCase { public StatisticalSummaryValuesTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(StatisticalSummaryValuesTest.class); suite.setName("StatisticalSummaryValues Tests"); return suite; } public void testSerialization() { StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6); TestUtils.checkSerializedEquality(u); StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u); verifyEquality(u, t); } public void testEqualsAndHashCode() { StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6); StatisticalSummaryValues t = null; assertTrue("reflexive", u.equals(u)); assertFalse("non-null compared to null", u.equals(t)); assertFalse("wrong type", u.equals(Double.valueOf(0))); t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6); assertTrue("instances with same data should be equal", t.equals(u)); assertEquals("hash code", u.hashCode(), t.hashCode()); u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6); t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6); assertFalse("instances based on different data should be different", (u.equals(t) ||t.equals(u))); } private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) { assertEquals("N",s.getN(),u.getN()); TestUtils.assertEquals("sum",s.getSum(),u.getSum(), 0); TestUtils.assertEquals("var",s.getVariance(),u.getVariance(), 0); TestUtils.assertEquals("std",s.getStandardDeviation(),u.getStandardDeviation(), 0); TestUtils.assertEquals("mean",s.getMean(),u.getMean(), 0); TestUtils.assertEquals("min",s.getMin(),u.getMin(), 0); TestUtils.assertEquals("max",s.getMax(),u.getMax(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.moment.Mean; /** * Tests for AbstractUnivariateStatistic * * @version $Revision$ $Date$ */ public class AbstractUnivariateStatisticTest extends TestCase { public AbstractUnivariateStatisticTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class); suite.setName("AbstractUnivariateStatistic Tests"); return suite; } protected double[] testArray = {0, 1, 2, 3, 4, 5}; protected double[] nullArray = null; protected double[] singletonArray = {0}; protected Mean testStatistic = new Mean(); public void testTestPositive() { for (int j = 0; j < 6; j++) { for (int i = 1; i < (7 - j); i++) { assertTrue(testStatistic.test(testArray, 0, i)); } } assertTrue(testStatistic.test(singletonArray, 0, 1)); } public void testTestNegative() { assertFalse(testStatistic.test(singletonArray, 0, 0)); assertFalse(testStatistic.test(testArray, 0, 0)); try { testStatistic.test(singletonArray, 2, 1); // start past end fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.test(testArray, 0, 7); // end past end fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.test(testArray, -1, 1); // start negative fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.test(testArray, 0, -1); // length negative fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.test(nullArray, 0, 1); // null array fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import java.util.ArrayList; import java.util.List; import org.apache.commons.math.util.NumberTransformer; import org.apache.commons.math.util.TransformerMap; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test cases for the {@link ListUnivariateImpl} class. * * @version $Revision$ $Date$ */ public final class MixedListUnivariateImplTest extends TestCase { private double one = 1; private float two = 2; private int three = 3; private double mean = 2; private double sumSq = 18; private double sum = 8; private double var = 0.666666666666666666667; private double std = Math.sqrt(var); private double n = 4; private double min = 1; private double max = 3; private double tolerance = 10E-15; private TransformerMap transformers = new TransformerMap(); public MixedListUnivariateImplTest(String name) { super(name); transformers = new TransformerMap(); transformers.putTransformer(Foo.class, new FooTransformer()); transformers.putTransformer(Bar.class, new BarTransformer()); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class); suite.setName("Mixed List Tests"); return suite; } /** test stats */ public void testStats() { List<Object> externalList = new ArrayList<Object>(); DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers); assertEquals("total count", 0, u.getN(), tolerance); u.addValue(one); u.addValue(two); u.addValue(two); u.addValue(three); assertEquals("N", n, u.getN(), tolerance); assertEquals("sum", sum, u.getSum(), tolerance); assertEquals("sumsq", sumSq, u.getSumsq(), tolerance); assertEquals("var", var, u.getVariance(), tolerance); assertEquals("std", std, u.getStandardDeviation(), tolerance); assertEquals("mean", mean, u.getMean(), tolerance); assertEquals("min", min, u.getMin(), tolerance); assertEquals("max", max, u.getMax(), tolerance); u.clear(); assertEquals("total count", 0, u.getN(), tolerance); } public void testN0andN1Conditions() throws Exception { DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers); assertTrue( "Mean of n = 0 set should be NaN", Double.isNaN(u.getMean())); assertTrue( "Standard Deviation of n = 0 set should be NaN", Double.isNaN(u.getStandardDeviation())); assertTrue( "Variance of n = 0 set should be NaN", Double.isNaN(u.getVariance())); u.addValue(one); assertTrue( "Mean of n = 1 set should be value of single item n1, instead it is " + u.getMean() , u.getMean() == one); assertTrue( "StdDev of n = 1 set should be zero, instead it is: " + u.getStandardDeviation(), u.getStandardDeviation() == 0); assertTrue( "Variance of n = 1 set should be zero", u.getVariance() == 0); } public void testSkewAndKurtosis() { ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(), transformers); u.addObject("12.5"); u.addObject(Integer.valueOf(12)); u.addObject("11.8"); u.addObject("14.2"); u.addObject(new Foo()); u.addObject("14.5"); u.addObject(Long.valueOf(21)); u.addObject("8.2"); u.addObject("10.3"); u.addObject("11.3"); u.addObject(Float.valueOf(14.1f)); u.addObject("9.9"); u.addObject("12.2"); u.addObject(new Bar()); u.addObject("12.1"); u.addObject("11"); u.addObject(Double.valueOf(19.8)); u.addObject("11"); u.addObject("10"); u.addObject("8.8"); u.addObject("9"); u.addObject("12.3"); assertEquals("mean", 12.40455, u.getMean(), 0.0001); assertEquals("variance", 10.00236, u.getVariance(), 0.0001); assertEquals("skewness", 1.437424, u.getSkewness(), 0.0001); assertEquals("kurtosis", 2.37719, u.getKurtosis(), 0.0001); } public void testProductAndGeometricMean() throws Exception { ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers); u.setWindowSize(10); u.addValue(1.0); u.addValue(2.0); u.addValue(3.0); u.addValue(4.0); assertEquals( "Geometric mean not expected", 2.213364, u.getGeometricMean(), 0.00001); // Now test rolling - StorelessDescriptiveStatistics should discount the contribution // of a discarded element for (int i = 0; i < 10; i++) { u.addValue(i + 2); } // Values should be (2,3,4,5,6,7,8,9,10,11) assertEquals( "Geometric mean not expected", 5.755931, u.getGeometricMean(), 0.00001); } public static final class Foo { public String heresFoo() { return "14.9"; } } public static final class FooTransformer implements NumberTransformer { private static final long serialVersionUID = -4252248129291326127L; public double transform(Object o) { return Double.parseDouble(((Foo) o).heresFoo()); } } public static final class Bar { public String heresBar() { return "12.0"; } } public static final class BarTransformer implements NumberTransformer { private static final long serialVersionUID = -1768345377764262043L; public double transform(Object o) { return Double.parseDouble(((Bar) o).heresBar()); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math.stat.descriptive; import junit.framework.Test; import junit.framework.TestSuite; /** * Test cases for the {@link SynchronizedDescriptiveStatisticsTest} class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug * 2007) $ */ public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest { public SynchronizedDescriptiveStatisticsTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(SynchronizedDescriptiveStatisticsTest.class); suite.setName("SynchronizedDescriptiveStatistics Tests"); return suite; } protected DescriptiveStatistics createDescriptiveStatistics() { return new SynchronizedDescriptiveStatistics(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import org.apache.commons.math.TestUtils; import org.apache.commons.math.stat.descriptive.moment.SecondMoment; /** * Test cases for {@link StorelessUnivariateStatistic} classes. * @version $Revision$ $Date$ */ public abstract class StorelessUnivariateStatisticAbstractTest extends UnivariateStatisticAbstractTest { public StorelessUnivariateStatisticAbstractTest(String name) { super(name); } /** Small sample arrays */ protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}}; /** Return a new instance of the statistic */ public abstract UnivariateStatistic getUnivariateStatistic(); /**Expected value for the testArray defined in UnivariateStatisticAbstractTest */ public abstract double expectedValue(); /** * Verifies that increment() and incrementAll work properly. */ public void testIncrementation() throws Exception { StorelessUnivariateStatistic statistic = (StorelessUnivariateStatistic) getUnivariateStatistic(); // Add testArray one value at a time and check result for (int i = 0; i < testArray.length; i++) { statistic.increment(testArray[i]); } assertEquals(expectedValue(), statistic.getResult(), getTolerance()); assertEquals(testArray.length, statistic.getN()); statistic.clear(); // Add testArray all at once and check again statistic.incrementAll(testArray); assertEquals(expectedValue(), statistic.getResult(), getTolerance()); assertEquals(testArray.length, statistic.getN()); statistic.clear(); // Cleared assertTrue(Double.isNaN(statistic.getResult())); assertEquals(0, statistic.getN()); } public void testSerialization() throws Exception { StorelessUnivariateStatistic statistic = (StorelessUnivariateStatistic) getUnivariateStatistic(); TestUtils.checkSerializedEquality(statistic); statistic.clear(); for (int i = 0; i < testArray.length; i++) { statistic.increment(testArray[i]); if(i % 5 == 0) statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic); } TestUtils.checkSerializedEquality(statistic); assertEquals(expectedValue(), statistic.getResult(), getTolerance()); statistic.clear(); assertTrue(Double.isNaN(statistic.getResult())); } public void testEqualsAndHashCode() { StorelessUnivariateStatistic statistic = (StorelessUnivariateStatistic) getUnivariateStatistic(); StorelessUnivariateStatistic statistic2 = null; assertTrue("non-null, compared to null", !statistic.equals(statistic2)); assertTrue("reflexive, non-null", statistic.equals(statistic)); int emptyHash = statistic.hashCode(); statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic(); assertTrue("empty stats should be equal", statistic.equals(statistic2)); assertEquals("empty stats should have the same hashcode", emptyHash, statistic2.hashCode()); statistic.increment(1d); assertTrue("reflexive, non-empty", statistic.equals(statistic)); assertTrue("non-empty, compared to empty", !statistic.equals(statistic2)); assertTrue("non-empty, compared to empty", !statistic2.equals(statistic)); assertTrue("non-empty stat should have different hashcode from empty stat", statistic.hashCode() != emptyHash); statistic2.increment(1d); assertTrue("stats with same data should be equal", statistic.equals(statistic2)); assertEquals("stats with same data should have the same hashcode", statistic.hashCode(), statistic2.hashCode()); statistic.increment(Double.POSITIVE_INFINITY); assertTrue("stats with different n's should not be equal", !statistic2.equals(statistic)); assertTrue("stats with different n's should have different hashcodes", statistic.hashCode() != statistic2.hashCode()); statistic2.increment(Double.POSITIVE_INFINITY); assertTrue("stats with same data should be equal", statistic.equals(statistic2)); assertEquals("stats with same data should have the same hashcode", statistic.hashCode(), statistic2.hashCode()); statistic.clear(); statistic2.clear(); assertTrue("cleared stats should be equal", statistic.equals(statistic2)); assertEquals("cleared stats should have thashcode of empty stat", emptyHash, statistic2.hashCode()); assertEquals("cleared stats should have thashcode of empty stat", emptyHash, statistic.hashCode()); } public void testMomentSmallSamples() { UnivariateStatistic stat = getUnivariateStatistic(); if (stat instanceof SecondMoment) { SecondMoment moment = (SecondMoment) getUnivariateStatistic(); assertTrue(Double.isNaN(moment.getResult())); moment.increment(1d); assertEquals(0d, moment.getResult(), 0); } } /** * Make sure that evaluate(double[]) and inrementAll(double[]), * getResult() give same results. */ public void testConsistency() { StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic(); stat.incrementAll(testArray); assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance()); for (int i = 0; i < smallSamples.length; i++) { stat.clear(); for (int j =0; j < smallSamples[i].length; j++) { stat.increment(smallSamples[i][j]); } TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance()); } } /** * Verifies that copied statistics remain equal to originals when * incremented the same way. * */ public void testCopyConsistency() { StorelessUnivariateStatistic master = (StorelessUnivariateStatistic) getUnivariateStatistic(); StorelessUnivariateStatistic replica = null; // Randomly select a portion of testArray to load first long index = Math.round((Math.random()) * (double) testArray.length); // Put first half in master and copy master to replica master.incrementAll(testArray, 0, (int) index); replica = (StorelessUnivariateStatistic) master.copy(); // Check same assertTrue(replica.equals(master)); assertTrue(master.equals(replica)); // Now add second part to both and check again master.incrementAll(testArray, (int) index, (int) (testArray.length - index)); replica.incrementAll(testArray, (int) index, (int) (testArray.length - index)); assertTrue(replica.equals(master)); assertTrue(master.equals(replica)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import org.apache.commons.math.stat.descriptive.moment.FourthMoment; import org.apache.commons.math.stat.descriptive.moment.Kurtosis; import org.apache.commons.math.stat.descriptive.moment.Mean; import org.apache.commons.math.stat.descriptive.moment.Skewness; import org.apache.commons.math.stat.descriptive.moment.Variance; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class InteractionTest extends TestCase { protected double mean = 12.40454545454550; protected double var = 10.00235930735930; protected double skew = 1.437423729196190; protected double kurt = 2.377191264804700; protected double tolerance = 10E-12; protected double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 }; public InteractionTest(String name) { super(name); } public void testInteraction() { FourthMoment m4 = new FourthMoment(); Mean m = new Mean(m4); Variance v = new Variance(m4); Skewness s= new Skewness(m4); Kurtosis k = new Kurtosis(m4); for (int i = 0; i < testArray.length; i++){ m4.increment(testArray[i]); } assertEquals(mean,m.getResult(),tolerance); assertEquals(var,v.getResult(),tolerance); assertEquals(skew ,s.getResult(),tolerance); assertEquals(kurt,k.getResult(),tolerance); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math.stat.descriptive; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.rank.Percentile; import org.apache.commons.math.util.MathUtils; /** * Test cases for the DescriptiveStatistics class. * * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug * 2007) $ */ public class DescriptiveStatisticsTest extends TestCase { public DescriptiveStatisticsTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class); suite.setName("DescriptiveStatistics Tests"); return suite; } public void testSetterInjection() throws Exception { DescriptiveStatistics stats = new DescriptiveStatistics(); stats.addValue(1); stats.addValue(3); assertEquals(2, stats.getMean(), 1E-10); // Now lets try some new math stats.setMeanImpl(new deepMean()); assertEquals(42, stats.getMean(), 1E-10); } public void testPercentileSetter() throws Exception { DescriptiveStatistics stats = new DescriptiveStatistics(); stats.addValue(1); stats.addValue(2); stats.addValue(3); assertEquals(2, stats.getPercentile(50.0), 1E-10); // Inject wrapped Percentile impl stats.setPercentileImpl(new goodPercentile()); assertEquals(2, stats.getPercentile(50.0), 1E-10); // Try "new math" impl stats.setPercentileImpl(new subPercentile()); assertEquals(10.0, stats.getPercentile(10.0), 1E-10); // Try to set bad impl try { stats.setPercentileImpl(new badPercentile()); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } public void testRemoval() { final DescriptiveStatistics dstat = new DescriptiveStatistics(); checkremoval(dstat, 1, 6.0, 0.0, Double.NaN); checkremoval(dstat, 3, 5.0, 3.0, 4.5); checkremoval(dstat, 6, 3.5, 2.5, 3.0); checkremoval(dstat, 9, 3.5, 2.5, 3.0); checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0); } public void checkremoval(DescriptiveStatistics dstat, int wsize, double mean1, double mean2, double mean3) { dstat.setWindowSize(wsize); dstat.clear(); for (int i = 1 ; i <= 6 ; ++i) { dstat.addValue(i); } assertTrue(MathUtils.equals(mean1, dstat.getMean())); dstat.replaceMostRecentValue(0); assertTrue(MathUtils.equals(mean2, dstat.getMean())); dstat.removeMostRecentValue(); assertTrue(MathUtils.equals(mean3, dstat.getMean())); } // Test UnivariateStatistics impls for setter injection tests /** * A new way to compute the mean */ static class deepMean implements UnivariateStatistic { private static final long serialVersionUID = 9108665370122541953L; public double evaluate(double[] values, int begin, int length) { return 42; } public double evaluate(double[] values) { return 42; } public UnivariateStatistic copy() { return new deepMean(); } } /** * Test percentile implementation - wraps a Percentile */ static class goodPercentile implements UnivariateStatistic { private static final long serialVersionUID = 801005145532790795L; private Percentile percentile = new Percentile(); public void setQuantile(double quantile) { percentile.setQuantile(quantile); } public double evaluate(double[] values, int begin, int length) { return percentile.evaluate(values, begin, length); } public double evaluate(double[] values) { return percentile.evaluate(values); } public UnivariateStatistic copy() { goodPercentile result = new goodPercentile(); result.setQuantile(percentile.getQuantile()); return result; } } /** * Test percentile subclass - another "new math" impl * Always returns currently set quantile */ static class subPercentile extends Percentile { public double evaluate(double[] values, int begin, int length) { return getQuantile(); } public double evaluate(double[] values) { return getQuantile(); } private static final long serialVersionUID = 8040701391045914979L; public Percentile copy() { subPercentile result = new subPercentile(); return result; } } /** * "Bad" test percentile implementation - no setQuantile */ static class badPercentile implements UnivariateStatistic { private static final long serialVersionUID = -707437653388052183L; private Percentile percentile = new Percentile(); public double evaluate(double[] values, int begin, int length) { return percentile.evaluate(values, begin, length); } public double evaluate(double[] values) { return percentile.evaluate(values); } public UnivariateStatistic copy() { return new badPercentile(); } } private void checkSameResults(DescriptiveStatistics first, DescriptiveStatistics second) throws Exception { assertEquals(first.getGeometricMean(), second.getGeometricMean(), 0); assertEquals(first.getKurtosis(), second.getKurtosis(), 0); assertEquals(first.getMax(), second.getMax(), 0); assertEquals(first.getMean(), second.getMean(), 0); assertEquals(first.getMin(), second.getMin(), 0); assertEquals(first.getN(), second.getN(), 0); assertEquals(first.getPercentile(10), second.getPercentile(10), 0); assertEquals(first.getSkewness(), second.getSkewness(), 0); assertEquals(first.getStandardDeviation(), second.getStandardDeviation(), 0); assertEquals(first.getSum(), second.getSum(), 0); assertEquals(first.getSumsq(), second.getSumsq(), 0); assertEquals(first.getVariance(), second.getVariance(), 0); assertEquals(first.eDA, second.eDA); assertEquals(first.getWindowSize(), second.getWindowSize()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.DimensionMismatchException; import org.apache.commons.math.TestUtils; import org.apache.commons.math.stat.descriptive.moment.Mean; /** * Test cases for the {@link MultivariateSummaryStatistics} class. * * @version $Revision$ $Date$ */ public class MultivariateSummaryStatisticsTest extends TestCase { public MultivariateSummaryStatisticsTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(MultivariateSummaryStatisticsTest.class); suite.setName("MultivariateSummaryStatistics tests"); return suite; } public void testSetterInjection() throws Exception { MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true); u.setMeanImpl(new StorelessUnivariateStatistic[] { new sumMean(), new sumMean() }); u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 3, 4 }); assertEquals(4, u.getMean()[0], 1E-14); assertEquals(6, u.getMean()[1], 1E-14); u.clear(); u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 3, 4 }); assertEquals(4, u.getMean()[0], 1E-14); assertEquals(6, u.getMean()[1], 1E-14); u.clear(); u.setMeanImpl(new StorelessUnivariateStatistic[] { new Mean(), new Mean() }); // OK after clear u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 3, 4 }); assertEquals(2, u.getMean()[0], 1E-14); assertEquals(3, u.getMean()[1], 1E-14); } public void testSetterIllegalState() throws Exception { MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true); u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 3, 4 }); try { u.setMeanImpl(new StorelessUnivariateStatistic[] { new sumMean(), new sumMean() }); fail("Expecting IllegalStateException"); } catch (IllegalStateException ex) { // expected } } /** * Bogus mean implementation to test setter injection. * Returns the sum instead of the mean. */ static class sumMean implements StorelessUnivariateStatistic { private static final long serialVersionUID = 6492471391340853423L; private double sum = 0; private long n = 0; public double evaluate(double[] values, int begin, int length) { return 0; } public double evaluate(double[] values) { return 0; } public void clear() { sum = 0; n = 0; } public long getN() { return n; } public double getResult() { return sum; } public void increment(double d) { sum += d; n++; } public void incrementAll(double[] values, int start, int length) { } public void incrementAll(double[] values) { } public StorelessUnivariateStatistic copy() { return new sumMean(); } } public void testDimension() { try { new MultivariateSummaryStatistics(2, true).addValue(new double[3]); } catch (DimensionMismatchException dme) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** test stats */ public void testStats() throws DimensionMismatchException { MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true); assertEquals(0, u.getN()); u.addValue(new double[] { 1, 2 }); u.addValue(new double[] { 2, 3 }); u.addValue(new double[] { 2, 3 }); u.addValue(new double[] { 3, 4 }); assertEquals( 4, u.getN()); assertEquals( 8, u.getSum()[0], 1.0e-10); assertEquals(12, u.getSum()[1], 1.0e-10); assertEquals(18, u.getSumSq()[0], 1.0e-10); assertEquals(38, u.getSumSq()[1], 1.0e-10); assertEquals( 1, u.getMin()[0], 1.0e-10); assertEquals( 2, u.getMin()[1], 1.0e-10); assertEquals( 3, u.getMax()[0], 1.0e-10); assertEquals( 4, u.getMax()[1], 1.0e-10); assertEquals(2.4849066497880003102, u.getSumLog()[0], 1.0e-10); assertEquals( 4.276666119016055311, u.getSumLog()[1], 1.0e-10); assertEquals( 1.8612097182041991979, u.getGeometricMean()[0], 1.0e-10); assertEquals( 2.9129506302439405217, u.getGeometricMean()[1], 1.0e-10); assertEquals( 2, u.getMean()[0], 1.0e-10); assertEquals( 3, u.getMean()[1], 1.0e-10); assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[0], 1.0e-10); assertEquals(Math.sqrt(2.0 / 3.0), u.getStandardDeviation()[1], 1.0e-10); assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 0), 1.0e-10); assertEquals(2.0 / 3.0, u.getCovariance().getEntry(0, 1), 1.0e-10); assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10); assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10); u.clear(); assertEquals(0, u.getN()); } public void testN0andN1Conditions() throws Exception { MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(1, true); assertTrue(Double.isNaN(u.getMean()[0])); assertTrue(Double.isNaN(u.getStandardDeviation()[0])); /* n=1 */ u.addValue(new double[] { 1 }); assertEquals(1.0, u.getMean()[0], 1.0e-10); assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10); assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10); /* n=2 */ u.addValue(new double[] { 2 }); assertTrue(u.getStandardDeviation()[0] > 0); } public void testNaNContracts() throws DimensionMismatchException { MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(1, true); assertTrue(Double.isNaN(u.getMean()[0])); assertTrue(Double.isNaN(u.getMin()[0])); assertTrue(Double.isNaN(u.getStandardDeviation()[0])); assertTrue(Double.isNaN(u.getGeometricMean()[0])); u.addValue(new double[] { 1.0 }); assertFalse(Double.isNaN(u.getMean()[0])); assertFalse(Double.isNaN(u.getMin()[0])); assertFalse(Double.isNaN(u.getStandardDeviation()[0])); assertFalse(Double.isNaN(u.getGeometricMean()[0])); } public void testSerialization() throws DimensionMismatchException { MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true); // Empty test TestUtils.checkSerializedEquality(u); MultivariateSummaryStatistics s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u); assertEquals(u, s); // Add some data u.addValue(new double[] { 2d, 1d }); u.addValue(new double[] { 1d, 1d }); u.addValue(new double[] { 3d, 1d }); u.addValue(new double[] { 4d, 1d }); u.addValue(new double[] { 5d, 1d }); // Test again TestUtils.checkSerializedEquality(u); s = (MultivariateSummaryStatistics) TestUtils.serializeAndRecover(u); assertEquals(u, s); } public void testEqualsAndHashCode() throws DimensionMismatchException { MultivariateSummaryStatistics u = new MultivariateSummaryStatistics(2, true); MultivariateSummaryStatistics t = null; int emptyHash = u.hashCode(); assertTrue(u.equals(u)); assertFalse(u.equals(t)); assertFalse(u.equals(Double.valueOf(0))); t = new MultivariateSummaryStatistics(2, true); assertTrue(t.equals(u)); assertTrue(u.equals(t)); assertEquals(emptyHash, t.hashCode()); // Add some data to u u.addValue(new double[] { 2d, 1d }); u.addValue(new double[] { 1d, 1d }); u.addValue(new double[] { 3d, 1d }); u.addValue(new double[] { 4d, 1d }); u.addValue(new double[] { 5d, 1d }); assertFalse(t.equals(u)); assertFalse(u.equals(t)); assertTrue(u.hashCode() != t.hashCode()); //Add data in same order to t t.addValue(new double[] { 2d, 1d }); t.addValue(new double[] { 1d, 1d }); t.addValue(new double[] { 3d, 1d }); t.addValue(new double[] { 4d, 1d }); t.addValue(new double[] { 5d, 1d }); assertTrue(t.equals(u)); assertTrue(u.equals(t)); assertEquals(u.hashCode(), t.hashCode()); // Clear and make sure summaries are indistinguishable from empty summary u.clear(); t.clear(); assertTrue(t.equals(u)); assertTrue(u.equals(t)); assertEquals(emptyHash, t.hashCode()); assertEquals(emptyHash, u.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math.stat.descriptive; import junit.framework.Test; import junit.framework.TestSuite; /** * Test cases for the {@link SynchronizedSummaryStatisticsTest} class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug * 2007) $ */ public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest { public SynchronizedSummaryStatisticsTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(SynchronizedSummaryStatisticsTest.class); suite.setName("SynchronizedSummaryStatistics Tests"); return suite; } protected SummaryStatistics createSummaryStatistics() { return new SynchronizedSummaryStatistics(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.summary; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{ protected SumOfLogs stat; /** * @param name */ public SumLogTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(SumLogTest.class); suite.setName("SumLog Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new SumOfLogs(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.sumLog; } public void testSpecialValues() { SumOfLogs sum = new SumOfLogs(); // empty assertTrue(Double.isNaN(sum.getResult())); // finite data sum.increment(1d); assertFalse(Double.isNaN(sum.getResult())); // add negative infinity sum.increment(0d); assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0); // add positive infinity -- should make NaN sum.increment(Double.POSITIVE_INFINITY); assertTrue(Double.isNaN(sum.getResult())); // clear sum.clear(); assertTrue(Double.isNaN(sum.getResult())); // positive infinity by itself sum.increment(Double.POSITIVE_INFINITY); assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0); // negative value -- should make NaN sum.increment(-2d); assertTrue(Double.isNaN(sum.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.summary; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link Sum} class. * @version $Revision$ $Date$ */ public class SumTest extends StorelessUnivariateStatisticAbstractTest{ protected Sum stat; /** * @param name */ public SumTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(SumTest.class); suite.setName("Sum Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Sum(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.sum; } public void testSpecialValues() { Sum sum = new Sum(); assertTrue(Double.isNaN(sum.getResult())); sum.increment(1); assertEquals(1, sum.getResult(), 0); sum.increment(Double.POSITIVE_INFINITY); assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0); sum.increment(Double.NEGATIVE_INFINITY); assertTrue(Double.isNaN(sum.getResult())); sum.increment(1); assertTrue(Double.isNaN(sum.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.summary; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class ProductTest extends StorelessUnivariateStatisticAbstractTest{ protected Product stat; /** * @param name */ public ProductTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(ProductTest.class); suite.setName("Product Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Product(); } public double getTolerance() { return 10E8; //sic -- big absolute error due to only 15 digits of accuracy in double } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.product; } public void testSpecialValues() { Product product = new Product(); assertTrue(Double.isNaN(product.getResult())); product.increment(1); assertEquals(1, product.getResult(), 0); product.increment(Double.POSITIVE_INFINITY); assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0); product.increment(Double.NEGATIVE_INFINITY); assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0); product.increment(Double.NaN); assertTrue(Double.isNaN(product.getResult())); product.increment(1); assertTrue(Double.isNaN(product.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.summary; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link SumOfSquares} class. * * @version $Revision$ $Date$ */ public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{ protected SumOfSquares stat; /** * @param name */ public SumSqTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(SumSqTest.class); suite.setName("SumSq Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new SumOfSquares(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.sumSq; } public void testSpecialValues() { SumOfSquares sumSq = new SumOfSquares(); assertTrue(Double.isNaN(sumSq.getResult())); sumSq.increment(2d); assertEquals(4d, sumSq.getResult(), 0); sumSq.increment(Double.POSITIVE_INFINITY); assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0); sumSq.increment(Double.NEGATIVE_INFINITY); assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0); sumSq.increment(Double.NaN); assertTrue(Double.isNaN(sumSq.getResult())); sumSq.increment(1); assertTrue(Double.isNaN(sumSq.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link SecondMoment} class. * @version $Revision$ $Date$ */ public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest { /** descriptive statistic. */ protected SecondMoment stat; /** * @param name */ public SecondMomentTest(String name) { super(name); } /** * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new SecondMoment(); } /** * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.secondMoment; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * * @version $Revision$ $Date$ */ public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{ protected Skewness stat; /** * @param name */ public SkewnessTest(String name) { super(name); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Skewness(); } public static Test suite() { TestSuite suite = new TestSuite(SkewnessTest.class); suite.setName("Skewness Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.skew; } /** * Make sure Double.NaN is returned iff n < 3 * */ public void testNaN() { Skewness skew = new Skewness(); assertTrue(Double.isNaN(skew.getResult())); skew.increment(1d); assertTrue(Double.isNaN(skew.getResult())); skew.increment(1d); assertTrue(Double.isNaN(skew.getResult())); skew.increment(1d); assertFalse(Double.isNaN(skew.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{ protected GeometricMean stat; /** * @param name */ public GeometricMeanTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(GeometricMeanTest.class); suite.setName("Mean Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new GeometricMean(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.geoMean; } public void testSpecialValues() { GeometricMean mean = new GeometricMean(); // empty assertTrue(Double.isNaN(mean.getResult())); // finite data mean.increment(1d); assertFalse(Double.isNaN(mean.getResult())); // add 0 -- makes log sum blow to minus infinity, should make 0 mean.increment(0d); assertEquals(0d, mean.getResult(), 0); // add positive infinity - note the minus infinity above mean.increment(Double.POSITIVE_INFINITY); assertTrue(Double.isNaN(mean.getResult())); // clear mean.clear(); assertTrue(Double.isNaN(mean.getResult())); // positive infinity by itself mean.increment(Double.POSITIVE_INFINITY); assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0); // negative value -- should make NaN mean.increment(-2d); assertTrue(Double.isNaN(mean.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class MeanTest extends StorelessUnivariateStatisticAbstractTest{ protected Mean stat; /** * @param name */ public MeanTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(MeanTest.class); suite.setName("Mean Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Mean(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.mean; } public void testSmallSamples() { Mean mean = new Mean(); assertTrue(Double.isNaN(mean.getResult())); mean.increment(1d); assertEquals(1d, mean.getResult(), 0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * * @version $Revision$ $Date$ */ public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{ protected Variance stat; /** * @param name */ public VarianceTest(String name) { super(name); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Variance(); } public static Test suite() { TestSuite suite = new TestSuite(VarianceTest.class); suite.setName("Variance Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.var; } /** * Make sure Double.NaN is returned iff n = 0 * */ public void testNaN() { StandardDeviation std = new StandardDeviation(); assertTrue(Double.isNaN(std.getResult())); std.increment(1d); assertEquals(0d, std.getResult(), 0); } /** * Test population version of variance */ public void testPopulation() { double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d}; SecondMoment m = new SecondMoment(); m.evaluate(values); // side effect is to add values Variance v1 = new Variance(); v1.setBiasCorrected(false); assertEquals(populationVariance(values), v1.evaluate(values), 1E-14); v1.incrementAll(values); assertEquals(populationVariance(values), v1.getResult(), 1E-14); v1 = new Variance(false, m); assertEquals(populationVariance(values), v1.getResult(), 1E-14); v1 = new Variance(false); assertEquals(populationVariance(values), v1.evaluate(values), 1E-14); v1.incrementAll(values); assertEquals(populationVariance(values), v1.getResult(), 1E-14); } /** * Definitional formula for population variance */ protected double populationVariance(double[] v) { double mean = new Mean().evaluate(v); double sum = 0; for (int i = 0; i < v.length; i++) { sum += (v[i] - mean) * (v[i] - mean); } return sum / (double) v.length; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * * @version $Revision$ $Date$ */ public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{ protected StandardDeviation stat; /** * @param name */ public StandardDeviationTest(String name) { super(name); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new StandardDeviation(); } public static Test suite() { TestSuite suite = new TestSuite(StandardDeviationTest.class); suite.setName("StandardDeviation Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.std; } /** * Make sure Double.NaN is returned iff n = 0 * */ public void testNaN() { StandardDeviation std = new StandardDeviation(); assertTrue(Double.isNaN(std.getResult())); std.increment(1d); assertEquals(0d, std.getResult(), 0); } /** * Test population version of variance */ public void testPopulation() { double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d}; double sigma = populationStandardDeviation(values); SecondMoment m = new SecondMoment(); m.evaluate(values); // side effect is to add values StandardDeviation s1 = new StandardDeviation(); s1.setBiasCorrected(false); assertEquals(sigma, s1.evaluate(values), 1E-14); s1.incrementAll(values); assertEquals(sigma, s1.getResult(), 1E-14); s1 = new StandardDeviation(false, m); assertEquals(sigma, s1.getResult(), 1E-14); s1 = new StandardDeviation(false); assertEquals(sigma, s1.evaluate(values), 1E-14); s1.incrementAll(values); assertEquals(sigma, s1.getResult(), 1E-14); } /** * Definitional formula for population standard deviation */ protected double populationStandardDeviation(double[] v) { double mean = new Mean().evaluate(v); double sum = 0; for (int i = 0; i < v.length; i++) { sum += (v[i] - mean) * (v[i] - mean); } return Math.sqrt(sum / (double) v.length); } }
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements. See the NOTICE file //distributed with this work for additional information //regarding copyright ownership. The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License. You may obtain a copy of the License at //http://www.apache.org/licenses/LICENSE-2.0 //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied. See the License for the //specific language governing permissions and limitations //under the License. package org.apache.commons.math.stat.descriptive.moment; import org.apache.commons.math.DimensionMismatchException; import org.apache.commons.math.linear.RealMatrix; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class VectorialCovarianceTest extends TestCase { public VectorialCovarianceTest(String name) { super(name); points = null; } public void testMismatch() { try { new VectorialCovariance(8, true).increment(new double[5]); fail("an exception should have been thrown"); } catch (DimensionMismatchException dme) { assertEquals(5, dme.getDimension1()); assertEquals(8, dme.getDimension2()); } catch (Exception e) { fail("wrong exception type caught: " + e.getClass().getName()); } } public void testSimplistic() throws DimensionMismatchException { VectorialCovariance stat = new VectorialCovariance(2, true); stat.increment(new double[] {-1.0, 1.0}); stat.increment(new double[] { 1.0, -1.0}); RealMatrix c = stat.getResult(); assertEquals( 2.0, c.getEntry(0, 0), 1.0e-12); assertEquals(-2.0, c.getEntry(1, 0), 1.0e-12); assertEquals( 2.0, c.getEntry(1, 1), 1.0e-12); } public void testBasicStats() throws DimensionMismatchException { VectorialCovariance stat = new VectorialCovariance(points[0].length, true); for (int i = 0; i < points.length; ++i) { stat.increment(points[i]); } assertEquals(points.length, stat.getN()); RealMatrix c = stat.getResult(); double[][] refC = new double[][] { { 8.0470, -1.9195, -3.4445}, {-1.9195, 1.0470, 3.2795}, {-3.4445, 3.2795, 12.2070} }; for (int i = 0; i < c.getRowDimension(); ++i) { for (int j = 0; j <= i; ++j) { assertEquals(refC[i][j], c.getEntry(i, j), 1.0e-12); } } } public void setUp() { points = new double[][] { { 1.2, 2.3, 4.5}, {-0.7, 2.3, 5.0}, { 3.1, 0.0, -3.1}, { 6.0, 1.2, 4.2}, {-0.7, 2.3, 5.0} }; } public void tearDown() { points = null; } public static Test suite() { return new TestSuite(VectorialCovarianceTest.class); } private double [][] points; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link FirstMoment} class. * @version $Revision$ $Date$ */ public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{ /** descriptive statistic. */ protected FirstMoment stat; /** * @param name */ public FirstMomentTest(String name) { super(name); } /** * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new FirstMoment(); } /** * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.mean; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{ protected Kurtosis stat; /** * @param name */ public KurtosisTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(KurtosisTest.class); suite.setName("Kurtosis Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Kurtosis(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.kurt; } /** * Make sure Double.NaN is returned iff n < 4 * */ public void testNaN() { Kurtosis kurt = new Kurtosis(); assertTrue(Double.isNaN(kurt.getResult())); kurt.increment(1d); assertTrue(Double.isNaN(kurt.getResult())); kurt.increment(1d); assertTrue(Double.isNaN(kurt.getResult())); kurt.increment(1d); assertTrue(Double.isNaN(kurt.getResult())); kurt.increment(1d); assertFalse(Double.isNaN(kurt.getResult())); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link ThirdMoment} class. * @version $Revision$ $Date$ */ public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{ /** descriptive statistic. */ protected ThirdMoment stat; /** * @param name */ public ThirdMomentTest(String name) { super(name); } /** * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new ThirdMoment(); } /** * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.thirdMoment; } }
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements. See the NOTICE file //distributed with this work for additional information //regarding copyright ownership. The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License. You may obtain a copy of the License at //http://www.apache.org/licenses/LICENSE-2.0 //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied. See the License for the //specific language governing permissions and limitations //under the License. package org.apache.commons.math.stat.descriptive.moment; import org.apache.commons.math.DimensionMismatchException; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class VectorialMeanTest extends TestCase { public VectorialMeanTest(String name) { super(name); points = null; } public void testMismatch() { try { new VectorialMean(8).increment(new double[5]); fail("an exception should have been thrown"); } catch (DimensionMismatchException dme) { assertEquals(5, dme.getDimension1()); assertEquals(8, dme.getDimension2()); } catch (Exception e) { fail("wrong exception type caught: " + e.getClass().getName()); } } public void testSimplistic() throws DimensionMismatchException { VectorialMean stat = new VectorialMean(2); stat.increment(new double[] {-1.0, 1.0}); stat.increment(new double[] { 1.0, -1.0}); double[] mean = stat.getResult(); assertEquals(0.0, mean[0], 1.0e-12); assertEquals(0.0, mean[1], 1.0e-12); } public void testBasicStats() throws DimensionMismatchException { VectorialMean stat = new VectorialMean(points[0].length); for (int i = 0; i < points.length; ++i) { stat.increment(points[i]); } assertEquals(points.length, stat.getN()); double[] mean = stat.getResult(); double[] refMean = new double[] { 1.78, 1.62, 3.12}; for (int i = 0; i < mean.length; ++i) { assertEquals(refMean[i], mean[i], 1.0e-12); } } public void setUp() { points = new double[][] { { 1.2, 2.3, 4.5}, {-0.7, 2.3, 5.0}, { 3.1, 0.0, -3.1}, { 6.0, 1.2, 4.2}, {-0.7, 2.3, 5.0} }; } public void tearDown() { points = null; } public static Test suite() { return new TestSuite(VectorialMeanTest.class); } private double [][] points; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.moment; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link FourthMoment} class. * @version $Revision$ $Date$ */ public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{ /** descriptive statistic. */ protected FourthMoment stat; /** * @param name */ public FourthMomentTest(String name) { super(name); } /** * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new FourthMoment(); } /** * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.fourthMoment; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.rank; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class PercentileTest extends UnivariateStatisticAbstractTest{ protected Percentile stat; /** * @param name */ public PercentileTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(PercentileTest.class); suite.setName("Percentile Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Percentile(95.0); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.percentile95; } public void testHighPercentile(){ double[] d = new double[]{1, 2, 3}; Percentile p = new Percentile(75); assertEquals(3.0, p.evaluate(d), 1.0e-5); } public void testPercentile() { double[] d = new double[] {1, 3, 2, 4}; Percentile p = new Percentile(30); assertEquals(1.5, p.evaluate(d), 1.0e-5); p.setQuantile(25); assertEquals(1.25, p.evaluate(d), 1.0e-5); p.setQuantile(75); assertEquals(3.75, p.evaluate(d), 1.0e-5); p.setQuantile(50); assertEquals(2.5, p.evaluate(d), 1.0e-5); // invalid percentiles try { p.evaluate(d, 0, d.length, -1.0); fail(); } catch (IllegalArgumentException ex) { // success } try { p.evaluate(d, 0, d.length, 101.0); fail(); } catch (IllegalArgumentException ex) { // success } } public void testNISTExample() { double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959, 95.1442, 95.0610, 95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682 }; Percentile p = new Percentile(90); assertEquals(95.1981, p.evaluate(d), 1.0e-4); assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0); } public void test5() { Percentile percentile = new Percentile(5); assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance()); } public void testNullEmpty() { Percentile percentile = new Percentile(50); double[] nullArray = null; double[] emptyArray = new double[] {}; try { percentile.evaluate(nullArray); fail("Expecting IllegalArgumentException for null array"); } catch (IllegalArgumentException ex) { // expected } assertTrue(Double.isNaN(percentile.evaluate(emptyArray))); } public void testSingleton() { Percentile percentile = new Percentile(50); double[] singletonArray = new double[] {1d}; assertEquals(1d, percentile.evaluate(singletonArray), 0); assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0); assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0); assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0); assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0))); } public void testSpecialValues() { Percentile percentile = new Percentile(50); double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d, Double.NaN}; assertEquals(2.5d, percentile.evaluate(specialValues), 0); specialValues = new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d, Double.NaN, Double.POSITIVE_INFINITY}; assertEquals(2.5d, percentile.evaluate(specialValues), 0); specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY}; assertTrue(Double.isInfinite(percentile.evaluate(specialValues))); specialValues = new double[] {1d, 1d, Double.NaN, Double.NaN}; assertTrue(Double.isNaN(percentile.evaluate(specialValues))); specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY}; // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY assertTrue(Double.isNaN(percentile.evaluate(specialValues))); } public void testSetQuantile() { Percentile percentile = new Percentile(10); percentile.setQuantile(100); // OK assertEquals(100, percentile.getQuantile(), 0); try { percentile.setQuantile(0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { new Percentile(0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.rank; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class MinTest extends StorelessUnivariateStatisticAbstractTest{ protected Min stat; /** * @param name */ public MinTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(MinTest.class); suite.setName("Min Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Min(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.min; } public void testSpecialValues() { double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY}; Min min = new Min(); assertTrue(Double.isNaN(min.getResult())); min.increment(testArray[0]); assertEquals(0d, min.getResult(), 0); min.increment(testArray[1]); assertEquals(0d, min.getResult(), 0); min.increment(testArray[2]); assertEquals(0d, min.getResult(), 0); min.increment(testArray[3]); assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0); assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0); } public void testNaNs() { Min min = new Min(); double nan = Double.NaN; assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0); assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0); assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0); assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan}))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.rank; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class MaxTest extends StorelessUnivariateStatisticAbstractTest{ protected Max stat; /** * @param name */ public MaxTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(MaxTest.class); suite.setName("Max Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Max(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.max; } public void testSpecialValues() { double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}; Max max = new Max(); assertTrue(Double.isNaN(max.getResult())); max.increment(testArray[0]); assertEquals(0d, max.getResult(), 0); max.increment(testArray[1]); assertEquals(0d, max.getResult(), 0); max.increment(testArray[2]); assertEquals(0d, max.getResult(), 0); max.increment(testArray[3]); assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0); assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0); } public void testNaNs() { Max max = new Max(); double nan = Double.NaN; assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0); assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0); assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0); assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan}))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.descriptive.rank; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.UnivariateStatistic; import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest; /** * Test cases for the {@link UnivariateStatistic} class. * @version $Revision$ $Date$ */ public class MedianTest extends UnivariateStatisticAbstractTest{ protected Median stat; /** * @param name */ public MedianTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(MedianTest.class); suite.setName("Median Tests"); return suite; } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic() */ public UnivariateStatistic getUnivariateStatistic() { return new Median(); } /* (non-Javadoc) * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue() */ public double expectedValue() { return this.median; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.inference; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * Test cases for the TTestImpl class. * * @version $Revision$ $Date$ */ public class TTestTest extends TestCase { protected TTest testStatistic = new TTestImpl(); private double[] tooShortObs = { 1.0 }; private double[] emptyObs = {}; private SummaryStatistics emptyStats = new SummaryStatistics(); SummaryStatistics tooShortStats = null; public TTestTest(String name) { super(name); } public void setUp() { tooShortStats = new SummaryStatistics(); tooShortStats.addValue(0d); } public static Test suite() { TestSuite suite = new TestSuite(TTestTest.class); suite.setName("TestStatistic Tests"); return suite; } public void testOneSampleT() throws Exception { double[] observed = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0, 88.0, 98.0, 94.0, 101.0, 92.0, 95.0 }; double mu = 100.0; SummaryStatistics sampleStats = null; sampleStats = new SummaryStatistics(); for (int i = 0; i < observed.length; i++) { sampleStats.addValue(observed[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("t statistic", -2.81976445346, testStatistic.t(mu, observed), 10E-10); assertEquals("t statistic", -2.81976445346, testStatistic.t(mu, sampleStats), 10E-10); assertEquals("p value", 0.0136390585873, testStatistic.tTest(mu, observed), 10E-10); assertEquals("p value", 0.0136390585873, testStatistic.tTest(mu, sampleStats), 10E-10); try { testStatistic.t(mu, (double[]) null); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.t(mu, (SummaryStatistics) null); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.t(mu, emptyObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.t(mu, emptyStats); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.t(mu, tooShortObs); fail("insufficient data to compute t statistic, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.tTest(mu, tooShortObs); fail("insufficient data to perform t test, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.t(mu, tooShortStats); fail("insufficient data to compute t statistic, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.tTest(mu, tooShortStats); fail("insufficient data to perform t test, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testOneSampleTTest() throws Exception { double[] oneSidedP = {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d }; SummaryStatistics oneSidedPStats = new SummaryStatistics(); for (int i = 0; i < oneSidedP.length; i++) { oneSidedPStats.addValue(oneSidedP[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("one sample t stat", 3.86485535541, testStatistic.t(0d, oneSidedP), 10E-10); assertEquals("one sample t stat", 3.86485535541, testStatistic.t(0d, oneSidedPStats),1E-10); assertEquals("one sample p value", 0.000521637019637, testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10); assertEquals("one sample p value", 0.000521637019637, testStatistic.tTest(0d, oneSidedPStats) / 2d, 10E-5); assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedP, 0.01)); assertTrue("one sample t-test reject", testStatistic.tTest(0d, oneSidedPStats, 0.01)); assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedP, 0.0001)); assertTrue("one sample t-test accept", !testStatistic.tTest(0d, oneSidedPStats, 0.0001)); try { testStatistic.tTest(0d, oneSidedP, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.tTest(0d, oneSidedPStats, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testTwoSampleTHeterscedastic() throws Exception { double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d }; double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d }; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("two sample heteroscedastic t stat", 1.60371728768, testStatistic.t(sample1, sample2), 1E-10); assertEquals("two sample heteroscedastic t stat", 1.60371728768, testStatistic.t(sampleStats1, sampleStats2), 1E-10); assertEquals("two sample heteroscedastic p value", 0.128839369622, testStatistic.tTest(sample1, sample2), 1E-10); assertEquals("two sample heteroscedastic p value", 0.128839369622, testStatistic.tTest(sampleStats1, sampleStats2), 1E-10); assertTrue("two sample heteroscedastic t-test reject", testStatistic.tTest(sample1, sample2, 0.2)); assertTrue("two sample heteroscedastic t-test reject", testStatistic.tTest(sampleStats1, sampleStats2, 0.2)); assertTrue("two sample heteroscedastic t-test accept", !testStatistic.tTest(sample1, sample2, 0.1)); assertTrue("two sample heteroscedastic t-test accept", !testStatistic.tTest(sampleStats1, sampleStats2, 0.1)); try { testStatistic.tTest(sample1, sample2, .95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.tTest(sampleStats1, sampleStats2, .95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.tTest(sample1, tooShortObs, .01); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.tTest(sampleStats1, tooShortStats, .01); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.tTest(sample1, tooShortObs); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.tTest(sampleStats1, tooShortStats); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.t(sample1, tooShortObs); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { testStatistic.t(sampleStats1, tooShortStats); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testTwoSampleTHomoscedastic() throws Exception { double[] sample1 ={2, 4, 6, 8, 10, 97}; double[] sample2 = {4, 6, 8, 10, 16}; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("two sample homoscedastic t stat", 0.73096310086, testStatistic.homoscedasticT(sample1, sample2), 10E-11); assertEquals("two sample homoscedastic p value", 0.4833963785, testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10); assertTrue("two sample homoscedastic t-test reject", testStatistic.homoscedasticTTest(sample1, sample2, 0.49)); assertTrue("two sample homoscedastic t-test accept", !testStatistic.homoscedasticTTest(sample1, sample2, 0.48)); } public void testSmallSamples() throws Exception { double[] sample1 = {1d, 3d}; double[] sample2 = {4d, 5d}; // Target values computed using R, version 1.8.1 (linux version) assertEquals(-2.2360679775, testStatistic.t(sample1, sample2), 1E-10); assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2), 1E-10); } public void testPaired() throws Exception { double[] sample1 = {1d, 3d, 5d, 7d}; double[] sample2 = {0d, 6d, 11d, 2d}; double[] sample3 = {5d, 7d, 8d, 10d}; // Target values computed using R, version 1.8.1 (linux version) assertEquals(-0.3133, testStatistic.pairedT(sample1, sample2), 1E-4); assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10); assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6); assertFalse(testStatistic.pairedTTest(sample1, sample3, .001)); assertTrue(testStatistic.pairedTTest(sample1, sample3, .002)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.inference; import junit.framework.Test; import junit.framework.TestSuite; /** * Test cases for the TTestTestFactory. * * @version $Revision$ $Date$ */ public class TTestFactoryTest extends TTestTest { public TTestFactoryTest(String name) { super(name); } public void setUp() { super.setUp(); testStatistic = TestUtils.getTTest(); } public static Test suite() { TestSuite suite = new TestSuite(TTestFactoryTest.class); suite.setName("TTestFactory Tests"); return suite; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.inference; import java.util.ArrayList; import java.util.List; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * Test cases for the TestUtils class. * * @version $Revision$ $Date$ */ public class TestUtilsTest extends TestCase { public TestUtilsTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(TestUtilsTest.class); suite.setName("TestUtils Tests"); return suite; } public void testChiSquare() throws Exception { // Target values computed using R version 1.8.1 // Some assembly required ;-) // Use sum((obs - exp)^2/exp) for the chi-square statistic and // 1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; assertEquals("chi-square statistic", 0.2, TestUtils.chiSquare(expected, observed), 10E-12); assertEquals("chi-square p-value", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10); long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; assertEquals( "chi-square test statistic", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10); assertEquals("chi-square p-value", 0.06051952647453607, TestUtils.chiSquareTest(expected1, observed1), 1E-9); assertTrue("chi-square test reject", TestUtils.chiSquareTest(expected1, observed1, 0.07)); assertTrue("chi-square test accept", !TestUtils.chiSquareTest(expected1, observed1, 0.05)); try { TestUtils.chiSquareTest(expected1, observed1, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { TestUtils.chiSquare(tooShortEx, tooShortObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // unmatched arrays long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { TestUtils.chiSquare(unMatchedEx, unMatchedObs); fail("arrays have different lengths, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // 0 expected count expected[0] = 0; try { TestUtils.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // negative observed count expected[0] = 1; observed[0] = -1; try { TestUtils.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testChiSquareIndependence() throws Exception { // Target values computed using R version 1.8.1 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}}; assertEquals( "chi-square test statistic", 22.709027688, TestUtils.chiSquare(counts), 1E-9); assertEquals("chi-square p-value", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9); assertTrue("chi-square test reject", TestUtils.chiSquareTest(counts, 0.0002)); assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts, 0.0001)); long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} }; assertEquals( "chi-square test statistic", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9); assertEquals("chi-square p-value",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9); assertTrue("chi-square test accept", !TestUtils.chiSquareTest(counts2, 0.1)); // ragged input array long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}}; try { TestUtils.chiSquare(counts3); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // insufficient data long[][] counts4 = {{40, 22, 43}}; try { TestUtils.chiSquare(counts4); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } long[][] counts5 = {{40}, {40}, {30}, {10}}; try { TestUtils.chiSquare(counts5); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // negative counts long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} }; try { TestUtils.chiSquare(counts6); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // bad alpha try { TestUtils.chiSquareTest(counts, 0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } public void testChiSquareLargeTestStatistic() throws Exception { double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); double cst = csti.chiSquareTest(exp, obs); assertEquals("chi-square p-value", 0.0, cst, 1E-3); assertEquals( "chi-square test statistic", 114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9); } /** Contingency table containing zeros - PR # 32531 */ public void testChiSquareZeroCount() throws Exception { // Target values computed using R version 1.8.1 long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}}; assertEquals( "chi-square test statistic", 9.67444662263, TestUtils.chiSquare(counts), 1E-9); assertEquals("chi-square p-value", 0.0462835770603, TestUtils.chiSquareTest(counts), 1E-9); } private double[] tooShortObs = { 1.0 }; private double[] emptyObs = {}; private SummaryStatistics emptyStats = new SummaryStatistics(); public void testOneSampleT() throws Exception { double[] observed = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0, 88.0, 98.0, 94.0, 101.0, 92.0, 95.0 }; double mu = 100.0; SummaryStatistics sampleStats = null; sampleStats = new SummaryStatistics(); for (int i = 0; i < observed.length; i++) { sampleStats.addValue(observed[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("t statistic", -2.81976445346, TestUtils.t(mu, observed), 10E-10); assertEquals("t statistic", -2.81976445346, TestUtils.t(mu, sampleStats), 10E-10); assertEquals("p value", 0.0136390585873, TestUtils.tTest(mu, observed), 10E-10); assertEquals("p value", 0.0136390585873, TestUtils.tTest(mu, sampleStats), 10E-10); try { TestUtils.t(mu, (double[]) null); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, (SummaryStatistics) null); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, emptyObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, emptyStats); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, tooShortObs); fail("insufficient data to compute t statistic, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(mu, tooShortObs); fail("insufficient data to perform t test, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(mu, (SummaryStatistics) null); fail("insufficient data to compute t statistic, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(mu, (SummaryStatistics) null); fail("insufficient data to perform t test, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testOneSampleTTest() throws Exception { double[] oneSidedP = {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d }; SummaryStatistics oneSidedPStats = new SummaryStatistics(); for (int i = 0; i < oneSidedP.length; i++) { oneSidedPStats.addValue(oneSidedP[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("one sample t stat", 3.86485535541, TestUtils.t(0d, oneSidedP), 10E-10); assertEquals("one sample t stat", 3.86485535541, TestUtils.t(0d, oneSidedPStats),1E-10); assertEquals("one sample p value", 0.000521637019637, TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10); assertEquals("one sample p value", 0.000521637019637, TestUtils.tTest(0d, oneSidedPStats) / 2d, 10E-5); assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedP, 0.01)); assertTrue("one sample t-test reject", TestUtils.tTest(0d, oneSidedPStats, 0.01)); assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedP, 0.0001)); assertTrue("one sample t-test accept", !TestUtils.tTest(0d, oneSidedPStats, 0.0001)); try { TestUtils.tTest(0d, oneSidedP, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(0d, oneSidedPStats, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testTwoSampleTHeterscedastic() throws Exception { double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d }; double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d }; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("two sample heteroscedastic t stat", 1.60371728768, TestUtils.t(sample1, sample2), 1E-10); assertEquals("two sample heteroscedastic t stat", 1.60371728768, TestUtils.t(sampleStats1, sampleStats2), 1E-10); assertEquals("two sample heteroscedastic p value", 0.128839369622, TestUtils.tTest(sample1, sample2), 1E-10); assertEquals("two sample heteroscedastic p value", 0.128839369622, TestUtils.tTest(sampleStats1, sampleStats2), 1E-10); assertTrue("two sample heteroscedastic t-test reject", TestUtils.tTest(sample1, sample2, 0.2)); assertTrue("two sample heteroscedastic t-test reject", TestUtils.tTest(sampleStats1, sampleStats2, 0.2)); assertTrue("two sample heteroscedastic t-test accept", !TestUtils.tTest(sample1, sample2, 0.1)); assertTrue("two sample heteroscedastic t-test accept", !TestUtils.tTest(sampleStats1, sampleStats2, 0.1)); try { TestUtils.tTest(sample1, sample2, .95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sampleStats1, sampleStats2, .95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sample1, tooShortObs, .01); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sample1, tooShortObs); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.tTest(sampleStats1, (SummaryStatistics) null); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(sample1, tooShortObs); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } try { TestUtils.t(sampleStats1, (SummaryStatistics) null); fail("insufficient data, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testTwoSampleTHomoscedastic() throws Exception { double[] sample1 ={2, 4, 6, 8, 10, 97}; double[] sample2 = {4, 6, 8, 10, 16}; SummaryStatistics sampleStats1 = new SummaryStatistics(); for (int i = 0; i < sample1.length; i++) { sampleStats1.addValue(sample1[i]); } SummaryStatistics sampleStats2 = new SummaryStatistics(); for (int i = 0; i < sample2.length; i++) { sampleStats2.addValue(sample2[i]); } // Target comparison values computed using R version 1.8.1 (Linux version) assertEquals("two sample homoscedastic t stat", 0.73096310086, TestUtils.homoscedasticT(sample1, sample2), 10E-11); assertEquals("two sample homoscedastic p value", 0.4833963785, TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10); assertTrue("two sample homoscedastic t-test reject", TestUtils.homoscedasticTTest(sample1, sample2, 0.49)); assertTrue("two sample homoscedastic t-test accept", !TestUtils.homoscedasticTTest(sample1, sample2, 0.48)); } public void testSmallSamples() throws Exception { double[] sample1 = {1d, 3d}; double[] sample2 = {4d, 5d}; // Target values computed using R, version 1.8.1 (linux version) assertEquals(-2.2360679775, TestUtils.t(sample1, sample2), 1E-10); assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2), 1E-10); } public void testPaired() throws Exception { double[] sample1 = {1d, 3d, 5d, 7d}; double[] sample2 = {0d, 6d, 11d, 2d}; double[] sample3 = {5d, 7d, 8d, 10d}; // Target values computed using R, version 1.8.1 (linux version) assertEquals(-0.3133, TestUtils.pairedT(sample1, sample2), 1E-4); assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10); assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6); assertFalse(TestUtils.pairedTTest(sample1, sample3, .001)); assertTrue(TestUtils.pairedTTest(sample1, sample3, .002)); } private double[] classA = {93.0, 103.0, 95.0, 101.0}; private double[] classB = {99.0, 92.0, 102.0, 100.0, 102.0}; private double[] classC = {110.0, 115.0, 111.0, 117.0, 128.0}; private List<double[]> classes = new ArrayList<double[]>(); private OneWayAnova oneWayAnova = new OneWayAnovaImpl(); public void testOneWayAnovaUtils() throws Exception { classes.add(classA); classes.add(classB); classes.add(classC); assertEquals(oneWayAnova.anovaFValue(classes), TestUtils.oneWayAnovaFValue(classes), 10E-12); assertEquals(oneWayAnova.anovaPValue(classes), TestUtils.oneWayAnovaPValue(classes), 10E-12); assertEquals(oneWayAnova.anovaTest(classes, 0.01), TestUtils.oneWayAnovaTest(classes, 0.01)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.inference; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test cases for the ChiSquareTestImpl class. * * @version $Revision$ $Date$ */ public class ChiSquareTestTest extends TestCase { protected UnknownDistributionChiSquareTest testStatistic = new ChiSquareTestImpl(); public ChiSquareTestTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(ChiSquareTestTest.class); suite.setName("TestStatistic Tests"); return suite; } public void testChiSquare() throws Exception { // Target values computed using R version 1.8.1 // Some assembly required ;-) // Use sum((obs - exp)^2/exp) for the chi-square statistic and // 1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value long[] observed = {10, 9, 11}; double[] expected = {10, 10, 10}; assertEquals("chi-square statistic", 0.2, testStatistic.chiSquare(expected, observed), 10E-12); assertEquals("chi-square p-value", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10); long[] observed1 = { 500, 623, 72, 70, 31 }; double[] expected1 = { 485, 541, 82, 61, 37 }; assertEquals( "chi-square test statistic", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10); assertEquals("chi-square p-value", 0.06051952647453607, testStatistic.chiSquareTest(expected1, observed1), 1E-9); assertTrue("chi-square test reject", testStatistic.chiSquareTest(expected1, observed1, 0.08)); assertTrue("chi-square test accept", !testStatistic.chiSquareTest(expected1, observed1, 0.05)); try { testStatistic.chiSquareTest(expected1, observed1, 95); fail("alpha out of range, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } long[] tooShortObs = { 0 }; double[] tooShortEx = { 1 }; try { testStatistic.chiSquare(tooShortEx, tooShortObs); fail("arguments too short, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // unmatched arrays long[] unMatchedObs = { 0, 1, 2, 3 }; double[] unMatchedEx = { 1, 1, 2 }; try { testStatistic.chiSquare(unMatchedEx, unMatchedObs); fail("arrays have different lengths, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // 0 expected count expected[0] = 0; try { testStatistic.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } // negative observed count expected[0] = 1; observed[0] = -1; try { testStatistic.chiSquareTest(expected, observed, .01); fail("bad expected count, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testChiSquareIndependence() throws Exception { // Target values computed using R version 1.8.1 long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}}; assertEquals( "chi-square test statistic", 22.709027688, testStatistic.chiSquare(counts), 1E-9); assertEquals("chi-square p-value", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9); assertTrue("chi-square test reject", testStatistic.chiSquareTest(counts, 0.0002)); assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts, 0.0001)); long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} }; assertEquals( "chi-square test statistic", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9); assertEquals("chi-square p-value",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9); assertTrue("chi-square test accept", !testStatistic.chiSquareTest(counts2, 0.1)); // ragged input array long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}}; try { testStatistic.chiSquare(counts3); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // insufficient data long[][] counts4 = {{40, 22, 43}}; try { testStatistic.chiSquare(counts4); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } long[][] counts5 = {{40}, {40}, {30}, {10}}; try { testStatistic.chiSquare(counts5); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // negative counts long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} }; try { testStatistic.chiSquare(counts6); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // bad alpha try { testStatistic.chiSquareTest(counts, 0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } public void testChiSquareLargeTestStatistic() throws Exception { double[] exp = new double[] { 3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, 232921.0, 437665.75 }; long[] obs = new long[] { 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899 }; org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); double cst = csti.chiSquareTest(exp, obs); assertEquals("chi-square p-value", 0.0, cst, 1E-3); assertEquals( "chi-square test statistic", 114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9); } /** Contingency table containing zeros - PR # 32531 */ public void testChiSquareZeroCount() throws Exception { // Target values computed using R version 1.8.1 long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}}; assertEquals( "chi-square test statistic", 9.67444662263, testStatistic.chiSquare(counts), 1E-9); assertEquals("chi-square p-value", 0.0462835770603, testStatistic.chiSquareTest(counts), 1E-9); } /** Target values verified using DATAPLOT version 2006.3 */ public void testChiSquareDataSetsComparisonEqualCounts() throws Exception { long[] observed1 = {10, 12, 12, 10}; long[] observed2 = {5, 15, 14, 10}; assertEquals("chi-square p value", 0.541096, testStatistic.chiSquareTestDataSetsComparison( observed1, observed2), 1E-6); assertEquals("chi-square test statistic", 2.153846, testStatistic.chiSquareDataSetsComparison( observed1, observed2), 1E-6); assertFalse("chi-square test result", testStatistic.chiSquareTestDataSetsComparison( observed1, observed2, 0.4)); } /** Target values verified using DATAPLOT version 2006.3 */ public void testChiSquareDataSetsComparisonUnEqualCounts() throws Exception { long[] observed1 = {10, 12, 12, 10, 15}; long[] observed2 = {15, 10, 10, 15, 5}; assertEquals("chi-square p value", 0.124115, testStatistic.chiSquareTestDataSetsComparison( observed1, observed2), 1E-6); assertEquals("chi-square test statistic", 7.232189, testStatistic.chiSquareDataSetsComparison( observed1, observed2), 1E-6); assertTrue("chi-square test result", testStatistic.chiSquareTestDataSetsComparison( observed1, observed2, 0.13)); assertFalse("chi-square test result", testStatistic.chiSquareTestDataSetsComparison( observed1, observed2, 0.12)); } public void testChiSquareDataSetsComparisonBadCounts() throws Exception { long[] observed1 = {10, -1, 12, 10, 15}; long[] observed2 = {15, 10, 10, 15, 5}; try { testStatistic.chiSquareTestDataSetsComparison( observed1, observed2); fail("Expecting IllegalArgumentException - negative count"); } catch (IllegalArgumentException ex) { // expected } long[] observed3 = {10, 0, 12, 10, 15}; long[] observed4 = {15, 0, 10, 15, 5}; try { testStatistic.chiSquareTestDataSetsComparison( observed3, observed4); fail("Expecting IllegalArgumentException - double 0's"); } catch (IllegalArgumentException ex) { // expected } long[] observed5 = {10, 10, 12, 10, 15}; long[] observed6 = {0, 0, 0, 0, 0}; try { testStatistic.chiSquareTestDataSetsComparison( observed5, observed6); fail("Expecting IllegalArgumentException - vanishing counts"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.inference; import junit.framework.Test; import junit.framework.TestSuite; /** * Test cases for the ChiSquareTestFactory. * * @version $Revision$ $Date$ */ public class ChiSquareFactoryTest extends ChiSquareTestTest { public ChiSquareFactoryTest(String name) { super(name); } public void setUp() { super.setUp(); testStatistic = TestUtils.getUnknownDistributionChiSquareTest(); } public static Test suite() { TestSuite suite = new TestSuite(ChiSquareFactoryTest.class); suite.setName("ChiSquareTestFactory Tests"); return suite; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.inference; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import java.util.ArrayList; import java.util.List; /** * Test cases for the OneWayAnovaImpl class. * * @version $Revision$ $Date$ */ public class OneWayAnovaTest extends TestCase { protected OneWayAnova testStatistic = new OneWayAnovaImpl(); private double[] emptyArray = {}; private double[] classA = {93.0, 103.0, 95.0, 101.0, 91.0, 105.0, 96.0, 94.0, 101.0 }; private double[] classB = {99.0, 92.0, 102.0, 100.0, 102.0, 89.0 }; private double[] classC = {110.0, 115.0, 111.0, 117.0, 128.0, 117.0 }; public OneWayAnovaTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(OneWayAnovaTest.class); suite.setName("TestStatistic Tests"); return suite; } public void testAnovaFValue() throws Exception { // Target comparison values computed using R version 2.6.0 (Linux version) List<double[]> threeClasses = new ArrayList<double[]>(); threeClasses.add(classA); threeClasses.add(classB); threeClasses.add(classC); assertEquals("ANOVA F-value", 24.67361709460624, testStatistic.anovaFValue(threeClasses), 1E-12); List<double[]> twoClasses = new ArrayList<double[]>(); twoClasses.add(classA); twoClasses.add(classB); assertEquals("ANOVA F-value", 0.0150579150579, testStatistic.anovaFValue(twoClasses), 1E-12); List<double[]> emptyContents = new ArrayList<double[]>(); emptyContents.add(emptyArray); emptyContents.add(classC); try { testStatistic.anovaFValue(emptyContents); fail("empty array for key classX, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } List<double[]> tooFew = new ArrayList<double[]>(); tooFew.add(classA); try { testStatistic.anovaFValue(tooFew); fail("less than two classes, IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected } } public void testAnovaPValue() throws Exception { // Target comparison values computed using R version 2.6.0 (Linux version) List<double[]> threeClasses = new ArrayList<double[]>(); threeClasses.add(classA); threeClasses.add(classB); threeClasses.add(classC); assertEquals("ANOVA P-value", 6.959446E-06, testStatistic.anovaPValue(threeClasses), 1E-12); List<double[]> twoClasses = new ArrayList<double[]>(); twoClasses.add(classA); twoClasses.add(classB); assertEquals("ANOVA P-value", 0.904212960464, testStatistic.anovaPValue(twoClasses), 1E-12); } public void testAnovaTest() throws Exception { // Target comparison values computed using R version 2.3.1 (Linux version) List<double[]> threeClasses = new ArrayList<double[]>(); threeClasses.add(classA); threeClasses.add(classB); threeClasses.add(classC); assertTrue("ANOVA Test P<0.01", testStatistic.anovaTest(threeClasses, 0.01)); List<double[]> twoClasses = new ArrayList<double[]>(); twoClasses.add(classA); twoClasses.add(classB); assertFalse("ANOVA Test P>0.01", testStatistic.anovaTest(twoClasses, 0.01)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.data; /** * @version $Revision$ $Date$ */ public class LewTest extends CertifiedDataAbstractTest { protected String getResourceName() { return "org/apache/commons/math/stat/data/Lew.txt"; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.data; /** * @version $Revision$ $Date$ */ public class LotteryTest extends CertifiedDataAbstractTest { protected String getResourceName() { return "org/apache/commons/math/stat/data/Lottery.txt"; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.stat.data; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.net.URL; import java.util.HashMap; import java.util.Map; import junit.framework.TestCase; import org.apache.commons.math.TestUtils; import org.apache.commons.math.stat.descriptive.DescriptiveStatistics; import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * @version $Revision$ $Date$ */ public abstract class CertifiedDataAbstractTest extends TestCase { private DescriptiveStatistics descriptives; private SummaryStatistics summaries; private Map<String, Double> certifiedValues; protected void setUp() throws Exception { descriptives = new DescriptiveStatistics(); summaries = new SummaryStatistics(); certifiedValues = new HashMap<String, Double>(); loadData(); } private void loadData() throws IOException { BufferedReader in = null; try { URL resourceURL = getClass().getClassLoader().getResource(getResourceName()); in = new BufferedReader(new InputStreamReader(resourceURL.openStream())); String line = in.readLine(); while (line != null) { /* this call to StringUtils did little for the * following conditional structure */ line = line.trim(); // not empty line or comment if (!("".equals(line) || line.startsWith("#"))) { int n = line.indexOf('='); if (n == -1) { // data value double value = Double.parseDouble(line); descriptives.addValue(value); summaries.addValue(value); } else { // certified value String name = line.substring(0, n).trim(); String valueString = line.substring(n + 1).trim(); Double value = Double.valueOf(valueString); certifiedValues.put(name, value); } } line = in.readLine(); } } finally { if (in != null) { in.close(); } } } protected abstract String getResourceName(); protected double getMaximumAbsoluteError() { return 1.0e-5; } protected void tearDown() throws Exception { descriptives.clear(); descriptives = null; summaries.clear(); summaries = null; certifiedValues.clear(); certifiedValues = null; } public void testCertifiedValues() { for (String name : certifiedValues.keySet()) { Double expectedValue = (Double)certifiedValues.get(name); Double summariesValue = getProperty(summaries, name); if (summariesValue != null) { TestUtils.assertEquals("summary value for " + name + " is incorrect.", summariesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError()); } Double descriptivesValue = getProperty(descriptives, name); if (descriptivesValue != null) { TestUtils.assertEquals("descriptive value for " + name + " is incorrect.", descriptivesValue.doubleValue(), expectedValue.doubleValue(), getMaximumAbsoluteError()); } } } protected Double getProperty(Object bean, String name) { try { // Get the value of prop String prop = "get" + name.substring(0,1).toUpperCase() + name.substring(1); Method meth = bean.getClass().getMethod(prop, new Class[0]); Object property = meth.invoke(bean, new Object[0]); if (meth.getReturnType().equals(Double.TYPE)) { return (Double) property; } else if (meth.getReturnType().equals(Long.TYPE)) { return Double.valueOf(((Long) property).doubleValue()); } else { fail("wrong type: " + meth.getReturnType().getName()); } } catch (NoSuchMethodException nsme) { // ignored } catch (InvocationTargetException ite) { fail(ite.getMessage()); } catch (IllegalAccessException iae) { fail(iae.getMessage()); } return null; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.util; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class TransformerMapTest extends TestCase { /** * */ public void testPutTransformer(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); assertEquals(expected, map.getTransformer(TransformerMapTest.class)); } /** * */ public void testContainsClass(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); assertTrue(map.containsClass(TransformerMapTest.class)); } /** * */ public void testContainsTransformer(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); assertTrue(map.containsTransformer(expected)); } /** * */ public void testRemoveTransformer(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); assertTrue(map.containsClass(TransformerMapTest.class)); assertTrue(map.containsTransformer(expected)); map.removeTransformer(TransformerMapTest.class); assertFalse(map.containsClass(TransformerMapTest.class)); assertFalse(map.containsTransformer(expected)); } /** * */ public void testClear(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); assertTrue(map.containsClass(TransformerMapTest.class)); map.clear(); assertFalse(map.containsClass(TransformerMapTest.class)); } /** * */ public void testClasses(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); assertTrue(map.classes().contains(TransformerMapTest.class)); } /** * */ public void testTransformers(){ NumberTransformer expected = new DefaultTransformer(); TransformerMap map = new TransformerMap(); map.putTransformer(TransformerMapTest.class, expected); assertTrue(map.transformers().contains(expected)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.util; import org.apache.commons.math.stat.StatUtils; import junit.framework.TestCase; /** * This class contains test cases for the ExpandableDoubleArray. * * @version $Revision$ $Date$ */ public abstract class DoubleArrayAbstractTest extends TestCase { protected DoubleArray da = null; // Array used to test rolling protected DoubleArray ra = null; public DoubleArrayAbstractTest(String name) { super(name); } public void testAdd1000() { for (int i = 0; i < 1000; i++) { da.addElement(i); } assertEquals( "Number of elements should be equal to 1000 after adding 1000 values", 1000, da.getNumElements()); assertEquals( "The element at the 56th index should be 56", 56.0, da.getElement(56), Double.MIN_VALUE); } public void testGetValues() { double[] controlArray = { 2.0, 4.0, 6.0 }; da.addElement(2.0); da.addElement(4.0); da.addElement(6.0); double[] testArray = da.getElements(); for (int i = 0; i < da.getNumElements(); i++) { assertEquals( "The testArray values should equal the controlArray values, index i: " + i + " does not match", testArray[i], controlArray[i], Double.MIN_VALUE); } } public void testAddElementRolling() { ra.addElement(0.5); ra.addElement(1.0); ra.addElement(1.0); ra.addElement(1.0); ra.addElement(1.0); ra.addElement(1.0); ra.addElementRolling(2.0); assertEquals( "There should be 6 elements in the eda", 6, ra.getNumElements()); assertEquals( "The max element should be 2.0", 2.0, StatUtils.max(ra.getElements()), Double.MIN_VALUE); assertEquals( "The min element should be 1.0", 1.0, StatUtils.min(ra.getElements()), Double.MIN_VALUE); for (int i = 0; i < 1024; i++) { ra.addElementRolling(i); } assertEquals( "We just inserted 1024 rolling elements, num elements should still be 6", 6, ra.getNumElements()); } public void testMinMax() { da.addElement(2.0); da.addElement(22.0); da.addElement(-2.0); da.addElement(21.0); da.addElement(22.0); da.addElement(42.0); da.addElement(62.0); da.addElement(22.0); da.addElement(122.0); da.addElement(1212.0); assertEquals("Min should be -2.0", -2.0, StatUtils.min(da.getElements()), Double.MIN_VALUE); assertEquals( "Max should be 1212.0", 1212.0, StatUtils.max(da.getElements()), Double.MIN_VALUE); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.util; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class ContinuedFractionTest extends TestCase { /** * Constructor for ContinuedFractionTest. * @param name */ public ContinuedFractionTest(String name) { super(name); } public void testGoldenRatio(){ ContinuedFraction cf = new ContinuedFraction() { private static final long serialVersionUID = 4696264881688589546L; public double getA(int n, double x) { return 1.0; } public double getB(int n, double x) { return 1.0; } }; try { double gr = cf.evaluate(0.0, 10e-9); assertEquals(1.61803399, gr, 10e-9); } catch (MathException e) { fail(e.getMessage()); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.util; import java.math.BigDecimal; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class DefaultTransformerTest extends TestCase { /** * */ public void testTransformDouble() throws Exception { double expected = 1.0; Double input = Double.valueOf(expected); DefaultTransformer t = new DefaultTransformer(); assertEquals(expected, t.transform(input), 1.0e-4); } /** * */ public void testTransformNull(){ DefaultTransformer t = new DefaultTransformer(); try { t.transform(null); fail("Expection MathException"); } catch (MathException e) { // expected } } /** * */ public void testTransformInteger() throws Exception { double expected = 1.0; Integer input = Integer.valueOf(1); DefaultTransformer t = new DefaultTransformer(); assertEquals(expected, t.transform(input), 1.0e-4); } /** * */ public void testTransformBigDecimal() throws Exception { double expected = 1.0; BigDecimal input = new BigDecimal("1.0"); DefaultTransformer t = new DefaultTransformer(); assertEquals(expected, t.transform(input), 1.0e-4); } /** * */ public void testTransformString() throws Exception { double expected = 1.0; String input = "1.0"; DefaultTransformer t = new DefaultTransformer(); assertEquals(expected, t.transform(input), 1.0e-4); } /** * */ public void testTransformObject(){ Boolean input = Boolean.TRUE; DefaultTransformer t = new DefaultTransformer(); try { t.transform(input); fail("Expecting MathException"); } catch (MathException e) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with this * work for additional information regarding copyright ownership. The ASF * licenses this file to You under the Apache License, Version 2.0 (the * "License"); you may not use this file except in compliance with the License. * You may obtain a copy of the License at * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law * or agreed to in writing, software distributed under the License is * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the specific language * governing permissions and limitations under the License. */ package org.apache.commons.math.util; import java.math.BigDecimal; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.random.RandomDataImpl; import org.apache.commons.math.TestUtils; /** * Test cases for the MathUtils class. * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug * 2007) $ */ public final class MathUtilsTest extends TestCase { public MathUtilsTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(MathUtilsTest.class); suite.setName("MathUtils Tests"); return suite; } /** * Exact recursive implementation to test against */ private long binomialCoefficient(int n, int k) { if ((n == k) || (k == 0)) { return 1; } if ((k == 1) || (k == n - 1)) { return n; } return binomialCoefficient(n - 1, k - 1) + binomialCoefficient(n - 1, k); } /** * Exact direct multiplication implementation to test against */ private long factorial(int n) { long result = 1; for (int i = 2; i <= n; i++) { result *= i; } return result; } /** Verify that b(0,0) = 1 */ public void test0Choose0() { assertEquals(MathUtils.binomialCoefficientDouble(0, 0), 1d, 0); assertEquals(MathUtils.binomialCoefficientLog(0, 0), 0d, 0); assertEquals(MathUtils.binomialCoefficient(0, 0), 1); } public void testAddAndCheck() { int big = Integer.MAX_VALUE; int bigNeg = Integer.MIN_VALUE; assertEquals(big, MathUtils.addAndCheck(big, 0)); try { MathUtils.addAndCheck(big, 1); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { } try { MathUtils.addAndCheck(bigNeg, -1); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { } } public void testAddAndCheckLong() { long max = Long.MAX_VALUE; long min = Long.MIN_VALUE; assertEquals(max, MathUtils.addAndCheck(max, 0L)); assertEquals(min, MathUtils.addAndCheck(min, 0L)); assertEquals(max, MathUtils.addAndCheck(0L, max)); assertEquals(min, MathUtils.addAndCheck(0L, min)); assertEquals(1, MathUtils.addAndCheck(-1L, 2L)); assertEquals(1, MathUtils.addAndCheck(2L, -1L)); testAddAndCheckLongFailure(max, 1L); testAddAndCheckLongFailure(min, -1L); testAddAndCheckLongFailure(1L, max); testAddAndCheckLongFailure(-1L, min); } private void testAddAndCheckLongFailure(long a, long b) { try { MathUtils.addAndCheck(a, b); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { // success } } public void testBinomialCoefficient() { long[] bcoef5 = { 1, 5, 10, 10, 5, 1 }; long[] bcoef6 = { 1, 6, 15, 20, 15, 6, 1 }; for (int i = 0; i < 6; i++) { assertEquals("5 choose " + i, bcoef5[i], MathUtils.binomialCoefficient(5, i)); } for (int i = 0; i < 7; i++) { assertEquals("6 choose " + i, bcoef6[i], MathUtils.binomialCoefficient(6, i)); } for (int n = 1; n < 10; n++) { for (int k = 0; k <= n; k++) { assertEquals(n + " choose " + k, binomialCoefficient(n, k), MathUtils.binomialCoefficient(n, k)); assertEquals(n + " choose " + k, (double)binomialCoefficient(n, k), MathUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE); assertEquals(n + " choose " + k, Math.log((double)binomialCoefficient(n, k)), MathUtils.binomialCoefficientLog(n, k), 10E-12); } } /* * Takes a long time for recursion to unwind, but succeeds and yields * exact value = 2,333,606,220 * assertEquals(MathUtils.binomialCoefficient(34,17), * binomialCoefficient(34,17)); */ } public void testBinomialCoefficientFail() { try { MathUtils.binomialCoefficient(4, 5); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } try { MathUtils.binomialCoefficientDouble(4, 5); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } try { MathUtils.binomialCoefficientLog(4, 5); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } try { MathUtils.binomialCoefficient(67, 34); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) { ; } double x = MathUtils.binomialCoefficientDouble(1030, 515); assertTrue("expecting infinite binomial coefficient", Double.isInfinite(x)); } public void testCosh() { double x = 3.0; double expected = 10.06766; assertEquals(expected, MathUtils.cosh(x), 1.0e-5); } public void testCoshNaN() { assertTrue(Double.isNaN(MathUtils.cosh(Double.NaN))); } public void testEquals() { double[] testArray = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }; for (int i = 0; i < testArray.length; i++) { for (int j = 0; j < testArray.length; j++) { if (i == j) { assertTrue(MathUtils.equals(testArray[i], testArray[j])); assertTrue(MathUtils.equals(testArray[j], testArray[i])); } else { assertTrue(!MathUtils.equals(testArray[i], testArray[j])); assertTrue(!MathUtils.equals(testArray[j], testArray[i])); } } } } public void testArrayEquals() { assertFalse(MathUtils.equals(new double[] { 1d }, null)); assertFalse(MathUtils.equals(null, new double[] { 1d })); assertTrue(MathUtils.equals((double[]) null, (double[]) null)); assertFalse(MathUtils.equals(new double[] { 1d }, new double[0])); assertTrue(MathUtils.equals(new double[] { 1d }, new double[] { 1d })); assertTrue(MathUtils.equals(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }, new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d })); assertFalse(MathUtils.equals(new double[] { Double.POSITIVE_INFINITY }, new double[] { Double.NEGATIVE_INFINITY })); assertFalse(MathUtils.equals(new double[] { 1d }, new double[] { MathUtils.nextAfter(1d, 2d) })); } public void testFactorial() { for (int i = 1; i < 10; i++) { assertEquals(i + "! ", factorial(i), MathUtils.factorial(i)); assertEquals(i + "! ", (double)factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE); assertEquals(i + "! ", Math.log((double)factorial(i)), MathUtils.factorialLog(i), 10E-12); } assertEquals("0", 1, MathUtils.factorial(0)); assertEquals("0", 1.0d, MathUtils.factorialDouble(0), 1E-14); assertEquals("0", 0.0d, MathUtils.factorialLog(0), 1E-14); } public void testFactorialFail() { try { MathUtils.factorial(-1); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } try { MathUtils.factorialDouble(-1); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } try { MathUtils.factorialLog(-1); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } try { MathUtils.factorial(21); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) { ; } assertTrue("expecting infinite factorial value", Double.isInfinite(MathUtils.factorialDouble(171))); } public void testGcd() { int a = 30; int b = 50; int c = 77; assertEquals(0, MathUtils.gcd(0, 0)); assertEquals(b, MathUtils.gcd(0, b)); assertEquals(a, MathUtils.gcd(a, 0)); assertEquals(b, MathUtils.gcd(0, -b)); assertEquals(a, MathUtils.gcd(-a, 0)); assertEquals(10, MathUtils.gcd(a, b)); assertEquals(10, MathUtils.gcd(-a, b)); assertEquals(10, MathUtils.gcd(a, -b)); assertEquals(10, MathUtils.gcd(-a, -b)); assertEquals(1, MathUtils.gcd(a, c)); assertEquals(1, MathUtils.gcd(-a, c)); assertEquals(1, MathUtils.gcd(a, -c)); assertEquals(1, MathUtils.gcd(-a, -c)); } public void testHash() { double[] testArray = { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d, 1E-14, (1 + 1E-14), Double.MIN_VALUE, Double.MAX_VALUE }; for (int i = 0; i < testArray.length; i++) { for (int j = 0; j < testArray.length; j++) { if (i == j) { assertEquals(MathUtils.hash(testArray[i]), MathUtils.hash(testArray[j])); assertEquals(MathUtils.hash(testArray[j]), MathUtils.hash(testArray[i])); } else { assertTrue(MathUtils.hash(testArray[i]) != MathUtils.hash(testArray[j])); assertTrue(MathUtils.hash(testArray[j]) != MathUtils.hash(testArray[i])); } } } } public void testArrayHash() { assertEquals(0, MathUtils.hash((double[]) null)); assertEquals(MathUtils.hash(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d }), MathUtils.hash(new double[] { Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 1d, 0d })); assertFalse(MathUtils.hash(new double[] { 1d }) == MathUtils.hash(new double[] { MathUtils.nextAfter(1d, 2d) })); assertFalse(MathUtils.hash(new double[] { 1d }) == MathUtils.hash(new double[] { 1d, 1d })); } /** * Make sure that permuted arrays do not hash to the same value. */ public void testPermutedArrayHash() { double[] original = new double[10]; double[] permuted = new double[10]; RandomDataImpl random = new RandomDataImpl(); // Generate 10 distinct random values for (int i = 0; i < 10; i++) { original[i] = random.nextUniform((double)i + 0.5, (double)i + 0.75); } // Generate a random permutation, making sure it is not the identity boolean isIdentity = true; do { int[] permutation = random.nextPermutation(10, 10); for (int i = 0; i < 10; i++) { if (i != permutation[i]) { isIdentity = false; } permuted[i] = original[permutation[i]]; } } while (isIdentity); // Verify that permuted array has different hash assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted)); } public void testIndicatorByte() { assertEquals((byte)1, MathUtils.indicator((byte)2)); assertEquals((byte)1, MathUtils.indicator((byte)0)); assertEquals((byte)(-1), MathUtils.indicator((byte)(-2))); } public void testIndicatorDouble() { double delta = 0.0; assertEquals(1.0, MathUtils.indicator(2.0), delta); assertEquals(1.0, MathUtils.indicator(0.0), delta); assertEquals(-1.0, MathUtils.indicator(-2.0), delta); } public void testIndicatorFloat() { float delta = 0.0F; assertEquals(1.0F, MathUtils.indicator(2.0F), delta); assertEquals(1.0F, MathUtils.indicator(0.0F), delta); assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta); } public void testIndicatorInt() { assertEquals((int)1, MathUtils.indicator((int)(2))); assertEquals((int)1, MathUtils.indicator((int)(0))); assertEquals((int)(-1), MathUtils.indicator((int)(-2))); } public void testIndicatorLong() { assertEquals(1L, MathUtils.indicator(2L)); assertEquals(1L, MathUtils.indicator(0L)); assertEquals(-1L, MathUtils.indicator(-2L)); } public void testIndicatorShort() { assertEquals((short)1, MathUtils.indicator((short)2)); assertEquals((short)1, MathUtils.indicator((short)0)); assertEquals((short)(-1), MathUtils.indicator((short)(-2))); } public void testLcm() { int a = 30; int b = 50; int c = 77; assertEquals(0, MathUtils.lcm(0, b)); assertEquals(0, MathUtils.lcm(a, 0)); assertEquals(b, MathUtils.lcm(1, b)); assertEquals(a, MathUtils.lcm(a, 1)); assertEquals(150, MathUtils.lcm(a, b)); assertEquals(150, MathUtils.lcm(-a, b)); assertEquals(150, MathUtils.lcm(a, -b)); assertEquals(2310, MathUtils.lcm(a, c)); try { MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { // expected } } public void testLog() { assertEquals(2.0, MathUtils.log(2, 4), 0); assertEquals(3.0, MathUtils.log(2, 8), 0); assertTrue(Double.isNaN(MathUtils.log(-1, 1))); assertTrue(Double.isNaN(MathUtils.log(1, -1))); assertTrue(Double.isNaN(MathUtils.log(0, 0))); assertEquals(0, MathUtils.log(0, 10), 0); assertEquals(Double.NEGATIVE_INFINITY, MathUtils.log(10, 0), 0); } public void testMulAndCheck() { int big = Integer.MAX_VALUE; int bigNeg = Integer.MIN_VALUE; assertEquals(big, MathUtils.mulAndCheck(big, 1)); try { MathUtils.mulAndCheck(big, 2); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { } try { MathUtils.mulAndCheck(bigNeg, 2); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { } } public void testMulAndCheckLong() { long max = Long.MAX_VALUE; long min = Long.MIN_VALUE; assertEquals(max, MathUtils.mulAndCheck(max, 1L)); assertEquals(min, MathUtils.mulAndCheck(min, 1L)); assertEquals(0L, MathUtils.mulAndCheck(max, 0L)); assertEquals(0L, MathUtils.mulAndCheck(min, 0L)); assertEquals(max, MathUtils.mulAndCheck(1L, max)); assertEquals(min, MathUtils.mulAndCheck(1L, min)); assertEquals(0L, MathUtils.mulAndCheck(0L, max)); assertEquals(0L, MathUtils.mulAndCheck(0L, min)); testMulAndCheckLongFailure(max, 2L); testMulAndCheckLongFailure(2L, max); testMulAndCheckLongFailure(min, 2L); testMulAndCheckLongFailure(2L, min); testMulAndCheckLongFailure(min, -1L); testMulAndCheckLongFailure(-1L, min); } private void testMulAndCheckLongFailure(long a, long b) { try { MathUtils.mulAndCheck(a, b); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { // success } } public void testNextAfter() { // 0x402fffffffffffff 0x404123456789abcd -> 4030000000000000 assertEquals(16.0, MathUtils.nextAfter(15.999999999999998, 34.27555555555555), 0.0); // 0xc02fffffffffffff 0x404123456789abcd -> c02ffffffffffffe assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 34.27555555555555), 0.0); // 0x402fffffffffffff 0x400123456789abcd -> 402ffffffffffffe assertEquals(15.999999999999996, MathUtils.nextAfter(15.999999999999998, 2.142222222222222), 0.0); // 0xc02fffffffffffff 0x400123456789abcd -> c02ffffffffffffe assertEquals(-15.999999999999996, MathUtils.nextAfter(-15.999999999999998, 2.142222222222222), 0.0); // 0x4020000000000000 0x404123456789abcd -> 4020000000000001 assertEquals(8.000000000000002, MathUtils.nextAfter(8.0, 34.27555555555555), 0.0); // 0xc020000000000000 0x404123456789abcd -> c01fffffffffffff assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 34.27555555555555), 0.0); // 0x4020000000000000 0x400123456789abcd -> 401fffffffffffff assertEquals(7.999999999999999, MathUtils.nextAfter(8.0, 2.142222222222222), 0.0); // 0xc020000000000000 0x400123456789abcd -> c01fffffffffffff assertEquals(-7.999999999999999, MathUtils.nextAfter(-8.0, 2.142222222222222), 0.0); // 0x3f2e43753d36a223 0x3f2e43753d36a224 -> 3f2e43753d36a224 assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.308922399667661E-4), 0.0); // 0x3f2e43753d36a223 0x3f2e43753d36a223 -> 3f2e43753d36a224 assertEquals(2.308922399667661E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676606E-4), 0.0); // 0x3f2e43753d36a223 0x3f2e43753d36a222 -> 3f2e43753d36a222 assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, 2.3089223996676603E-4), 0.0); // 0x3f2e43753d36a223 0xbf2e43753d36a224 -> 3f2e43753d36a222 assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.308922399667661E-4), 0.0); // 0x3f2e43753d36a223 0xbf2e43753d36a223 -> 3f2e43753d36a222 assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676606E-4), 0.0); // 0x3f2e43753d36a223 0xbf2e43753d36a222 -> 3f2e43753d36a222 assertEquals(2.3089223996676603E-4, MathUtils.nextAfter(2.3089223996676606E-4, -2.3089223996676603E-4), 0.0); // 0xbf2e43753d36a223 0x3f2e43753d36a224 -> bf2e43753d36a222 assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.308922399667661E-4), 0.0); // 0xbf2e43753d36a223 0x3f2e43753d36a223 -> bf2e43753d36a222 assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676606E-4), 0.0); // 0xbf2e43753d36a223 0x3f2e43753d36a222 -> bf2e43753d36a222 assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, 2.3089223996676603E-4), 0.0); // 0xbf2e43753d36a223 0xbf2e43753d36a224 -> bf2e43753d36a224 assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.308922399667661E-4), 0.0); // 0xbf2e43753d36a223 0xbf2e43753d36a223 -> bf2e43753d36a224 assertEquals(-2.308922399667661E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676606E-4), 0.0); // 0xbf2e43753d36a223 0xbf2e43753d36a222 -> bf2e43753d36a222 assertEquals(-2.3089223996676603E-4, MathUtils.nextAfter(-2.3089223996676606E-4, -2.3089223996676603E-4), 0.0); } public void testNextAfterSpecialCases() { assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.NEGATIVE_INFINITY, 0))); assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.POSITIVE_INFINITY, 0))); assertTrue(Double.isNaN(MathUtils.nextAfter(Double.NaN, 0))); assertTrue(Double.isInfinite(MathUtils.nextAfter(Double.MAX_VALUE, Double.POSITIVE_INFINITY))); assertTrue(Double.isInfinite(MathUtils.nextAfter(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY))); assertEquals(Double.MIN_VALUE, MathUtils.nextAfter(0, 1), 0); assertEquals(-Double.MIN_VALUE, MathUtils.nextAfter(0, -1), 0); assertEquals(0, MathUtils.nextAfter(Double.MIN_VALUE, -1), 0); assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE, 1), 0); } public void testScalb() { assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15); assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15); assertEquals(1.0 / 32.0, MathUtils.scalb(1.0, -5), 1.0e-15); assertEquals(Math.PI, MathUtils.scalb(Math.PI, 0), 1.0e-15); assertTrue(Double.isInfinite(MathUtils.scalb(Double.POSITIVE_INFINITY, 1))); assertTrue(Double.isInfinite(MathUtils.scalb(Double.NEGATIVE_INFINITY, 1))); assertTrue(Double.isNaN(MathUtils.scalb(Double.NaN, 1))); } public void testNormalizeAngle() { for (double a = -15.0; a <= 15.0; a += 0.1) { for (double b = -15.0; b <= 15.0; b += 0.2) { double c = MathUtils.normalizeAngle(a, b); assertTrue((b - Math.PI) <= c); assertTrue(c <= (b + Math.PI)); double twoK = Math.rint((a - c) / Math.PI); assertEquals(c, a - twoK * Math.PI, 1.0e-14); } } } public void testRoundDouble() { double x = 1.234567890; assertEquals(1.23, MathUtils.round(x, 2), 0.0); assertEquals(1.235, MathUtils.round(x, 3), 0.0); assertEquals(1.2346, MathUtils.round(x, 4), 0.0); // JIRA MATH-151 assertEquals(39.25, MathUtils.round(39.245, 2), 0.0); assertEquals(39.24, MathUtils.round(39.245, 2, BigDecimal.ROUND_DOWN), 0.0); double xx = 39.0; xx = xx + 245d / 1000d; assertEquals(39.25, MathUtils.round(xx, 2), 0.0); // BZ 35904 assertEquals(30.1d, MathUtils.round(30.095d, 2), 0.0d); assertEquals(30.1d, MathUtils.round(30.095d, 1), 0.0d); assertEquals(33.1d, MathUtils.round(33.095d, 1), 0.0d); assertEquals(33.1d, MathUtils.round(33.095d, 2), 0.0d); assertEquals(50.09d, MathUtils.round(50.085d, 2), 0.0d); assertEquals(50.19d, MathUtils.round(50.185d, 2), 0.0d); assertEquals(50.01d, MathUtils.round(50.005d, 2), 0.0d); assertEquals(30.01d, MathUtils.round(30.005d, 2), 0.0d); assertEquals(30.65d, MathUtils.round(30.645d, 2), 0.0d); assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0); assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0); assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0); assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0); assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0); assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0); assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0); assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0); assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0); assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0); assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0); assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0); assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0); assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0); try { MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY); fail(); } catch (ArithmeticException ex) { // success } assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0); assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0); assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0); assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0); assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0); assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0); try { MathUtils.round(1.234, 2, 1923); fail(); } catch (IllegalArgumentException ex) { // success } // MATH-151 assertEquals(39.25, MathUtils.round(39.245, 2, BigDecimal.ROUND_HALF_UP), 0.0); // special values TestUtils.assertEquals(Double.NaN, MathUtils.round(Double.NaN, 2), 0.0); assertEquals(0.0, MathUtils.round(0.0, 2), 0.0); assertEquals(Double.POSITIVE_INFINITY, MathUtils.round(Double.POSITIVE_INFINITY, 2), 0.0); assertEquals(Double.NEGATIVE_INFINITY, MathUtils.round(Double.NEGATIVE_INFINITY, 2), 0.0); } public void testRoundFloat() { float x = 1.234567890f; assertEquals(1.23f, MathUtils.round(x, 2), 0.0); assertEquals(1.235f, MathUtils.round(x, 3), 0.0); assertEquals(1.2346f, MathUtils.round(x, 4), 0.0); // BZ 35904 assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f); assertEquals(30.1f, MathUtils.round(30.095f, 1), 0.0f); assertEquals(50.09f, MathUtils.round(50.085f, 2), 0.0f); assertEquals(50.19f, MathUtils.round(50.185f, 2), 0.0f); assertEquals(50.01f, MathUtils.round(50.005f, 2), 0.0f); assertEquals(30.01f, MathUtils.round(30.005f, 2), 0.0f); assertEquals(30.65f, MathUtils.round(30.645f, 2), 0.0f); assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0); assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0); assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0); assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0); assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0); assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0); assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0); assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0); assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0); assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0); assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0); assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0); assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0); assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0); assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0); assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0); assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0); assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0); try { MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY); fail(); } catch (ArithmeticException ex) { // success } assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0); assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0); assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0); assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0); assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0); assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0); try { MathUtils.round(1.234f, 2, 1923); fail(); } catch (IllegalArgumentException ex) { // success } // special values TestUtils.assertEquals(Float.NaN, MathUtils.round(Float.NaN, 2), 0.0f); assertEquals(0.0f, MathUtils.round(0.0f, 2), 0.0f); assertEquals(Float.POSITIVE_INFINITY, MathUtils.round(Float.POSITIVE_INFINITY, 2), 0.0f); assertEquals(Float.NEGATIVE_INFINITY, MathUtils.round(Float.NEGATIVE_INFINITY, 2), 0.0f); } public void testSignByte() { assertEquals((byte)1, MathUtils.indicator((byte)2)); assertEquals((byte)(-1), MathUtils.indicator((byte)(-2))); } public void testSignDouble() { double delta = 0.0; assertEquals(1.0, MathUtils.indicator(2.0), delta); assertEquals(-1.0, MathUtils.indicator(-2.0), delta); } public void testSignFloat() { float delta = 0.0F; assertEquals(1.0F, MathUtils.indicator(2.0F), delta); assertEquals(-1.0F, MathUtils.indicator(-2.0F), delta); } public void testSignInt() { assertEquals((int)1, MathUtils.indicator((int)(2))); assertEquals((int)(-1), MathUtils.indicator((int)(-2))); } public void testSignLong() { assertEquals(1L, MathUtils.indicator(2L)); assertEquals(-1L, MathUtils.indicator(-2L)); } public void testSignShort() { assertEquals((short)1, MathUtils.indicator((short)2)); assertEquals((short)(-1), MathUtils.indicator((short)(-2))); } public void testSinh() { double x = 3.0; double expected = 10.01787; assertEquals(expected, MathUtils.sinh(x), 1.0e-5); } public void testSinhNaN() { assertTrue(Double.isNaN(MathUtils.sinh(Double.NaN))); } public void testSubAndCheck() { int big = Integer.MAX_VALUE; int bigNeg = Integer.MIN_VALUE; assertEquals(big, MathUtils.subAndCheck(big, 0)); try { MathUtils.subAndCheck(big, -1); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { } try { MathUtils.subAndCheck(bigNeg, 1); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { } } public void testSubAndCheckErrorMessage() { int big = Integer.MAX_VALUE; try { MathUtils.subAndCheck(big, -1); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { assertEquals("overflow: subtract", ex.getMessage()); } } public void testSubAndCheckLong() { long max = Long.MAX_VALUE; long min = Long.MIN_VALUE; assertEquals(max, MathUtils.subAndCheck(max, 0)); assertEquals(min, MathUtils.subAndCheck(min, 0)); assertEquals(-max, MathUtils.subAndCheck(0, max)); testSubAndCheckLongFailure(0L, min); testSubAndCheckLongFailure(max, -1L); testSubAndCheckLongFailure(min, 1L); } private void testSubAndCheckLongFailure(long a, long b) { try { MathUtils.subAndCheck(a, b); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { // success } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.util; import org.apache.commons.math.random.RandomDataImpl; import org.apache.commons.math.random.RandomData; /** * This class contains test cases for the ResizableDoubleArray. * * @version $Revision$ $Date$ */ public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest { public ResizableDoubleArrayTest(String name) { super( name ); } protected void tearDown() throws Exception { da = null; ra = null; } protected void setUp() throws Exception { da = new ResizableDoubleArray(); ra = new ResizableDoubleArray(); } public void testConstructors() { float defaultExpansionFactor = 2.0f; float defaultContractionCriteria = 2.5f; int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE; ResizableDoubleArray testDa = new ResizableDoubleArray(2); assertEquals(0, testDa.getNumElements()); assertEquals(2, testDa.getInternalLength()); assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0); assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0); assertEquals(defaultMode, testDa.getExpansionMode()); try { da = new ResizableDoubleArray(-1); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } testDa = new ResizableDoubleArray(2, 2.0f); assertEquals(0, testDa.getNumElements()); assertEquals(2, testDa.getInternalLength()); assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0); assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0); assertEquals(defaultMode, testDa.getExpansionMode()); try { da = new ResizableDoubleArray(2, 0.5f); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } testDa = new ResizableDoubleArray(2, 3.0f); assertEquals(3.0f, testDa.getExpansionFactor(), 0); assertEquals(3.5f, testDa.getContractionCriteria(), 0); testDa = new ResizableDoubleArray(2, 2.0f, 3.0f); assertEquals(0, testDa.getNumElements()); assertEquals(2, testDa.getInternalLength()); assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0); assertEquals(3.0f, testDa.getContractionCriteria(), 0); assertEquals(defaultMode, testDa.getExpansionMode()); try { da = new ResizableDoubleArray(2, 2.0f, 1.5f); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, ResizableDoubleArray.ADDITIVE_MODE); assertEquals(0, testDa.getNumElements()); assertEquals(2, testDa.getInternalLength()); assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0); assertEquals(3.0f, testDa.getContractionCriteria(), 0); assertEquals(ResizableDoubleArray.ADDITIVE_MODE, testDa.getExpansionMode()); try { da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } // Copy constructor testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, ResizableDoubleArray.ADDITIVE_MODE); testDa.addElement(2.0); testDa.addElement(3.2); ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa); assertEquals(copyDa, testDa); assertEquals(testDa, copyDa); } public void testSetElementArbitraryExpansion() { // MULTIPLICATIVE_MODE da.addElement(2.0); da.addElement(4.0); da.addElement(6.0); da.setElement(1, 3.0); // Expand the array arbitrarily to 1000 items da.setElement(1000, 3.4); assertEquals( "The number of elements should now be 1001, it isn't", da.getNumElements(), 1001); assertEquals( "Uninitialized Elements are default value of 0.0, index 766 wasn't", 0.0, da.getElement( 760 ), Double.MIN_VALUE ); assertEquals( "The 1000th index should be 3.4, it isn't", 3.4, da.getElement(1000), Double.MIN_VALUE ); assertEquals( "The 0th index should be 2.0, it isn't", 2.0, da.getElement(0), Double.MIN_VALUE); // Make sure numElements and expansion work correctly for expansion boundary cases da.clear(); da.addElement(2.0); da.addElement(4.0); da.addElement(6.0); assertEquals(4, ((ResizableDoubleArray) da).getInternalLength()); assertEquals(3, da.getNumElements()); da.setElement(3, 7.0); assertEquals(4, ((ResizableDoubleArray) da).getInternalLength()); assertEquals(4, da.getNumElements()); da.setElement(10, 10.0); assertEquals(11, ((ResizableDoubleArray) da).getInternalLength()); assertEquals(11, da.getNumElements()); da.setElement(9, 10.0); assertEquals(11, ((ResizableDoubleArray) da).getInternalLength()); assertEquals(11, da.getNumElements()); try { da.setElement(-2, 3); fail("Expecting ArrayIndexOutOfBoundsException for negative index"); } catch (ArrayIndexOutOfBoundsException ex) { // expected } // ADDITIVE_MODE ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, ResizableDoubleArray.ADDITIVE_MODE); assertEquals(2, testDa.getInternalLength()); testDa.addElement(1d); testDa.addElement(1d); assertEquals(2, testDa.getInternalLength()); testDa.addElement(1d); assertEquals(4, testDa.getInternalLength()); } public void testAdd1000() { super.testAdd1000(); assertEquals("Internal Storage length should be 1024 if we started out with initial capacity of " + "16 and an expansion factor of 2.0", 1024, ((ResizableDoubleArray) da).getInternalLength()); } public void testAddElementRolling() { super.testAddElementRolling(); // MULTIPLICATIVE_MODE da.clear(); da.addElement(1); da.addElement(2); da.addElementRolling(3); assertEquals(3, da.getElement(1), 0); da.addElementRolling(4); assertEquals(3, da.getElement(0), 0); assertEquals(4, da.getElement(1), 0); da.addElement(5); assertEquals(5, da.getElement(2), 0); da.addElementRolling(6); assertEquals(4, da.getElement(0), 0); assertEquals(5, da.getElement(1), 0); assertEquals(6, da.getElement(2), 0); // ADDITIVE_MODE (x's are occupied storage locations, 0's are open) ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f, ResizableDoubleArray.ADDITIVE_MODE); assertEquals(2, testDa.getInternalLength()); testDa.addElement(1d); // x,0 testDa.addElement(2d); // x,x testDa.addElement(3d); // x,x,x,0 -- expanded assertEquals(1d, testDa.getElement(0), 0); assertEquals(2d, testDa.getElement(1), 0); assertEquals(3d, testDa.getElement(2), 0); assertEquals(4, testDa.getInternalLength()); // x,x,x,0 assertEquals(3, testDa.getNumElements()); testDa.addElementRolling(4d); assertEquals(2d, testDa.getElement(0), 0); assertEquals(3d, testDa.getElement(1), 0); assertEquals(4d, testDa.getElement(2), 0); assertEquals(4, testDa.getInternalLength()); // 0,x,x,x assertEquals(3, testDa.getNumElements()); testDa.addElementRolling(5d); // 0,0,x,x,x,0 -- time to contract assertEquals(3d, testDa.getElement(0), 0); assertEquals(4d, testDa.getElement(1), 0); assertEquals(5d, testDa.getElement(2), 0); assertEquals(4, testDa.getInternalLength()); // contracted -- x,x,x,0 assertEquals(3, testDa.getNumElements()); try { testDa.getElement(4); fail("Expecting ArrayIndexOutOfBoundsException"); } catch (ArrayIndexOutOfBoundsException ex) { // expected } try { testDa.getElement(-1); fail("Expecting ArrayIndexOutOfBoundsException"); } catch (ArrayIndexOutOfBoundsException ex) { // expected } } public void testSetNumberOfElements() { da.addElement( 1.0 ); da.addElement( 1.0 ); da.addElement( 1.0 ); da.addElement( 1.0 ); da.addElement( 1.0 ); da.addElement( 1.0 ); assertEquals( "Number of elements should equal 6", da.getNumElements(), 6); ((ResizableDoubleArray) da).setNumElements( 3 ); assertEquals( "Number of elements should equal 3", da.getNumElements(), 3); try { ((ResizableDoubleArray) da).setNumElements( -3 ); fail( "Setting number of elements to negative should've thrown an exception"); } catch( IllegalArgumentException iae ) { } ((ResizableDoubleArray) da).setNumElements(1024); assertEquals( "Number of elements should now be 1024", da.getNumElements(), 1024); assertEquals( "Element 453 should be a default double", da.getElement( 453 ), 0.0, Double.MIN_VALUE); } public void testWithInitialCapacity() { ResizableDoubleArray eDA2 = new ResizableDoubleArray(2); assertEquals("Initial number of elements should be 0", 0, eDA2.getNumElements()); RandomData randomData = new RandomDataImpl(); int iterations = randomData.nextInt(100, 1000); for( int i = 0; i < iterations; i++) { eDA2.addElement( i ); } assertEquals("Number of elements should be equal to " + iterations, iterations, eDA2.getNumElements()); eDA2.addElement( 2.0 ); assertEquals("Number of elements should be equals to " + (iterations +1), iterations + 1 , eDA2.getNumElements() ); } public void testWithInitialCapacityAndExpansionFactor() { ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f); assertEquals("Initial number of elements should be 0", 0, eDA3.getNumElements() ); RandomData randomData = new RandomDataImpl(); int iterations = randomData.nextInt(100, 3000); for( int i = 0; i < iterations; i++) { eDA3.addElement( i ); } assertEquals("Number of elements should be equal to " + iterations, iterations,eDA3.getNumElements()); eDA3.addElement( 2.0 ); assertEquals("Number of elements should be equals to " + (iterations +1), iterations +1, eDA3.getNumElements() ); assertEquals("Expansion factor should equal 3.0", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE); } public void testDiscard() { da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); assertEquals( "Number of elements should be 11", 11, da.getNumElements()); ((ResizableDoubleArray)da).discardFrontElements(5); assertEquals( "Number of elements should be 6", 6, da.getNumElements()); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); assertEquals( "Number of elements should be 10", 10, da.getNumElements()); ((ResizableDoubleArray)da).discardMostRecentElements(2); assertEquals( "Number of elements should be 8", 8, da.getNumElements()); try { ((ResizableDoubleArray)da).discardFrontElements(-1); fail( "Trying to discard a negative number of element is not allowed"); } catch( Exception e ){ } try { ((ResizableDoubleArray)da).discardMostRecentElements(-1); fail( "Trying to discard a negative number of element is not allowed"); } catch( Exception e ){ } try { ((ResizableDoubleArray)da).discardFrontElements( 10000 ); fail( "You can't discard more elements than the array contains"); } catch( Exception e ){ } try { ((ResizableDoubleArray)da).discardMostRecentElements( 10000 ); fail( "You can't discard more elements than the array contains"); } catch( Exception e ){ } } public void testSubstitute() { da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); da.addElement(2.0); assertEquals( "Number of elements should be 11", 11, da.getNumElements()); ((ResizableDoubleArray)da).substituteMostRecentElement(24); assertEquals( "Number of elements should be 11", 11, da.getNumElements()); try { ((ResizableDoubleArray)da).discardMostRecentElements(10); } catch( Exception e ){ fail( "Trying to discard a negative number of element is not allowed"); } ((ResizableDoubleArray)da).substituteMostRecentElement(24); assertEquals( "Number of elements should be 1", 1, da.getNumElements()); } public void testMutators() { ((ResizableDoubleArray)da).setContractionCriteria(10f); assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0); ((ResizableDoubleArray)da).setExpansionFactor(8f); assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0); try { ((ResizableDoubleArray)da).setExpansionFactor(11f); // greater than contractionCriteria fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } ((ResizableDoubleArray)da).setExpansionMode( ResizableDoubleArray.ADDITIVE_MODE); assertEquals(ResizableDoubleArray.ADDITIVE_MODE, ((ResizableDoubleArray)da).getExpansionMode()); try { ((ResizableDoubleArray)da).setExpansionMode(-1); fail ("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } public void testEqualsAndHashCode() throws Exception { // Wrong type ResizableDoubleArray first = new ResizableDoubleArray(); Double other = new Double(2); assertFalse(first.equals(other)); // Null other = null; assertFalse(first.equals(other)); // Reflexive assertTrue(first.equals(first)); // Argumentless constructor ResizableDoubleArray second = new ResizableDoubleArray(); verifyEquality(first, second); // Equals iff same data, same properties ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f); verifyInequality(third, first); ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0f, 2.0f); ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0f, 2.0f); verifyEquality(third, fourth); verifyInequality(third, fifth); third.addElement(4.1); third.addElement(4.2); third.addElement(4.3); fourth.addElement(4.1); fourth.addElement(4.2); fourth.addElement(4.3); verifyEquality(third, fourth); // expand fourth.addElement(4.4); verifyInequality(third, fourth); third.addElement(4.4); verifyEquality(third, fourth); fourth.addElement(4.4); verifyInequality(third, fourth); third.addElement(4.4); verifyEquality(third, fourth); fourth.addElementRolling(4.5); third.addElementRolling(4.5); verifyEquality(third, fourth); // discard third.discardFrontElements(1); verifyInequality(third, fourth); fourth.discardFrontElements(1); verifyEquality(third, fourth); // discard recent third.discardMostRecentElements(2); fourth.discardMostRecentElements(2); verifyEquality(third, fourth); // wrong order third.addElement(18); fourth.addElement(17); third.addElement(17); fourth.addElement(18); verifyInequality(third, fourth); // copy ResizableDoubleArray.copy(fourth, fifth); verifyEquality(fourth, fifth); // Copy constructor verifyEquality(fourth, new ResizableDoubleArray(fourth)); // Instance copy verifyEquality(fourth, fourth.copy()); } private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) { assertTrue(b.equals(a)); assertTrue(a.equals(b)); assertEquals(a.hashCode(), b.hashCode()); } private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) { assertFalse(b.equals(a)); assertFalse(a.equals(b)); assertFalse(a.hashCode() == b.hashCode()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.complex; import org.apache.commons.math.TestUtils; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class ComplexTest extends TestCase { private double inf = Double.POSITIVE_INFINITY; private double neginf = Double.NEGATIVE_INFINITY; private double nan = Double.NaN; private double pi = Math.PI; private Complex oneInf = new Complex(1, inf); private Complex oneNegInf = new Complex(1, neginf); private Complex infOne = new Complex(inf, 1); private Complex infZero = new Complex(inf, 0); private Complex infNaN = new Complex(inf, nan); private Complex infNegInf = new Complex(inf, neginf); private Complex infInf = new Complex(inf, inf); private Complex negInfInf = new Complex(neginf, inf); private Complex negInfZero = new Complex(neginf, 0); private Complex negInfOne = new Complex(neginf, 1); private Complex negInfNaN = new Complex(neginf, nan); private Complex negInfNegInf = new Complex(neginf, neginf); private Complex oneNaN = new Complex(1, nan); private Complex zeroInf = new Complex(0, inf); private Complex zeroNaN = new Complex(0, nan); private Complex nanInf = new Complex(nan, inf); private Complex nanNegInf = new Complex(nan, neginf); private Complex nanZero = new Complex(nan, 0); public void testConstructor() { Complex z = new Complex(3.0, 4.0); assertEquals(3.0, z.getReal(), 1.0e-5); assertEquals(4.0, z.getImaginary(), 1.0e-5); } public void testConstructorNaN() { Complex z = new Complex(3.0, Double.NaN); assertTrue(z.isNaN()); z = new Complex(nan, 4.0); assertTrue(z.isNaN()); z = new Complex(3.0, 4.0); assertFalse(z.isNaN()); } public void testAbs() { Complex z = new Complex(3.0, 4.0); assertEquals(5.0, z.abs(), 1.0e-5); } public void testAbsNaN() { assertTrue(Double.isNaN(Complex.NaN.abs())); Complex z = new Complex(inf, nan); assertTrue(Double.isNaN(z.abs())); } public void testAbsInfinite() { Complex z = new Complex(inf, 0); assertEquals(inf, z.abs(), 0); z = new Complex(0, neginf); assertEquals(inf, z.abs(), 0); z = new Complex(inf, neginf); assertEquals(inf, z.abs(), 0); } public void testAdd() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.add(y); assertEquals(8.0, z.getReal(), 1.0e-5); assertEquals(10.0, z.getImaginary(), 1.0e-5); } public void testAddNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.add(Complex.NaN); assertTrue(z.isNaN()); z = new Complex(1, nan); Complex w = x.add(z); assertEquals(w.getReal(), 4.0, 0); assertTrue(Double.isNaN(w.getImaginary())); } public void testAddInfinite() { Complex x = new Complex(1, 1); Complex z = new Complex(inf, 0); Complex w = x.add(z); assertEquals(w.getImaginary(), 1, 0); assertEquals(inf, w.getReal(), 0); x = new Complex(neginf, 0); assertTrue(Double.isNaN(x.add(z).getReal())); } public void testConjugate() { Complex x = new Complex(3.0, 4.0); Complex z = x.conjugate(); assertEquals(3.0, z.getReal(), 1.0e-5); assertEquals(-4.0, z.getImaginary(), 1.0e-5); } public void testConjugateNaN() { Complex z = Complex.NaN.conjugate(); assertTrue(z.isNaN()); } public void testConjugateInfiinite() { Complex z = new Complex(0, inf); assertEquals(neginf, z.conjugate().getImaginary(), 0); z = new Complex(0, neginf); assertEquals(inf, z.conjugate().getImaginary(), 0); } public void testDivide() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.divide(y); assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5); assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5); } public void testDivideInfinite() { Complex x = new Complex(3, 4); Complex w = new Complex(neginf, inf); assertTrue(x.divide(w).equals(Complex.ZERO)); Complex z = w.divide(x); assertTrue(Double.isNaN(z.getReal())); assertEquals(inf, z.getImaginary(), 0); w = new Complex(inf, inf); z = w.divide(x); assertTrue(Double.isNaN(z.getImaginary())); assertEquals(inf, z.getReal(), 0); w = new Complex(1, inf); z = w.divide(w); assertTrue(Double.isNaN(z.getReal())); assertTrue(Double.isNaN(z.getImaginary())); } public void testDivideNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.divide(Complex.NaN); assertTrue(z.isNaN()); } public void testDivideNaNInf() { Complex z = oneInf.divide(Complex.ONE); assertTrue(Double.isNaN(z.getReal())); assertEquals(inf, z.getImaginary(), 0); z = negInfNegInf.divide(oneNaN); assertTrue(Double.isNaN(z.getReal())); assertTrue(Double.isNaN(z.getImaginary())); z = negInfInf.divide(Complex.ONE); assertTrue(Double.isNaN(z.getReal())); assertTrue(Double.isNaN(z.getImaginary())); } public void testMultiply() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.multiply(y); assertEquals(-9.0, z.getReal(), 1.0e-5); assertEquals(38.0, z.getImaginary(), 1.0e-5); } public void testMultiplyNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.multiply(Complex.NaN); assertTrue(z.isNaN()); } public void testMultiplyNaNInf() { Complex z = new Complex(1,1); Complex w = z.multiply(infOne); assertEquals(w.getReal(), inf, 0); assertEquals(w.getImaginary(), inf, 0); // [MATH-164] assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF)); assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF)); assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF)); w = oneInf.multiply(oneNegInf); assertEquals(w.getReal(), inf, 0); assertEquals(w.getImaginary(), inf, 0); w = negInfNegInf.multiply(oneNaN); assertTrue(Double.isNaN(w.getReal())); assertTrue(Double.isNaN(w.getImaginary())); } public void testNegate() { Complex x = new Complex(3.0, 4.0); Complex z = x.negate(); assertEquals(-3.0, z.getReal(), 1.0e-5); assertEquals(-4.0, z.getImaginary(), 1.0e-5); } public void testNegateNaN() { Complex z = Complex.NaN.negate(); assertTrue(z.isNaN()); } public void testSubtract() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(5.0, 6.0); Complex z = x.subtract(y); assertEquals(-2.0, z.getReal(), 1.0e-5); assertEquals(-2.0, z.getImaginary(), 1.0e-5); } public void testSubtractNaN() { Complex x = new Complex(3.0, 4.0); Complex z = x.subtract(Complex.NaN); assertTrue(z.isNaN()); } public void testEqualsNull() { Complex x = new Complex(3.0, 4.0); assertFalse(x.equals(null)); } public void testEqualsClass() { Complex x = new Complex(3.0, 4.0); assertFalse(x.equals(this)); } public void testEqualsSame() { Complex x = new Complex(3.0, 4.0); assertTrue(x.equals(x)); } public void testEqualsTrue() { Complex x = new Complex(3.0, 4.0); Complex y = new Complex(3.0, 4.0); assertTrue(x.equals(y)); } public void testEqualsRealDifference() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0); assertFalse(x.equals(y)); } public void testEqualsImaginaryDifference() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE); assertFalse(x.equals(y)); } public void testEqualsNaN() { Complex realNaN = new Complex(Double.NaN, 0.0); Complex imaginaryNaN = new Complex(0.0, Double.NaN); Complex complexNaN = Complex.NaN; assertTrue(realNaN.equals(imaginaryNaN)); assertTrue(imaginaryNaN.equals(complexNaN)); assertTrue(realNaN.equals(complexNaN)); } public void testHashCode() { Complex x = new Complex(0.0, 0.0); Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE); assertFalse(x.hashCode()==y.hashCode()); y = new Complex(0.0 + Double.MIN_VALUE, 0.0); assertFalse(x.hashCode()==y.hashCode()); Complex realNaN = new Complex(Double.NaN, 0.0); Complex imaginaryNaN = new Complex(0.0, Double.NaN); assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode()); assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode()); } public void testAcos() { Complex z = new Complex(3, 4); Complex expected = new Complex(0.936812, -2.30551); TestUtils.assertEquals(expected, z.acos(), 1.0e-5); TestUtils.assertEquals(new Complex(Math.acos(0), 0), Complex.ZERO.acos(), 1.0e-12); } public void testAcosInf() { TestUtils.assertSame(Complex.NaN, oneInf.acos()); TestUtils.assertSame(Complex.NaN, oneNegInf.acos()); TestUtils.assertSame(Complex.NaN, infOne.acos()); TestUtils.assertSame(Complex.NaN, negInfOne.acos()); TestUtils.assertSame(Complex.NaN, infInf.acos()); TestUtils.assertSame(Complex.NaN, infNegInf.acos()); TestUtils.assertSame(Complex.NaN, negInfInf.acos()); TestUtils.assertSame(Complex.NaN, negInfNegInf.acos()); } public void testAcosNaN() { assertTrue(Complex.NaN.acos().isNaN()); } public void testAsin() { Complex z = new Complex(3, 4); Complex expected = new Complex(0.633984, 2.30551); TestUtils.assertEquals(expected, z.asin(), 1.0e-5); } public void testAsinNaN() { assertTrue(Complex.NaN.asin().isNaN()); } public void testAsinInf() { TestUtils.assertSame(Complex.NaN, oneInf.asin()); TestUtils.assertSame(Complex.NaN, oneNegInf.asin()); TestUtils.assertSame(Complex.NaN, infOne.asin()); TestUtils.assertSame(Complex.NaN, negInfOne.asin()); TestUtils.assertSame(Complex.NaN, infInf.asin()); TestUtils.assertSame(Complex.NaN, infNegInf.asin()); TestUtils.assertSame(Complex.NaN, negInfInf.asin()); TestUtils.assertSame(Complex.NaN, negInfNegInf.asin()); } public void testAtan() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.44831, 0.158997); TestUtils.assertEquals(expected, z.atan(), 1.0e-5); } public void testAtanInf() { TestUtils.assertSame(Complex.NaN, oneInf.atan()); TestUtils.assertSame(Complex.NaN, oneNegInf.atan()); TestUtils.assertSame(Complex.NaN, infOne.atan()); TestUtils.assertSame(Complex.NaN, negInfOne.atan()); TestUtils.assertSame(Complex.NaN, infInf.atan()); TestUtils.assertSame(Complex.NaN, infNegInf.atan()); TestUtils.assertSame(Complex.NaN, negInfInf.atan()); TestUtils.assertSame(Complex.NaN, negInfNegInf.atan()); } public void testAtanNaN() { assertTrue(Complex.NaN.atan().isNaN()); assertTrue(Complex.I.atan().isNaN()); } public void testCos() { Complex z = new Complex(3, 4); Complex expected = new Complex(-27.03495, -3.851153); TestUtils.assertEquals(expected, z.cos(), 1.0e-5); } public void testCosNaN() { assertTrue(Complex.NaN.cos().isNaN()); } public void testCosInf() { TestUtils.assertSame(infNegInf, oneInf.cos()); TestUtils.assertSame(infInf, oneNegInf.cos()); TestUtils.assertSame(Complex.NaN, infOne.cos()); TestUtils.assertSame(Complex.NaN, negInfOne.cos()); TestUtils.assertSame(Complex.NaN, infInf.cos()); TestUtils.assertSame(Complex.NaN, infNegInf.cos()); TestUtils.assertSame(Complex.NaN, negInfInf.cos()); TestUtils.assertSame(Complex.NaN, negInfNegInf.cos()); } public void testCosh() { Complex z = new Complex(3, 4); Complex expected = new Complex(-6.58066, -7.58155); TestUtils.assertEquals(expected, z.cosh(), 1.0e-5); } public void testCoshNaN() { assertTrue(Complex.NaN.cosh().isNaN()); } public void testCoshInf() { TestUtils.assertSame(Complex.NaN, oneInf.cosh()); TestUtils.assertSame(Complex.NaN, oneNegInf.cosh()); TestUtils.assertSame(infInf, infOne.cosh()); TestUtils.assertSame(infNegInf, negInfOne.cosh()); TestUtils.assertSame(Complex.NaN, infInf.cosh()); TestUtils.assertSame(Complex.NaN, infNegInf.cosh()); TestUtils.assertSame(Complex.NaN, negInfInf.cosh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh()); } public void testExp() { Complex z = new Complex(3, 4); Complex expected = new Complex(-13.12878, -15.20078); TestUtils.assertEquals(expected, z.exp(), 1.0e-5); TestUtils.assertEquals(Complex.ONE, Complex.ZERO.exp(), 10e-12); Complex iPi = Complex.I.multiply(new Complex(pi,0)); TestUtils.assertEquals(Complex.ONE.negate(), iPi.exp(), 10e-12); } public void testExpNaN() { assertTrue(Complex.NaN.exp().isNaN()); } public void testExpInf() { TestUtils.assertSame(Complex.NaN, oneInf.exp()); TestUtils.assertSame(Complex.NaN, oneNegInf.exp()); TestUtils.assertSame(infInf, infOne.exp()); TestUtils.assertSame(Complex.ZERO, negInfOne.exp()); TestUtils.assertSame(Complex.NaN, infInf.exp()); TestUtils.assertSame(Complex.NaN, infNegInf.exp()); TestUtils.assertSame(Complex.NaN, negInfInf.exp()); TestUtils.assertSame(Complex.NaN, negInfNegInf.exp()); } public void testLog() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.60944, 0.927295); TestUtils.assertEquals(expected, z.log(), 1.0e-5); } public void testLogNaN() { assertTrue(Complex.NaN.log().isNaN()); } public void testLogInf() { TestUtils.assertEquals(new Complex(inf, pi / 2), oneInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, -pi / 2), oneNegInf.log(), 10e-12); TestUtils.assertEquals(infZero, infOne.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, pi), negInfOne.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, pi / 4), infInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, -pi / 4), infNegInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, 3d * pi / 4), negInfInf.log(), 10e-12); TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4), negInfNegInf.log(), 10e-12); } public void testLogZero() { TestUtils.assertSame(negInfZero, Complex.ZERO.log()); } public void testPow() { Complex x = new Complex(3, 4); Complex y = new Complex(5, 6); Complex expected = new Complex(-1.860893, 11.83677); TestUtils.assertEquals(expected, x.pow(y), 1.0e-5); } public void testPowNaNBase() { Complex x = new Complex(3, 4); assertTrue(Complex.NaN.pow(x).isNaN()); } public void testPowNaNExponent() { Complex x = new Complex(3, 4); assertTrue(x.pow(Complex.NaN).isNaN()); } public void testPowInf() { TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infOne)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfInf)); TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infOne.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfOne.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,infInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,negInfNegInf.pow(infInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infInf.pow(infInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf)); TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf)); } public void testPowZero() { TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.ONE)); TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.ZERO)); TestUtils.assertSame(Complex.NaN, Complex.ZERO.pow(Complex.I)); TestUtils.assertEquals(Complex.ONE, Complex.ONE.pow(Complex.ZERO), 10e-12); TestUtils.assertEquals(Complex.ONE, Complex.I.pow(Complex.ZERO), 10e-12); TestUtils.assertEquals(Complex.ONE, new Complex(-1, 3).pow(Complex.ZERO), 10e-12); } public void testpowNull() { try { Complex.ONE.pow(null); fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // expected } } public void testSin() { Complex z = new Complex(3, 4); Complex expected = new Complex(3.853738, -27.01681); TestUtils.assertEquals(expected, z.sin(), 1.0e-5); } public void testSinInf() { TestUtils.assertSame(infInf, oneInf.sin()); TestUtils.assertSame(infNegInf, oneNegInf.sin()); TestUtils.assertSame(Complex.NaN, infOne.sin()); TestUtils.assertSame(Complex.NaN, negInfOne.sin()); TestUtils.assertSame(Complex.NaN, infInf.sin()); TestUtils.assertSame(Complex.NaN, infNegInf.sin()); TestUtils.assertSame(Complex.NaN, negInfInf.sin()); TestUtils.assertSame(Complex.NaN, negInfNegInf.sin()); } public void testSinNaN() { assertTrue(Complex.NaN.sin().isNaN()); } public void testSinh() { Complex z = new Complex(3, 4); Complex expected = new Complex(-6.54812, -7.61923); TestUtils.assertEquals(expected, z.sinh(), 1.0e-5); } public void testSinhNaN() { assertTrue(Complex.NaN.sinh().isNaN()); } public void testSinhInf() { TestUtils.assertSame(Complex.NaN, oneInf.sinh()); TestUtils.assertSame(Complex.NaN, oneNegInf.sinh()); TestUtils.assertSame(infInf, infOne.sinh()); TestUtils.assertSame(negInfInf, negInfOne.sinh()); TestUtils.assertSame(Complex.NaN, infInf.sinh()); TestUtils.assertSame(Complex.NaN, infNegInf.sinh()); TestUtils.assertSame(Complex.NaN, negInfInf.sinh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh()); } public void testSqrtRealPositive() { Complex z = new Complex(3, 4); Complex expected = new Complex(2, 1); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } public void testSqrtRealZero() { Complex z = new Complex(0.0, 4); Complex expected = new Complex(1.41421, 1.41421); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } public void testSqrtRealNegative() { Complex z = new Complex(-3.0, 4); Complex expected = new Complex(1, 2); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } public void testSqrtImaginaryZero() { Complex z = new Complex(-3.0, 0.0); Complex expected = new Complex(0.0, 1.73205); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } public void testSqrtImaginaryNegative() { Complex z = new Complex(-3.0, -4.0); Complex expected = new Complex(1.0, -2.0); TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5); } public void testSqrtPolar() { double r = 1; for (int i = 0; i < 5; i++) { r += i; double theta = 0; for (int j =0; j < 11; j++) { theta += pi /12; Complex z = ComplexUtils.polar2Complex(r, theta); Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2); TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12); } } } public void testSqrtNaN() { assertTrue(Complex.NaN.sqrt().isNaN()); } public void testSqrtInf() { TestUtils.assertSame(infNaN, oneInf.sqrt()); TestUtils.assertSame(infNaN, oneNegInf.sqrt()); TestUtils.assertSame(infZero, infOne.sqrt()); TestUtils.assertSame(zeroInf, negInfOne.sqrt()); TestUtils.assertSame(infNaN, infInf.sqrt()); TestUtils.assertSame(infNaN, infNegInf.sqrt()); TestUtils.assertSame(nanInf, negInfInf.sqrt()); TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt()); } public void testSqrt1z() { Complex z = new Complex(3, 4); Complex expected = new Complex(4.08033, -2.94094); TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5); } public void testSqrt1zNaN() { assertTrue(Complex.NaN.sqrt1z().isNaN()); } public void testTan() { Complex z = new Complex(3, 4); Complex expected = new Complex(-0.000187346, 0.999356); TestUtils.assertEquals(expected, z.tan(), 1.0e-5); } public void testTanNaN() { assertTrue(Complex.NaN.tan().isNaN()); } public void testTanInf() { TestUtils.assertSame(zeroNaN, oneInf.tan()); TestUtils.assertSame(zeroNaN, oneNegInf.tan()); TestUtils.assertSame(Complex.NaN, infOne.tan()); TestUtils.assertSame(Complex.NaN, negInfOne.tan()); TestUtils.assertSame(Complex.NaN, infInf.tan()); TestUtils.assertSame(Complex.NaN, infNegInf.tan()); TestUtils.assertSame(Complex.NaN, negInfInf.tan()); TestUtils.assertSame(Complex.NaN, negInfNegInf.tan()); } public void testTanCritical() { TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan()); TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan()); } public void testTanh() { Complex z = new Complex(3, 4); Complex expected = new Complex(1.00071, 0.00490826); TestUtils.assertEquals(expected, z.tanh(), 1.0e-5); } public void testTanhNaN() { assertTrue(Complex.NaN.tanh().isNaN()); } public void testTanhInf() { TestUtils.assertSame(Complex.NaN, oneInf.tanh()); TestUtils.assertSame(Complex.NaN, oneNegInf.tanh()); TestUtils.assertSame(nanZero, infOne.tanh()); TestUtils.assertSame(nanZero, negInfOne.tanh()); TestUtils.assertSame(Complex.NaN, infInf.tanh()); TestUtils.assertSame(Complex.NaN, infNegInf.tanh()); TestUtils.assertSame(Complex.NaN, negInfInf.tanh()); TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh()); } public void testTanhCritical() { TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh()); } /** test issue MATH-221 */ public void testMath221() { assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0))); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.complex; import org.apache.commons.math.TestUtils; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class ComplexUtilsTest extends TestCase { private double inf = Double.POSITIVE_INFINITY; private double negInf = Double.NEGATIVE_INFINITY; private double nan = Double.NaN; private double pi = Math.PI; private Complex negInfInf = new Complex(negInf, inf); private Complex infNegInf = new Complex(inf, negInf); private Complex infInf = new Complex(inf, inf); private Complex negInfNegInf = new Complex(negInf, negInf); private Complex infNaN = new Complex(inf, nan); public void testPolar2Complex() { TestUtils.assertEquals(Complex.ONE, ComplexUtils.polar2Complex(1, 0), 10e-12); TestUtils.assertEquals(Complex.ZERO, ComplexUtils.polar2Complex(0, 1), 10e-12); TestUtils.assertEquals(Complex.ZERO, ComplexUtils.polar2Complex(0, -1), 10e-12); TestUtils.assertEquals(Complex.I, ComplexUtils.polar2Complex(1, pi/2), 10e-12); TestUtils.assertEquals(Complex.I.negate(), ComplexUtils.polar2Complex(1, -pi/2), 10e-12); double r = 0; for (int i = 0; i < 5; i++) { r += i; double theta = 0; for (int j =0; j < 20; j++) { theta += pi / 6; TestUtils.assertEquals(altPolar(r, theta), ComplexUtils.polar2Complex(r, theta), 10e-12); } theta = -2 * pi; for (int j =0; j < 20; j++) { theta -= pi / 6; TestUtils.assertEquals(altPolar(r, theta), ComplexUtils.polar2Complex(r, theta), 10e-12); } } } protected Complex altPolar(double r, double theta) { return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0)); } public void testPolar2ComplexIllegalModulus() { try { ComplexUtils.polar2Complex(-1, 0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } public void testPolar2ComplexNaN() { TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, nan)); } public void testPolar2ComplexInf() { TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, negInf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, inf)); TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(inf, negInf)); TestUtils.assertSame(infInf, ComplexUtils.polar2Complex(inf, pi/4)); TestUtils.assertSame(infNaN, ComplexUtils.polar2Complex(inf, 0)); TestUtils.assertSame(infNegInf, ComplexUtils.polar2Complex(inf, -pi/4)); TestUtils.assertSame(negInfInf, ComplexUtils.polar2Complex(inf, 3*pi/4)); TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4)); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.complex; import java.text.NumberFormat; import java.text.ParseException; import java.text.ParsePosition; import java.util.Locale; import org.apache.commons.math.util.CompositeFormat; import junit.framework.TestCase; public abstract class ComplexFormatAbstractTest extends TestCase { CompositeFormat complexFormat = null; ComplexFormat complexFormatJ = null; protected abstract Locale getLocale(); protected abstract char getDecimalCharacter(); protected void setUp() throws Exception { complexFormat = ComplexFormat.getInstance(getLocale()); complexFormatJ = ComplexFormat.getInstance(getLocale()); complexFormatJ.setImaginaryCharacter("j"); } public void testSimpleNoDecimals() { Complex c = new Complex(1, 1); String expected = "1 + 1i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testSimpleWithDecimals() { Complex c = new Complex(1.23, 1.43); String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testSimpleWithDecimalsTrunc() { Complex c = new Complex(1.2323, 1.4343); String expected = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testNegativeReal() { Complex c = new Complex(-1.2323, 1.4343); String expected = "-1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testNegativeImaginary() { Complex c = new Complex(1.2323, -1.4343); String expected = "1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testNegativeBoth() { Complex c = new Complex(-1.2323, -1.4343); String expected = "-1" + getDecimalCharacter() + "23 - 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testZeroReal() { Complex c = new Complex(0.0, -1.4343); String expected = "0 - 1" + getDecimalCharacter() + "43i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testZeroImaginary() { Complex c = new Complex(30.233, 0); String expected = "30" + getDecimalCharacter() + "23"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testDifferentImaginaryChar() { Complex c = new Complex(1, 1); String expected = "1 + 1j"; String actual = complexFormatJ.format(c); assertEquals(expected, actual); } public void testStaticFormatComplex() { Locale defaultLocal = Locale.getDefault(); Locale.setDefault(getLocale()); Complex c = new Complex(232.222, -342.33); String expected = "232" + getDecimalCharacter() + "22 - 342" + getDecimalCharacter() + "33i"; String actual = ComplexFormat.formatComplex(c); assertEquals(expected, actual); Locale.setDefault(defaultLocal); } public void testNan() { Complex c = new Complex(Double.NaN, Double.NaN); String expected = "(NaN) + (NaN)i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testPositiveInfinity() { Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); String expected = "(Infinity) + (Infinity)i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testNegativeInfinity() { Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY); String expected = "(-Infinity) - (Infinity)i"; String actual = complexFormat.format(c); assertEquals(expected, actual); } public void testParseSimpleNoDecimals() { String source = "1 + 1i"; Complex expected = new Complex(1, 1); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseSimpleWithDecimals() { String source = "1" + getDecimalCharacter() + "23 + 1" + getDecimalCharacter() + "43i"; Complex expected = new Complex(1.23, 1.43); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseSimpleWithDecimalsTrunc() { String source = "1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(1.2323, 1.4343); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeReal() { String source = "-1" + getDecimalCharacter() + "2323 + 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(-1.2323, 1.4343); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeImaginary() { String source = "1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(1.2323, -1.4343); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeBoth() { String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(-1.2323, -1.4343); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseZeroReal() { String source = "0" + getDecimalCharacter() + "0 - 1" + getDecimalCharacter() + "4343i"; Complex expected = new Complex(0.0, -1.4343); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseZeroImaginary() { String source = "-1" + getDecimalCharacter() + "2323"; Complex expected = new Complex(-1.2323, 0); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseDifferentImaginaryChar() { String source = "-1" + getDecimalCharacter() + "2323 - 1" + getDecimalCharacter() + "4343j"; Complex expected = new Complex(-1.2323, -1.4343); try { Complex actual = (Complex)complexFormatJ.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNan() { String source = "(NaN) + (NaN)i"; Complex expected = new Complex(Double.NaN, Double.NaN); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParsePositiveInfinity() { String source = "(Infinity) + (Infinity)i"; Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testPaseNegativeInfinity() { String source = "(-Infinity) - (Infinity)i"; Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY); try { Complex actual = (Complex)complexFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testConstructorSingleFormat() { NumberFormat nf = NumberFormat.getInstance(); ComplexFormat cf = new ComplexFormat(nf); assertNotNull(cf); assertEquals(nf, cf.getRealFormat()); } public void testGetImaginaryFormat() { NumberFormat nf = NumberFormat.getInstance(); ComplexFormat cf = new ComplexFormat(); assertNotSame(nf, cf.getImaginaryFormat()); cf.setImaginaryFormat(nf); assertSame(nf, cf.getImaginaryFormat()); } public void testSetImaginaryFormatNull() { try { ComplexFormat cf = new ComplexFormat(); cf.setImaginaryFormat(null); fail(); } catch (IllegalArgumentException ex) { // success } } public void testSetRealFormatNull() { try { ComplexFormat cf = new ComplexFormat(); cf.setRealFormat(null); fail(); } catch (IllegalArgumentException ex) { // success } } public void testGetRealFormat() { NumberFormat nf = NumberFormat.getInstance(); ComplexFormat cf = new ComplexFormat(); assertNotSame(nf, cf.getRealFormat()); cf.setRealFormat(nf); assertSame(nf, cf.getRealFormat()); } public void testSetImaginaryCharacterNull() { try { ComplexFormat cf = new ComplexFormat(); cf.setImaginaryCharacter(null); fail(); } catch (IllegalArgumentException ex) { // success } } public void testSetImaginaryCharacterEmpty() { try { ComplexFormat cf = new ComplexFormat(); cf.setImaginaryCharacter(""); fail(); } catch (IllegalArgumentException ex) { // success } } public void testFormatNumber() { CompositeFormat cf = ComplexFormat.getInstance(getLocale()); Double pi = Double.valueOf(Math.PI); String text = cf.format(pi); assertEquals("3" + getDecimalCharacter() + "14", text); } public void testFormatObject() { try { CompositeFormat cf = new ComplexFormat(); Object object = new Object(); cf.format(object); fail(); } catch (IllegalArgumentException ex) { // success } } public void testForgottenImaginaryCharacter() { ParsePosition pos = new ParsePosition(0); assertNull(new ComplexFormat().parse("1 + 1", pos)); assertEquals(5, pos.getErrorIndex()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.complex; import java.util.Locale; public class ComplexFormatTest extends ComplexFormatAbstractTest { protected char getDecimalCharacter() { return '.'; } protected Locale getLocale() { return Locale.US; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.complex; import java.util.Locale; public class FrenchComplexFormatTest extends ComplexFormatAbstractTest { protected char getDecimalCharacter() { return ','; } protected Locale getLocale() { return Locale.FRENCH; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.geometry; import org.apache.commons.math.geometry.CardanEulerSingularityException; import org.apache.commons.math.geometry.NotARotationMatrixException; import org.apache.commons.math.geometry.Rotation; import org.apache.commons.math.geometry.RotationOrder; import org.apache.commons.math.geometry.Vector3D; import org.apache.commons.math.util.MathUtils; import junit.framework.*; public class RotationTest extends TestCase { public RotationTest(String name) { super(name); } public void testIdentity() { Rotation r = Rotation.IDENTITY; checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); checkAngle(r.getAngle(), 0); r = new Rotation(-1, 0, 0, 0, false); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); checkAngle(r.getAngle(), 0); r = new Rotation(42, 0, 0, 0, true); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K); checkAngle(r.getAngle(), 0); } public void testAxisAngle() { Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I); double s = 1 / Math.sqrt(3); checkVector(r.getAxis(), new Vector3D(s, s, s)); checkAngle(r.getAngle(), 2 * Math.PI / 3); try { new Rotation(new Vector3D(0, 0, 0), 2 * Math.PI / 3); fail("an exception should have been thrown"); } catch (ArithmeticException e) { } catch (Exception e) { fail("unexpected exception"); } r = new Rotation(Vector3D.PLUS_K, 1.5 * Math.PI); checkVector(r.getAxis(), new Vector3D(0, 0, -1)); checkAngle(r.getAngle(), 0.5 * Math.PI); r = new Rotation(Vector3D.PLUS_J, Math.PI); checkVector(r.getAxis(), Vector3D.PLUS_J); checkAngle(r.getAngle(), Math.PI); checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I); } public void testRevert() { Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true); Rotation reverted = r.revert(); checkRotation(r.applyTo(reverted), 1, 0, 0, 0); checkRotation(reverted.applyTo(r), 1, 0, 0, 0); assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12); assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12); } public void testVectorOnePair() { Vector3D u = new Vector3D(3, 2, 1); Vector3D v = new Vector3D(-4, 2, 2); Rotation r = new Rotation(u, v); checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm())); checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI); try { new Rotation(u, Vector3D.ZERO); fail("an exception should have been thrown"); } catch (IllegalArgumentException e) { // expected behavior } catch (Exception e) { fail("unexpected exception"); } } public void testVectorTwoPairs() { Vector3D u1 = new Vector3D(3, 0, 0); Vector3D u2 = new Vector3D(0, 5, 0); Vector3D v1 = new Vector3D(0, 0, 2); Vector3D v2 = new Vector3D(-2, 0, 2); Rotation r = new Rotation(u1, u2, v1, v2); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I); r = new Rotation(u1, u2, u1.negate(), u2.negate()); Vector3D axis = r.getAxis(); if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) { checkVector(axis, Vector3D.PLUS_K); } else { checkVector(axis, Vector3D.MINUS_K); } checkAngle(r.getAngle(), Math.PI); double sqrt = Math.sqrt(2) / 2; r = new Rotation(Vector3D.PLUS_I, Vector3D.PLUS_J, new Vector3D(0.5, 0.5, sqrt), new Vector3D(0.5, 0.5, -sqrt)); checkRotation(r, sqrt, 0.5, 0.5, 0); r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2)); checkRotation(r, sqrt, -sqrt, 0, 0); checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0); try { new Rotation(u1, u2, Vector3D.ZERO, v2); fail("an exception should have been thrown"); } catch (IllegalArgumentException e) { // expected behavior } catch (Exception e) { fail("unexpected exception"); } } public void testMatrix() throws NotARotationMatrixException { try { new Rotation(new double[][] { { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }, 1.0e-7); } catch (NotARotationMatrixException nrme) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } try { new Rotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { 0.821760, -0.184320, 0.539200 }, { -0.354816, 0.574912, 0.737280 } }, 1.0e-7); } catch (NotARotationMatrixException nrme) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } try { new Rotation(new double[][] { { 0.4, 0.8, -0.4 }, { -0.4, 0.6, 0.7 }, { 0.8, -0.2, 0.5 } }, 1.0e-15); } catch (NotARotationMatrixException nrme) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } checkRotation(new Rotation(new double[][] { { 0.445888, 0.797184, -0.407040 }, { -0.354816, 0.574912, 0.737280 }, { 0.821760, -0.184320, 0.539200 } }, 1.0e-10), 0.8, 0.288, 0.384, 0.36); checkRotation(new Rotation(new double[][] { { 0.539200, 0.737280, 0.407040 }, { 0.184320, -0.574912, 0.797184 }, { 0.821760, -0.354816, -0.445888 } }, 1.0e-10), 0.36, 0.8, 0.288, 0.384); checkRotation(new Rotation(new double[][] { { -0.445888, 0.797184, -0.407040 }, { 0.354816, 0.574912, 0.737280 }, { 0.821760, 0.184320, -0.539200 } }, 1.0e-10), 0.384, 0.36, 0.8, 0.288); checkRotation(new Rotation(new double[][] { { -0.539200, 0.737280, 0.407040 }, { -0.184320, -0.574912, 0.797184 }, { 0.821760, 0.354816, 0.445888 } }, 1.0e-10), 0.288, 0.384, 0.36, 0.8); double[][] m1 = { { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0 } }; Rotation r = new Rotation(m1, 1.0e-7); checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K); checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I); checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J); double[][] m2 = { { 0.83203, -0.55012, -0.07139 }, { 0.48293, 0.78164, -0.39474 }, { 0.27296, 0.29396, 0.91602 } }; r = new Rotation(m2, 1.0e-12); double[][] m3 = r.getMatrix(); double d00 = m2[0][0] - m3[0][0]; double d01 = m2[0][1] - m3[0][1]; double d02 = m2[0][2] - m3[0][2]; double d10 = m2[1][0] - m3[1][0]; double d11 = m2[1][1] - m3[1][1]; double d12 = m2[1][2] - m3[1][2]; double d20 = m2[2][0] - m3[2][0]; double d21 = m2[2][1] - m3[2][1]; double d22 = m2[2][2] - m3[2][2]; assertTrue(Math.abs(d00) < 6.0e-6); assertTrue(Math.abs(d01) < 6.0e-6); assertTrue(Math.abs(d02) < 6.0e-6); assertTrue(Math.abs(d10) < 6.0e-6); assertTrue(Math.abs(d11) < 6.0e-6); assertTrue(Math.abs(d12) < 6.0e-6); assertTrue(Math.abs(d20) < 6.0e-6); assertTrue(Math.abs(d21) < 6.0e-6); assertTrue(Math.abs(d22) < 6.0e-6); assertTrue(Math.abs(d00) > 4.0e-7); assertTrue(Math.abs(d01) > 4.0e-7); assertTrue(Math.abs(d02) > 4.0e-7); assertTrue(Math.abs(d10) > 4.0e-7); assertTrue(Math.abs(d11) > 4.0e-7); assertTrue(Math.abs(d12) > 4.0e-7); assertTrue(Math.abs(d20) > 4.0e-7); assertTrue(Math.abs(d21) > 4.0e-7); assertTrue(Math.abs(d22) > 4.0e-7); for (int i = 0; i < 3; ++i) { for (int j = 0; j < 3; ++j) { double m3tm3 = m3[i][0] * m3[j][0] + m3[i][1] * m3[j][1] + m3[i][2] * m3[j][2]; if (i == j) { assertTrue(Math.abs(m3tm3 - 1.0) < 1.0e-10); } else { assertTrue(Math.abs(m3tm3) < 1.0e-10); } } } checkVector(r.applyTo(Vector3D.PLUS_I), new Vector3D(m3[0][0], m3[1][0], m3[2][0])); checkVector(r.applyTo(Vector3D.PLUS_J), new Vector3D(m3[0][1], m3[1][1], m3[2][1])); checkVector(r.applyTo(Vector3D.PLUS_K), new Vector3D(m3[0][2], m3[1][2], m3[2][2])); double[][] m4 = { { 1.0, 0.0, 0.0 }, { 0.0, -1.0, 0.0 }, { 0.0, 0.0, -1.0 } }; r = new Rotation(m4, 1.0e-7); checkAngle(r.getAngle(), Math.PI); try { double[][] m5 = { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }; r = new Rotation(m5, 1.0e-7); fail("got " + r + ", should have caught an exception"); } catch (NotARotationMatrixException e) { // expected } catch (Exception e) { fail("wrong exception caught"); } } public void testAngles() throws CardanEulerSingularityException { RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; for (int i = 0; i < CardanOrders.length; ++i) { for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) { for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3); double[] angles = r.getAngles(CardanOrders[i]); checkAngle(angles[0], alpha1); checkAngle(angles[1], alpha2); checkAngle(angles[2], alpha3); } } } } RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; for (int i = 0; i < EulerOrders.length; ++i) { for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) { for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) { for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) { Rotation r = new Rotation(EulerOrders[i], alpha1, alpha2, alpha3); double[] angles = r.getAngles(EulerOrders[i]); checkAngle(angles[0], alpha1); checkAngle(angles[1], alpha2); checkAngle(angles[2], alpha3); } } } } } public void testSingularities() throws CardanEulerSingularityException { RotationOrder[] CardanOrders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX }; double[] singularCardanAngle = { Math.PI / 2, -Math.PI / 2 }; for (int i = 0; i < CardanOrders.length; ++i) { for (int j = 0; j < singularCardanAngle.length; ++j) { Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3); try { r.getAngles(CardanOrders[i]); fail("an exception should have been caught"); } catch (CardanEulerSingularityException cese) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } } RotationOrder[] EulerOrders = { RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; double[] singularEulerAngle = { 0, Math.PI }; for (int i = 0; i < EulerOrders.length; ++i) { for (int j = 0; j < singularEulerAngle.length; ++j) { Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3); try { r.getAngles(EulerOrders[i]); fail("an exception should have been caught"); } catch (CardanEulerSingularityException cese) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } } } public void testQuaternion() { Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); double n = 23.5; Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(), n * r1.getQ2(), n * r1.getQ3(), true); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { Vector3D u = new Vector3D(x, y, z); checkVector(r2.applyTo(u), r1.applyTo(u)); } } } r1 = new Rotation( 0.288, 0.384, 0.36, 0.8, false); checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3()); } public void testCompose() { Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3); Rotation r3 = r2.applyTo(r1); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { Vector3D u = new Vector3D(x, y, z); checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u)); } } } } public void testComposeInverse() { Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7); Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3); Rotation r3 = r2.applyInverseTo(r1); for (double x = -0.9; x < 0.9; x += 0.2) { for (double y = -0.9; y < 0.9; y += 0.2) { for (double z = -0.9; z < 0.9; z += 0.2) { Vector3D u = new Vector3D(x, y, z); checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u)); } } } } public void testApplyInverseTo() { Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi), Math.sin(lambda) * Math.cos(phi), Math.sin(phi)); r.applyInverseTo(r.applyTo(u)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } r = Rotation.IDENTITY; for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi), Math.sin(lambda) * Math.cos(phi), Math.sin(phi)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } r = new Rotation(Vector3D.PLUS_K, Math.PI); for (double lambda = 0; lambda < 6.2; lambda += 0.2) { for (double phi = -1.55; phi < 1.55; phi += 0.2) { Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi), Math.sin(lambda) * Math.cos(phi), Math.sin(phi)); checkVector(u, r.applyInverseTo(r.applyTo(u))); checkVector(u, r.applyTo(r.applyInverseTo(u))); } } } private void checkVector(Vector3D v1, Vector3D v2) { assertTrue(v1.subtract(v2).getNorm() < 1.0e-10); } private void checkAngle(double a1, double a2) { assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10); } private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) { assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12); } public static Test suite() { return new TestSuite(RotationTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.geometry; import org.apache.commons.math.geometry.Vector3D; import junit.framework.*; public class Vector3DTest extends TestCase { public Vector3DTest(String name) { super(name); } public void testConstructors() { double r = Math.sqrt(2) /2; checkVector(new Vector3D(2, new Vector3D(Math.PI / 3, -Math.PI / 4)), r, r * Math.sqrt(3), -2 * r); checkVector(new Vector3D(2, Vector3D.PLUS_I, -3, Vector3D.MINUS_K), 2, 0, 3); checkVector(new Vector3D(2, Vector3D.PLUS_I, 5, Vector3D.PLUS_J, -3, Vector3D.MINUS_K), 2, 5, 3); checkVector(new Vector3D(2, Vector3D.PLUS_I, 5, Vector3D.PLUS_J, 5, Vector3D.MINUS_J, -3, Vector3D.MINUS_K), 2, 0, 3); } public void testCoordinates() { Vector3D v = new Vector3D(1, 2, 3); assertTrue(Math.abs(v.getX() - 1) < 1.0e-12); assertTrue(Math.abs(v.getY() - 2) < 1.0e-12); assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12); } public void testNorm() { assertTrue(Math.abs(Vector3D.ZERO.getNorm()) < 1.0e-12); assertTrue(Math.abs(new Vector3D(1, 2, 3).getNorm() - Math.sqrt(14)) < 1.0e-12); } public void testSubtract() { Vector3D v1 = new Vector3D(1, 2, 3); Vector3D v2 = new Vector3D(-3, -2, -1); v1 = v1.subtract(v2); checkVector(v1, 4, 4, 4); checkVector(v2.subtract(v1), -7, -6, -5); checkVector(v2.subtract(3, v1), -15, -14, -13); } public void testAdd() { Vector3D v1 = new Vector3D(1, 2, 3); Vector3D v2 = new Vector3D(-3, -2, -1); v1 = v1.add(v2); checkVector(v1, -2, 0, 2); checkVector(v2.add(v1), -5, -2, 1); checkVector(v2.add(3, v1), -9, -2, 5); } public void testScalarProduct() { Vector3D v = new Vector3D(1, 2, 3); v = v.scalarMultiply(3); checkVector(v, 3, 6, 9); checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5); } public void testVectorialProducts() { Vector3D v1 = new Vector3D(2, 1, -4); Vector3D v2 = new Vector3D(3, 1, -1); assertTrue(Math.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12); Vector3D v3 = Vector3D.crossProduct(v1, v2); checkVector(v3, 3, -10, -1); assertTrue(Math.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12); assertTrue(Math.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12); } public void testAngular() { assertEquals(0, Vector3D.PLUS_I.getAlpha(), 1.0e-10); assertEquals(0, Vector3D.PLUS_I.getDelta(), 1.0e-10); assertEquals(Math.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10); assertEquals(0, Vector3D.PLUS_J.getDelta(), 1.0e-10); assertEquals(0, Vector3D.PLUS_K.getAlpha(), 1.0e-10); assertEquals(Math.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10); Vector3D u = new Vector3D(-1, 1, -1); assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10); assertEquals(-1.0 / Math.sqrt(3), Math.sin(u.getDelta()), 1.0e-10); } public void testAngularSeparation() { Vector3D v1 = new Vector3D(2, -1, 4); Vector3D k = v1.normalize(); Vector3D i = k.orthogonal(); Vector3D v2 = k.scalarMultiply(Math.cos(1.2)).add(i.scalarMultiply(Math.sin(1.2))); assertTrue(Math.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12); } public void testNormalize() { assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12); try { Vector3D.ZERO.normalize(); fail("an exception should have been thrown"); } catch (ArithmeticException ae) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } public void testOrthogonal() { Vector3D v1 = new Vector3D(0.1, 2.5, 1.3); assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12); Vector3D v2 = new Vector3D(2.3, -0.003, 7.6); assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12); Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2); assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12); try { new Vector3D(0, 0, 0).orthogonal(); fail("an exception should have been thrown"); } catch (ArithmeticException ae) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } public void testAngle() { assertEquals(0.22572612855273393616, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)), 1.0e-12); assertEquals(7.98595620686106654517199e-8, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)), 1.0e-12); assertEquals(3.14159257373023116985197793156, Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)), 1.0e-12); try { Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I); fail("an exception should have been thrown"); } catch (ArithmeticException ae) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } private void checkVector(Vector3D v, double x, double y, double z) { assertEquals(x, v.getX(), 1.0e-12); assertEquals(y, v.getY(), 1.0e-12); assertEquals(z, v.getZ(), 1.0e-12); } public static Test suite() { return new TestSuite(Vector3DTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.geometry; import java.lang.reflect.Field; import org.apache.commons.math.geometry.RotationOrder; import junit.framework.*; public class RotationOrderTest extends TestCase { public RotationOrderTest(String name) { super(name); } public void testName() { RotationOrder[] orders = { RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ, RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX, RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY, RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ }; for (int i = 0; i < orders.length; ++i) { assertEquals(getFieldName(orders[i]), orders[i].toString()); } } private String getFieldName(RotationOrder order) { try { Field[] fields = RotationOrder.class.getFields(); for (int i = 0; i < fields.length; ++i) { if (fields[i].get(null) == order) { return fields[i].getName(); } } } catch (IllegalAccessException iae) { // ignored } return "unknown"; } public static Test suite() { return new TestSuite(RotationOrderTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.geometry; import java.util.Locale; public class Vector3DFormatTest extends Vector3DFormatAbstractTest { protected char getDecimalCharacter() { return '.'; } protected Locale getLocale() { return Locale.US; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.geometry; import java.util.Locale; public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest { protected char getDecimalCharacter() { return ','; } protected Locale getLocale() { return Locale.FRENCH; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.geometry; import java.text.NumberFormat; import java.text.ParseException; import java.text.ParsePosition; import java.util.Locale; import junit.framework.TestCase; import org.apache.commons.math.util.CompositeFormat; public abstract class Vector3DFormatAbstractTest extends TestCase { Vector3DFormat vector3DFormat = null; Vector3DFormat vector3DFormatSquare = null; protected abstract Locale getLocale(); protected abstract char getDecimalCharacter(); protected void setUp() throws Exception { vector3DFormat = Vector3DFormat.getInstance(getLocale()); final NumberFormat nf = NumberFormat.getInstance(getLocale()); nf.setMaximumFractionDigits(2); vector3DFormatSquare = new Vector3DFormat("[", "]", " : ", nf); } public void testSimpleNoDecimals() { Vector3D c = new Vector3D(1, 1, 1); String expected = "{1; 1; 1}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void testSimpleWithDecimals() { Vector3D c = new Vector3D(1.23, 1.43, 1.63); String expected = "{1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void testSimpleWithDecimalsTrunc() { Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333); String expected = "{1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void testNegativeX() { Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333); String expected = "{-1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void testNegativeY() { Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333); String expected = "{1" + getDecimalCharacter() + "23; -1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void testNegativeZ() { Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333); String expected = "{1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; -1" + getDecimalCharacter() + "63}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void testNonDefaultSetting() { Vector3D c = new Vector3D(1, 1, 1); String expected = "[1 : 1 : 1]"; String actual = vector3DFormatSquare.format(c); assertEquals(expected, actual); } public void testStaticFormatVector3D() { Locale defaultLocal = Locale.getDefault(); Locale.setDefault(getLocale()); Vector3D c = new Vector3D(232.222, -342.33, 432.444); String expected = "{232" + getDecimalCharacter() + "22; -342" + getDecimalCharacter() + "33; 432" + getDecimalCharacter() + "44}"; String actual = Vector3DFormat.formatVector3D(c); assertEquals(expected, actual); Locale.setDefault(defaultLocal); } public void testNan() { Vector3D c = Vector3D.NaN; String expected = "{(NaN); (NaN); (NaN)}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void testPositiveInfinity() { Vector3D c = Vector3D.POSITIVE_INFINITY; String expected = "{(Infinity); (Infinity); (Infinity)}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void tesNegativeInfinity() { Vector3D c = Vector3D.NEGATIVE_INFINITY; String expected = "{(-Infinity); (-Infinity); (-Infinity)}"; String actual = vector3DFormat.format(c); assertEquals(expected, actual); } public void testParseSimpleNoDecimals() { String source = "{1; 1; 1}"; Vector3D expected = new Vector3D(1, 1, 1); try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseIgnoredWhitespace() { Vector3D expected = new Vector3D(1, 1, 1); ParsePosition pos1 = new ParsePosition(0); String source1 = "{1;1;1}"; assertEquals(expected, vector3DFormat.parseObject(source1, pos1)); assertEquals(source1.length(), pos1.getIndex()); ParsePosition pos2 = new ParsePosition(0); String source2 = " { 1 ; 1 ; 1 } "; assertEquals(expected, vector3DFormat.parseObject(source2, pos2)); assertEquals(source2.length() - 1, pos2.getIndex()); } public void testParseSimpleWithDecimals() { String source = "{1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; Vector3D expected = new Vector3D(1.23, 1.43, 1.63); try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseSimpleWithDecimalsTrunc() { String source = "{1" + getDecimalCharacter() + "2323; 1" + getDecimalCharacter() + "4343; 1" + getDecimalCharacter() + "6333}"; Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333); try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeX() { String source = "{-1" + getDecimalCharacter() + "2323; 1" + getDecimalCharacter() + "4343; 1" + getDecimalCharacter() + "6333}"; Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333); try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeY() { String source = "{1" + getDecimalCharacter() + "2323; -1" + getDecimalCharacter() + "4343; 1" + getDecimalCharacter() + "6333}"; Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333); try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeZ() { String source = "{1" + getDecimalCharacter() + "2323; 1" + getDecimalCharacter() + "4343; -1" + getDecimalCharacter() + "6333}"; Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333); try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeAll() { String source = "{-1" + getDecimalCharacter() + "2323; -1" + getDecimalCharacter() + "4343; -1" + getDecimalCharacter() + "6333}"; Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333); try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseZeroX() { String source = "{0" + getDecimalCharacter() + "0; -1" + getDecimalCharacter() + "4343; 1" + getDecimalCharacter() + "6333}"; Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333); try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNonDefaultSetting() { String source = "[1" + getDecimalCharacter() + "2323 : 1" + getDecimalCharacter() + "4343 : 1" + getDecimalCharacter() + "6333]"; Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333); try { Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNan() { String source = "{(NaN); (NaN); (NaN)}"; try { Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); assertEquals(Vector3D.NaN, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParsePositiveInfinity() { String source = "{(Infinity); (Infinity); (Infinity)}"; try { Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); assertEquals(Vector3D.POSITIVE_INFINITY, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeInfinity() { String source = "{(-Infinity); (-Infinity); (-Infinity)}"; try { Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); assertEquals(Vector3D.NEGATIVE_INFINITY, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testConstructorSingleFormat() { NumberFormat nf = NumberFormat.getInstance(); Vector3DFormat cf = new Vector3DFormat(nf); assertNotNull(cf); assertEquals(nf, cf.getFormat()); } public void testFormatObject() { try { CompositeFormat cf = new Vector3DFormat(); Object object = new Object(); cf.format(object); fail(); } catch (IllegalArgumentException ex) { // success } } public void testForgottenPrefix() { ParsePosition pos = new ParsePosition(0); assertNull(new Vector3DFormat().parse("1; 1; 1}", pos)); assertEquals(0, pos.getErrorIndex()); } public void testForgottenSeparator() { ParsePosition pos = new ParsePosition(0); assertNull(new Vector3DFormat().parse("{1; 1 1}", pos)); assertEquals(6, pos.getErrorIndex()); } public void testForgottenSuffix() { ParsePosition pos = new ParsePosition(0); assertNull(new Vector3DFormat().parse("{1; 1; 1 ", pos)); assertEquals(8, pos.getErrorIndex()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.optimization; import org.apache.commons.math.optimization.ConvergenceChecker; import org.apache.commons.math.optimization.CostException; import org.apache.commons.math.optimization.CostFunction; import org.apache.commons.math.optimization.NelderMead; import org.apache.commons.math.ConvergenceException; import org.apache.commons.math.optimization.PointCostPair; import org.apache.commons.math.random.JDKRandomGenerator; import org.apache.commons.math.random.NotPositiveDefiniteMatrixException; import org.apache.commons.math.random.RandomGenerator; import org.apache.commons.math.random.RandomVectorGenerator; import org.apache.commons.math.random.UncorrelatedRandomVectorGenerator; import org.apache.commons.math.random.UniformRandomGenerator; import junit.framework.*; public class NelderMeadTest extends TestCase { public NelderMeadTest(String name) { super(name); } public void testCostExceptions() throws ConvergenceException { CostFunction wrong = new CostFunction() { public double cost(double[] x) throws CostException { if (x[0] < 0) { throw new CostException("{0}", new Object[] { "oops"}); } else if (x[0] > 1) { throw new CostException(new RuntimeException("oops")); } else { return x[0] * (1 - x[0]); } } }; try { new NelderMead(0.9, 1.9, 0.4, 0.6).minimize(wrong, 10, new ValueChecker(1.0e-3), new double[] { -0.5 }, new double[] { 0.5 }); fail("an exception should have been thrown"); } catch (CostException ce) { // expected behavior assertNull(ce.getCause()); } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } try { new NelderMead(0.9, 1.9, 0.4, 0.6).minimize(wrong, 10, new ValueChecker(1.0e-3), new double[] { 0.5 }, new double[] { 1.5 }); fail("an exception should have been thrown"); } catch (CostException ce) { // expected behavior assertNotNull(ce.getCause()); } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } public void testRosenbrock() throws CostException, ConvergenceException, NotPositiveDefiniteMatrixException { CostFunction rosenbrock = new CostFunction() { public double cost(double[] x) { ++count; double a = x[1] - x[0] * x[0]; double b = 1.0 - x[0]; return 100 * a * a + b * b; } }; count = 0; NelderMead nm = new NelderMead(); try { nm.minimize(rosenbrock, 100, new ValueChecker(1.0e-3), new double[][] { { -1.2, 1.0 }, { 3.5, -2.3 }, { 0.4, 1.5 } }, 1, 5384353l); fail("an exception should have been thrown"); } catch (ConvergenceException ce) { // expected behavior } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } count = 0; PointCostPair optimum = nm.minimize(rosenbrock, 100, new ValueChecker(1.0e-3), new double[][] { { -1.2, 1.0 }, { 0.9, 1.2 }, { 3.5, -2.3 } }, 10, 1642738l); assertTrue(count > 700); assertTrue(count < 800); assertEquals(0.0, optimum.getCost(), 5.0e-5); assertEquals(1.0, optimum.getPoint()[0], 0.01); assertEquals(1.0, optimum.getPoint()[1], 0.01); PointCostPair[] minima = nm.getMinima(); assertEquals(10, minima.length); assertNotNull(minima[0]); assertNull(minima[minima.length - 1]); for (int i = 0; i < minima.length; ++i) { if (minima[i] == null) { if ((i + 1) < minima.length) { assertTrue(minima[i+1] == null); } } else { if (i > 0) { assertTrue(minima[i-1].getCost() <= minima[i].getCost()); } } } RandomGenerator rg = new JDKRandomGenerator(); rg.setSeed(64453353l); RandomVectorGenerator rvg = new UncorrelatedRandomVectorGenerator(new double[] { 0.9, 1.1 }, new double[] { 0.2, 0.2 }, new UniformRandomGenerator(rg)); optimum = nm.minimize(rosenbrock, 100, new ValueChecker(1.0e-3), rvg); assertEquals(0.0, optimum.getCost(), 2.0e-4); optimum = nm.minimize(rosenbrock, 100, new ValueChecker(1.0e-3), rvg, 3); assertEquals(0.0, optimum.getCost(), 3.0e-5); } public void testPowell() throws CostException, ConvergenceException { CostFunction powell = new CostFunction() { public double cost(double[] x) { ++count; double a = x[0] + 10 * x[1]; double b = x[2] - x[3]; double c = x[1] - 2 * x[2]; double d = x[0] - x[3]; return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d; } }; count = 0; NelderMead nm = new NelderMead(); PointCostPair optimum = nm.minimize(powell, 200, new ValueChecker(1.0e-3), new double[] { 3.0, -1.0, 0.0, 1.0 }, new double[] { 4.0, 0.0, 1.0, 2.0 }, 1, 1642738l); assertTrue(count < 150); assertEquals(0.0, optimum.getCost(), 6.0e-4); assertEquals(0.0, optimum.getPoint()[0], 0.07); assertEquals(0.0, optimum.getPoint()[1], 0.07); assertEquals(0.0, optimum.getPoint()[2], 0.07); assertEquals(0.0, optimum.getPoint()[3], 0.07); } private static class ValueChecker implements ConvergenceChecker { public ValueChecker(double threshold) { this.threshold = threshold; } public boolean converged(PointCostPair[] simplex) { PointCostPair smallest = simplex[0]; PointCostPair largest = simplex[simplex.length - 1]; return (largest.getCost() - smallest.getCost()) < threshold; } private double threshold; }; public static Test suite() { return new TestSuite(NelderMeadTest.class); } private int count; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.optimization; import org.apache.commons.math.optimization.ConvergenceChecker; import org.apache.commons.math.optimization.CostException; import org.apache.commons.math.optimization.CostFunction; import org.apache.commons.math.optimization.MultiDirectional; import org.apache.commons.math.ConvergenceException; import org.apache.commons.math.optimization.PointCostPair; import junit.framework.*; public class MultiDirectionalTest extends TestCase { public MultiDirectionalTest(String name) { super(name); } public void testCostExceptions() throws ConvergenceException { CostFunction wrong = new CostFunction() { public double cost(double[] x) throws CostException { if (x[0] < 0) { throw new CostException("{0}", new Object[] { "oops"}); } else if (x[0] > 1) { throw new CostException(new RuntimeException("oops")); } else { return x[0] * (1 - x[0]); } } }; try { new MultiDirectional(1.9, 0.4).minimize(wrong, 10, new ValueChecker(1.0e-3), new double[] { -0.5 }, new double[] { 0.5 }); fail("an exception should have been thrown"); } catch (CostException ce) { // expected behavior assertNull(ce.getCause()); } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } try { new MultiDirectional(1.9, 0.4).minimize(wrong, 10, new ValueChecker(1.0e-3), new double[] { 0.5 }, new double[] { 1.5 }); fail("an exception should have been thrown"); } catch (CostException ce) { // expected behavior assertNotNull(ce.getCause()); } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } public void testRosenbrock() throws CostException, ConvergenceException { CostFunction rosenbrock = new CostFunction() { public double cost(double[] x) { ++count; double a = x[1] - x[0] * x[0]; double b = 1.0 - x[0]; return 100 * a * a + b * b; } }; count = 0; PointCostPair optimum = new MultiDirectional().minimize(rosenbrock, 100, new ValueChecker(1.0e-3), new double[][] { { -1.2, 1.0 }, { 0.9, 1.2 } , { 3.5, -2.3 } }); assertTrue(count > 60); assertTrue(optimum.getCost() > 0.01); } public void testPowell() throws CostException, ConvergenceException { CostFunction powell = new CostFunction() { public double cost(double[] x) { ++count; double a = x[0] + 10 * x[1]; double b = x[2] - x[3]; double c = x[1] - 2 * x[2]; double d = x[0] - x[3]; return a * a + 5 * b * b + c * c * c * c + 10 * d * d * d * d; } }; count = 0; PointCostPair optimum = new MultiDirectional().minimize(powell, 1000, new ValueChecker(1.0e-3), new double[] { 3.0, -1.0, 0.0, 1.0 }, new double[] { 4.0, 0.0, 1.0, 2.0 }); assertTrue(count > 850); assertTrue(optimum.getCost() > 0.015); } private static class ValueChecker implements ConvergenceChecker { public ValueChecker(double threshold) { this.threshold = threshold; } public boolean converged(PointCostPair[] simplex) { PointCostPair smallest = simplex[0]; PointCostPair largest = simplex[simplex.length - 1]; return (largest.getCost() - smallest.getCost()) < threshold; } private double threshold; }; public static Test suite() { return new TestSuite(MultiDirectionalTest.class); } private int count; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.special; import org.apache.commons.math.MathException; import org.apache.commons.math.TestUtils; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class BetaTest extends TestCase { /** * Constructor for BetaTest. * @param name */ public BetaTest(String name) { super(name); } private void testRegularizedBeta(double expected, double x, double a, double b) { try { double actual = Beta.regularizedBeta(x, a, b); TestUtils.assertEquals(expected, actual, 10e-15); } catch(MathException ex){ fail(ex.getMessage()); } } private void testLogBeta(double expected, double a, double b) { double actual = Beta.logBeta(a, b); TestUtils.assertEquals(expected, actual, 10e-15); } public void testRegularizedBetaNanPositivePositive() { testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0); } public void testRegularizedBetaPositiveNanPositive() { testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0); } public void testRegularizedBetaPositivePositiveNan() { testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN); } public void testRegularizedBetaNegativePositivePositive() { testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0); } public void testRegularizedBetaPositiveNegativePositive() { testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0); } public void testRegularizedBetaPositivePositiveNegative() { testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0); } public void testRegularizedBetaZeroPositivePositive() { testRegularizedBeta(0.0, 0.0, 1.0, 2.0); } public void testRegularizedBetaPositiveZeroPositive() { testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0); } public void testRegularizedBetaPositivePositiveZero() { testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0); } public void testRegularizedBetaPositivePositivePositive() { testRegularizedBeta(0.75, 0.5, 1.0, 2.0); } public void testLogBetaNanPositive() { testLogBeta(Double.NaN, Double.NaN, 2.0); } public void testLogBetaPositiveNan() { testLogBeta(Double.NaN, 1.0, Double.NaN); } public void testLogBetaNegativePositive() { testLogBeta(Double.NaN, -1.0, 2.0); } public void testLogBetaPositiveNegative() { testLogBeta(Double.NaN, 1.0, -2.0); } public void testLogBetaZeroPositive() { testLogBeta(Double.NaN, 0.0, 2.0); } public void testLogBetaPositiveZero() { testLogBeta(Double.NaN, 1.0, 0.0); } public void testLogBetaPositivePositive() { testLogBeta(-0.693147180559945, 1.0, 2.0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.special; import org.apache.commons.math.MathException; import org.apache.commons.math.TestUtils; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class GammaTest extends TestCase { /** * Constructor for BetaTest. * @param name */ public GammaTest(String name) { super(name); } private void testRegularizedGamma(double expected, double a, double x) { try { double actualP = Gamma.regularizedGammaP(a, x); double actualQ = Gamma.regularizedGammaQ(a, x); TestUtils.assertEquals(expected, actualP, 10e-15); TestUtils.assertEquals(actualP, 1.0 - actualQ, 10e-15); } catch(MathException ex){ fail(ex.getMessage()); } } private void testLogGamma(double expected, double x) { double actual = Gamma.logGamma(x); TestUtils.assertEquals(expected, actual, 10e-15); } public void testRegularizedGammaNanPositive() { testRegularizedGamma(Double.NaN, Double.NaN, 1.0); } public void testRegularizedGammaPositiveNan() { testRegularizedGamma(Double.NaN, 1.0, Double.NaN); } public void testRegularizedGammaNegativePositive() { testRegularizedGamma(Double.NaN, -1.5, 1.0); } public void testRegularizedGammaPositiveNegative() { testRegularizedGamma(Double.NaN, 1.0, -1.0); } public void testRegularizedGammaZeroPositive() { testRegularizedGamma(Double.NaN, 0.0, 1.0); } public void testRegularizedGammaPositiveZero() { testRegularizedGamma(0.0, 1.0, 0.0); } public void testRegularizedGammaPositivePositive() { testRegularizedGamma(0.632120558828558, 1.0, 1.0); } public void testLogGammaNan() { testLogGamma(Double.NaN, Double.NaN); } public void testLogGammaNegative() { testLogGamma(Double.NaN, -1.0); } public void testLogGammaZero() { testLogGamma(Double.NaN, 0.0); } public void testLogGammaPositive() { testLogGamma(0.6931471805599457, 3.0); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.special; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class ErfTest extends TestCase { public void testErf0() throws MathException { double actual = Erf.erf(0.0); double expected = 0.0; assertEquals(expected, actual, 1.0e-5); } public void testErf1960() throws MathException { double x = 1.960 / Math.sqrt(2.0); double actual = Erf.erf(x); double expected = 0.95; assertEquals(expected, actual, 1.0e-5); actual = Erf.erf(-x); expected = -expected; assertEquals(expected, actual, 1.0e-5); } public void testErf2576() throws MathException { double x = 2.576 / Math.sqrt(2.0); double actual = Erf.erf(x); double expected = 0.99; assertEquals(expected, actual, 1.0e-5); actual = Erf.erf(-x); expected = -expected; assertEquals(expected, actual, 1.0e-5); } public void testErf2807() throws MathException { double x = 2.807 / Math.sqrt(2.0); double actual = Erf.erf(x); double expected = 0.995; assertEquals(expected, actual, 1.0e-5); actual = Erf.erf(-x); expected = -expected; assertEquals(expected, actual, 1.0e-5); } public void testErf3291() throws MathException { double x = 3.291 / Math.sqrt(2.0); double actual = Erf.erf(x); double expected = 0.999; assertEquals(expected, actual, 1.0e-5); actual = Erf.erf(-x); expected = -expected; assertEquals(expected, actual, 1.0e-5); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for ChiSquareDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest { /** * Constructor for ChiSquareDistributionTest. * @param name */ public ChiSquareDistributionTest(String name) { super(name); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ public ContinuousDistribution makeDistribution() { return new ChiSquaredDistributionImpl(5.0); } /** Creates the default cumulative probability distribution test input values */ public double[] makeCumulativeTestPoints() { // quantiles computed using R version 1.8.1 (linux version) return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, 20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d}; } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d}; } /** Creates the default inverse cumulative probability test input values */ public double[] makeInverseCumulativeTestPoints() { return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1}; } /** Creates the default inverse cumulative probability density test expected values */ public double[] makeInverseCumulativeTestValues() { return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, 20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d, Double.POSITIVE_INFINITY}; } // --------------------- Override tolerance -------------- protected void setUp() throws Exception { super.setUp(); setTolerance(5e-6); } //---------------------------- Additional test cases ------------------------- public void testSmallDf() throws Exception { setDistribution(new ChiSquaredDistributionImpl(0.1d)); setTolerance(1E-4); // quantiles computed using R version 1.8.1 (linux version) setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32, 1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438, 0.5318646, 0.1526342}); setInverseCumulativeTestValues(getCumulativeTestPoints()); setInverseCumulativeTestPoints(getCumulativeTestValues()); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } public void testDfAccessors() { ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution(); assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE); distribution.setDegreesOfFreedom(4d); assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE); try { distribution.setDegreesOfFreedom(0d); fail("Expecting IllegalArgumentException for df = 0"); } catch (IllegalArgumentException ex) { // expected } } public void testDensity() { double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5}; //R 2.5: print(dchisq(x, df=1), digits=10) checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256}); //R 2.5: print(dchisq(x, df=0.1), digits=10) checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04}); //R 2.5: print(dchisq(x, df=2), digits=10) checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931}); //R 2.5: print(dchisq(x, df=10), digits=10) checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02}); } private void checkDensity(double df, double[] x, double[] expected) { ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df); for (int i = 0; i < x.length; i++) { assertEquals(expected[i], d.density(x[i]), 1e-5); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for GammaDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class GammaDistributionTest extends ContinuousDistributionAbstractTest { /** * Constructor for GammaDistributionTest. * @param name */ public GammaDistributionTest(String name) { super(name); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ public ContinuousDistribution makeDistribution() { return new GammaDistributionImpl(4d, 2d); } /** Creates the default cumulative probability distribution test input values */ public double[] makeCumulativeTestPoints() { // quantiles computed using R version 1.8.1 (linux version) return new double[] {0.8571048, 1.646497, 2.179731, 2.732637, 3.489539, 26.12448, 20.09024, 17.53455, 15.50731, 13.36157}; } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d}; } // --------------------- Override tolerance -------------- protected void setUp() throws Exception { super.setUp(); setTolerance(6e-6); } //---------------------------- Additional test cases ------------------------- public void testParameterAccessors() { GammaDistribution distribution = (GammaDistribution) getDistribution(); assertEquals(4d, distribution.getAlpha(), 0); distribution.setAlpha(3d); assertEquals(3d, distribution.getAlpha(), 0); assertEquals(2d, distribution.getBeta(), 0); distribution.setBeta(4d); assertEquals(4d, distribution.getBeta(), 0); try { distribution.setAlpha(0d); fail("Expecting IllegalArgumentException for alpha = 0"); } catch (IllegalArgumentException ex) { // expected } try { distribution.setBeta(0d); fail("Expecting IllegalArgumentException for beta = 0"); } catch (IllegalArgumentException ex) { // expected } } public void testProbabilities() throws Exception { testProbability(-1.000, 4.0, 2.0, .0000); testProbability(15.501, 4.0, 2.0, .9499); testProbability(0.504, 4.0, 1.0, .0018); testProbability(10.011, 1.0, 2.0, .9933); testProbability(5.000, 2.0, 2.0, .7127); } public void testValues() throws Exception { testValue(15.501, 4.0, 2.0, .9499); testValue(0.504, 4.0, 1.0, .0018); testValue(10.011, 1.0, 2.0, .9933); testValue(5.000, 2.0, 2.0, .7127); } private void testProbability(double x, double a, double b, double expected) throws Exception { GammaDistribution distribution = new GammaDistributionImpl( a, b ); double actual = distribution.cumulativeProbability(x); assertEquals("probability for " + x, expected, actual, 10e-4); } private void testValue(double expected, double a, double b, double p) throws Exception { GammaDistribution distribution = new GammaDistributionImpl( a, b ); double actual = distribution.inverseCumulativeProbability(p); assertEquals("critical value for " + p, expected, actual, 10e-4); } public void testDensity() { double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5}; // R2.5: print(dgamma(x, shape=1, rate=1), digits=10) checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999}); // R2.5: print(dgamma(x, shape=2, rate=1), digits=10) checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995}); // R2.5: print(dgamma(x, shape=4, rate=1), digits=10) checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01}); // R2.5: print(dgamma(x, shape=4, rate=10), digits=10) checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17}); // R2.5: print(dgamma(x, shape=.1, rate=10), digits=10) checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24}); // R2.5: print(dgamma(x, shape=.1, rate=20), digits=10) checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45}); // R2.5: print(dgamma(x, shape=.1, rate=4), digits=10) checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11}); // R2.5: print(dgamma(x, shape=.1, rate=1), digits=10) checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04}); } private void checkDensity(double alpha, double rate, double[] x, double[] expected) { GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate); for (int i = 0; i < x.length; i++) { assertEquals(expected[i], d.density(x[i]), 1e-5); } } public void testInverseCumulativeProbabilityExtremes() throws Exception { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; import org.apache.commons.math.TestUtils; /** * Test cases for HyperGeometriclDistribution. * Extends IntegerDistributionAbstractTest. See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest { /** * Constructor for ChiSquareDistributionTest. * @param name */ public HypergeometricDistributionTest(String name) { super(name); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default discrete distribution instance to use in tests. */ public IntegerDistribution makeDistribution() { return new HypergeometricDistributionImpl(10,5, 5); } /** Creates the default probability density test input values */ public int[] makeDensityTestPoints() { return new int[] {-1, 0, 1, 2, 3, 4, 5, 10}; } /** Creates the default probability density test expected values */ public double[] makeDensityTestValues() { return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d, 0.099206d, 0.003968d, 0d}; } /** Creates the default cumulative probability density test input values */ public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d, 1.00000d, 1d}; } /** Creates the default inverse cumulative probability test input values */ public double[] makeInverseCumulativeTestPoints() { return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1d}; } /** Creates the default inverse cumulative probability density test expected values */ public int[] makeInverseCumulativeTestValues() { return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5}; } //-------------------- Additional test cases ------------------------------ /** Verify that if there are no failures, mass is concentrated on sampleSize */ public void testDegenerateNoFailures() throws Exception { setDistribution(new HypergeometricDistributionImpl(5,5,3)); setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 }); setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 3, 10}); setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {2, 2}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } /** Verify that if there are no successes, mass is concentrated on 0 */ public void testDegenerateNoSuccesses() throws Exception { setDistribution(new HypergeometricDistributionImpl(5,0,3)); setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 }); setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 3, 10}); setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {-1, -1}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */ public void testDegenerateFullSample() throws Exception { setDistribution(new HypergeometricDistributionImpl(5,3,5)); setCumulativeTestPoints(new int[] {-1, 0, 1, 3, 10 }); setCumulativeTestValues(new double[] {0d, 0d, 0d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 3, 10}); setDensityTestValues(new double[] {0d, 0d, 0d, 1d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {2, 2}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } public void testPopulationSize() { HypergeometricDistribution dist = new HypergeometricDistributionImpl(5,3,5); try { dist.setPopulationSize(-1); fail("negative population size. IllegalArgumentException expected"); } catch(IllegalArgumentException ex) { } dist.setPopulationSize(10); assertEquals(10, dist.getPopulationSize()); } public void testLargeValues() { int populationSize = 3456; int sampleSize = 789; int numberOfSucceses = 101; double[][] data = { {0.0, 2.75646034603961e-12, 2.75646034603961e-12, 1.0}, {1.0, 8.55705370142386e-11, 8.83269973602783e-11, 0.999999999997244}, {2.0, 1.31288129219665e-9, 1.40120828955693e-9, 0.999999999911673}, {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792}, {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375}, {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203}, {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701}, {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381}, {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199}, {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718}, {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418}, {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57}, {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59}, {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61}, {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63}, {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65}, {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68}, }; testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data); } private void testHypergeometricDistributionProbabilities(int populationSize, int sampleSize, int numberOfSucceses, double[][] data) { HypergeometricDistributionImpl dist = new HypergeometricDistributionImpl(populationSize, numberOfSucceses, sampleSize); for (int i = 0; i < data.length; ++i) { int x = (int)data[i][0]; double pdf = data[i][1]; double actualPdf = dist.probability(x); TestUtils.assertRelativelyEquals(pdf, actualPdf, 1.0e-9); double cdf = data[i][2]; double actualCdf = dist.cumulativeProbability(x); TestUtils.assertRelativelyEquals(cdf, actualCdf, 1.0e-9); double cdf1 = data[i][3]; double actualCdf1 = dist.upperCumulativeProbability(x); TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9); } } public void testMoreLargeValues() { int populationSize = 26896; int sampleSize = 895; int numberOfSucceses = 55; double[][] data = { {0.0, 0.155168304750504, 0.155168304750504, 1.0}, {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496}, {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16}, {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17}, {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18}, {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20}, {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21}, {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23}, {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69}, {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71}, {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74}, {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76}, {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79}, {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82}, }; testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for CauchyDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class CauchyDistributionTest extends ContinuousDistributionAbstractTest { /** * Constructor for CauchyDistributionTest. * @param arg0 */ public CauchyDistributionTest(String arg0) { super(arg0); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ public ContinuousDistribution makeDistribution() { return new CauchyDistributionImpl(1.2, 2.1); } /** Creates the default cumulative probability distribution test input values */ public double[] makeCumulativeTestPoints() { // quantiles computed using Mathematica return new double[] {-667.2485619d, -65.6230835d, -25.48302995d, -12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d, 27.88302995d, 68.0230835d, 669.6485619d}; } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d, 0.975d, 0.990d, 0.999d}; } //---------------------------- Additional test cases ------------------------- public void testInverseCumulativeProbabilityExtremes() throws Exception { setInverseCumulativeTestPoints(new double[] {0.0, 1.0}); setInverseCumulativeTestValues( new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } public void testMedian() { CauchyDistribution distribution = (CauchyDistribution) getDistribution(); double expected = Math.random(); distribution.setMedian(expected); assertEquals(expected, distribution.getMedian(), 0.0); } public void testScale() { CauchyDistribution distribution = (CauchyDistribution) getDistribution(); double expected = Math.random(); distribution.setScale(expected); assertEquals(expected, distribution.getScale(), 0.0); } public void testSetScale() { CauchyDistribution distribution = (CauchyDistribution) getDistribution(); try { distribution.setScale(0.0); fail("Can not have 0.0 scale."); } catch (IllegalArgumentException ex) { // success } try { distribution.setScale(-1.0); fail("Can not have negative scale."); } catch (IllegalArgumentException ex) { // success } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for FDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class FDistributionTest extends ContinuousDistributionAbstractTest { /** * Constructor for FDistributionTest. * @param name */ public FDistributionTest(String name) { super(name); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ public ContinuousDistribution makeDistribution() { return new FDistributionImpl(5.0, 6.0); } /** Creates the default cumulative probability distribution test input values */ public double[] makeCumulativeTestPoints() { // quantiles computed using R version 1.8.1 (linux version) return new double[] {0.03468084d ,0.09370091d, 0.1433137d, 0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d, 4.387374d, 3.107512d}; } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d}; } // --------------------- Override tolerance -------------- protected void setUp() throws Exception { super.setUp(); setTolerance(4e-6); } //---------------------------- Additional test cases ------------------------- public void testCumulativeProbabilityExtremes() throws Exception { setCumulativeTestPoints(new double[] {-2, 0}); setCumulativeTestValues(new double[] {0, 0}); verifyCumulativeProbabilities(); } public void testInverseCumulativeProbabilityExtremes() throws Exception { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } public void testDfAccessors() { FDistribution distribution = (FDistribution) getDistribution(); assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE); distribution.setNumeratorDegreesOfFreedom(4d); assertEquals(4d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE); assertEquals(6d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE); distribution.setDenominatorDegreesOfFreedom(4d); assertEquals(4d, distribution.getDenominatorDegreesOfFreedom(), Double.MIN_VALUE); try { distribution.setNumeratorDegreesOfFreedom(0d); fail("Expecting IllegalArgumentException for df = 0"); } catch (IllegalArgumentException ex) { // expected } try { distribution.setDenominatorDegreesOfFreedom(0d); fail("Expecting IllegalArgumentException for df = 0"); } catch (IllegalArgumentException ex) { // expected } } public void testLargeDegreesOfFreedom() throws Exception { org.apache.commons.math.distribution.FDistributionImpl fd = new org.apache.commons.math.distribution.FDistributionImpl( 100000., 100000.); double p = fd.cumulativeProbability(.999); double x = fd.inverseCumulativeProbability(p); assertEquals(.999, x, 1.0e-5); } public void testSmallDegreesOfFreedom() throws Exception { org.apache.commons.math.distribution.FDistributionImpl fd = new org.apache.commons.math.distribution.FDistributionImpl( 1.0, 1.0); double p = fd.cumulativeProbability(0.975); double x = fd.inverseCumulativeProbability(p); assertEquals(0.975, x, 1.0e-5); fd.setDenominatorDegreesOfFreedom(2.0); p = fd.cumulativeProbability(0.975); x = fd.inverseCumulativeProbability(p); assertEquals(0.975, x, 1.0e-5); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; import junit.framework.TestCase; import org.apache.commons.math.TestUtils; /** * Abstract base class for {@link ContinuousDistribution} tests. * <p> * To create a concrete test class for a continuous distribution * implementation, first implement makeDistribution() to return a distribution * instance to use in tests. Then implement each of the test data generation * methods below. In each case, the test points and test values arrays * returned represent parallel arrays of inputs and expected values for the * distribution returned by makeDistribution(). Default implementations * are provided for the makeInverseXxx methods that just invert the mapping * defined by the arrays returned by the makeCumulativeXxx methods. * <p> * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities * makeCumulativeTestValues() -- expected cumulative probabilites * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf * makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> * To implement additional test cases with different distribution instances and * test data, use the setXxx methods for the instance data in test cases and * call the verifyXxx methods to verify results. * <p> * Error tolerance can be overriden by implementing getTolerance(). * <p> * Test data should be validated against reference tables or other packages * where possible, and the source of the reference data and/or validation * should be documented in the test cases. A framework for validating * distribution data against R is included in the /src/test/R source tree. * <p> * See {@link NormalDistributionTest} and {@link ChiSquareDistributionTest} * for examples. * * @version $Revision$ $Date$ */ public abstract class ContinuousDistributionAbstractTest extends TestCase { //-------------------- Private test instance data ------------------------- /** Distribution instance used to perform tests */ private ContinuousDistribution distribution; /** Tolerance used in comparing expected and returned values */ private double tolerance = 1E-4; /** Arguments used to test cumulative probability density calculations */ private double[] cumulativeTestPoints; /** Values used to test cumulative probability density calculations */ private double[] cumulativeTestValues; /** Arguments used to test inverse cumulative probability density calculations */ private double[] inverseCumulativeTestPoints; /** Values used to test inverse cumulative probability density calculations */ private double[] inverseCumulativeTestValues; //------------------------------------------------------------------------- /** * Constructor for ContinuousDistributionAbstractTest. * @param name */ public ContinuousDistributionAbstractTest(String name) { super(name); } //-------------------- Abstract methods ----------------------------------- /** Creates the default continuous distribution instance to use in tests. */ public abstract ContinuousDistribution makeDistribution(); /** Creates the default cumulative probability density test input values */ public abstract double[] makeCumulativeTestPoints(); /** Creates the default cumulative probability density test expected values */ public abstract double[] makeCumulativeTestValues(); //---- Default implementations of inverse test data generation methods ---- /** Creates the default inverse cumulative probability test input values */ public double[] makeInverseCumulativeTestPoints() { return makeCumulativeTestValues(); } /** Creates the default inverse cumulative probability density test expected values */ public double[] makeInverseCumulativeTestValues() { return makeCumulativeTestPoints(); } //-------------------- Setup / tear down ---------------------------------- /** * Setup sets all test instance data to default values */ protected void setUp() throws Exception { super.setUp(); distribution = makeDistribution(); cumulativeTestPoints = makeCumulativeTestPoints(); cumulativeTestValues = makeCumulativeTestValues(); inverseCumulativeTestPoints = makeInverseCumulativeTestPoints(); inverseCumulativeTestValues = makeInverseCumulativeTestValues(); } /** * Cleans up test instance data */ protected void tearDown() throws Exception { super.tearDown(); distribution = null; cumulativeTestPoints = null; cumulativeTestValues = null; inverseCumulativeTestPoints = null; inverseCumulativeTestValues = null; } //-------------------- Verification methods ------------------------------- /** * Verifies that cumulative probability density calculations match expected values * using current test instance data */ protected void verifyCumulativeProbabilities() throws Exception { for (int i = 0; i < cumulativeTestPoints.length; i++) { TestUtils.assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i], cumulativeTestValues[i], distribution.cumulativeProbability(cumulativeTestPoints[i]), getTolerance()); } } /** * Verifies that inverse cumulative probability density calculations match expected values * using current test instance data */ protected void verifyInverseCumulativeProbabilities() throws Exception { for (int i = 0; i < inverseCumulativeTestPoints.length; i++) { TestUtils.assertEquals("Incorrect inverse cumulative probability value returned for " + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]), getTolerance()); } } //------------------------ Default test cases ----------------------------- /** * Verifies that cumulative probability density calculations match expected values * using default test instance data */ public void testCumulativeProbabilities() throws Exception { verifyCumulativeProbabilities(); } /** * Verifies that inverse cumulative probability density calculations match expected values * using default test instance data */ public void testInverseCumulativeProbabilities() throws Exception { verifyInverseCumulativeProbabilities(); } /** * Verifies that probability computations are consistent */ public void testConsistency() throws Exception { for (int i=1; i < cumulativeTestPoints.length; i++) { // check that cdf(x, x) = 0 TestUtils.assertEquals(0d, distribution.cumulativeProbability (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance); // check that P(a < X < b) = P(X < b) - P(X < a) double upper = Math.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]); double lower = Math.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]); double diff = distribution.cumulativeProbability(upper) - distribution.cumulativeProbability(lower); double direct = distribution.cumulativeProbability(lower, upper); TestUtils.assertEquals("Inconsistent cumulative probabilities for (" + lower + "," + upper + ")", diff, direct, tolerance); } } /** * Verifies that illegal arguments are correctly handled */ public void testIllegalArguments() throws Exception { try { distribution.cumulativeProbability(1, 0); fail("Expecting IllegalArgumentException for bad cumulativeProbability interval"); } catch (IllegalArgumentException ex) { // expected } try { distribution.inverseCumulativeProbability(-1); fail("Expecting IllegalArgumentException for p = -1"); } catch (IllegalArgumentException ex) { // expected } try { distribution.inverseCumulativeProbability(2); fail("Expecting IllegalArgumentException for p = 2"); } catch (IllegalArgumentException ex) { // expected } } //------------------ Getters / Setters for test instance data ----------- /** * @return Returns the cumulativeTestPoints. */ protected double[] getCumulativeTestPoints() { return cumulativeTestPoints; } /** * @param cumulativeTestPoints The cumulativeTestPoints to set. */ protected void setCumulativeTestPoints(double[] cumulativeTestPoints) { this.cumulativeTestPoints = cumulativeTestPoints; } /** * @return Returns the cumulativeTestValues. */ protected double[] getCumulativeTestValues() { return cumulativeTestValues; } /** * @param cumulativeTestValues The cumulativeTestValues to set. */ protected void setCumulativeTestValues(double[] cumulativeTestValues) { this.cumulativeTestValues = cumulativeTestValues; } /** * @return Returns the distribution. */ protected ContinuousDistribution getDistribution() { return distribution; } /** * @param distribution The distribution to set. */ protected void setDistribution(ContinuousDistribution distribution) { this.distribution = distribution; } /** * @return Returns the inverseCumulativeTestPoints. */ protected double[] getInverseCumulativeTestPoints() { return inverseCumulativeTestPoints; } /** * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set. */ protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) { this.inverseCumulativeTestPoints = inverseCumulativeTestPoints; } /** * @return Returns the inverseCumulativeTestValues. */ protected double[] getInverseCumulativeTestValues() { return inverseCumulativeTestValues; } /** * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set. */ protected void setInverseCumulativeTestValues(double[] inverseCumulativeTestValues) { this.inverseCumulativeTestValues = inverseCumulativeTestValues; } /** * @return Returns the tolerance. */ protected double getTolerance() { return tolerance; } /** * @param tolerance The tolerance to set. */ protected void setTolerance(double tolerance) { this.tolerance = tolerance; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; import junit.framework.TestCase; import org.apache.commons.math.MathException; public class BetaDistributionTest extends TestCase { public void testCumulative() throws MathException { double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1}; // all test data computed using R 2.5 checkCumulative(0.1, 0.1, x, new double[]{ 0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861, 0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098, 0.5936149061, 1.0000000000, 1.0000000000}); checkCumulative(0.1, 0.5, x, new double[]{ 0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304, 0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404, 0.9423662883, 1.0000000000, 1.0000000000}); checkCumulative(0.1, 1.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506, 0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685, 0.9895192582, 1.0000000000, 1.0000000000}); checkCumulative(0.1, 2.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211, 0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239, 0.9994144508, 1.0000000000, 1.0000000000}); checkCumulative(0.1, 4.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085, 0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793, 0.9999967829, 1.0000000000, 1.0000000000}); checkCumulative(0.5, 0.1, x, new double[]{ 0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962, 0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146, 0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000}); checkCumulative(0.5, 0.5, x, new double[]{ 0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196, 0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647, 0.7951672353, 1.0000000000, 1.0000000000}); checkCumulative(0.5, 1.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575, 0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910, 0.9486832981, 1.0000000000, 1.0000000000}); checkCumulative(0.5, 2.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526, 0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101, 0.9961174630, 1.0000000000, 1.0000000000}); checkCumulative(0.5, 4.0, x, new double[]{ 0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842, 0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859, 0.9999714889, 1.0000000000, 1.0000000000}); checkCumulative(1.0, 0.1, x, new double[]{ 0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146, 0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344, 0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000}); checkCumulative(1.0, 0.5, x, new double[]{ 0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900, 0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797, 0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000}); checkCumulative(1, 1, x, new double[]{ 0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0}); checkCumulative(1, 2, x, new double[]{ 0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00}); checkCumulative(1, 4, x, new double[]{ 0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919, 0.9984, 0.9999, 1.0000, 1.0000}); checkCumulative(2.0, 0.1, x, new double[]{ 0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862, 0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512, 0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000}); checkCumulative(2, 1, x, new double[]{ 0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00}); checkCumulative(2.0, 0.5, x, new double[]{ 0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900, 0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356, 0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000}); checkCumulative(2, 2, x, new double[]{ 0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000}); checkCumulative(2, 4, x, new double[]{ 0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296, 0.96922, 0.99328, 0.99954, 1.00000, 1.00000}); checkCumulative(4.0, 0.1, x, new double[]{ 0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05, 3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03, 1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00}); checkCumulative(4.0, 0.5, x, new double[]{ 0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04, 2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02, 1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00}); checkCumulative(4, 1, x, new double[]{ 0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401, 0.4096, 0.6561, 1.0000, 1.0000}); checkCumulative(4, 2, x, new double[]{ 0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696, 0.52822, 0.73728, 0.91854, 1.00000, 1.00000}); checkCumulative(4, 4, x, new double[]{ 0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000, 0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000}); } private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) throws MathException { BetaDistribution d = new BetaDistributionImpl(alpha, beta); for (int i = 0; i < x.length; i++) { assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8); } for (int i = 1; i < x.length - 1; i++) { assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5); } } public void testDensity() throws MathException { double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9}; checkDensity(0.1, 0.1, x, new double[]{ 12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01, 1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01, 2.639396531e-01, 4.429925026e-01}); checkDensity(0.1, 0.5, x, new double[]{ 2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01, 2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01, 2.414013907e-01, 3.070567405e-01}); checkDensity(0.1, 1.0, x, new double[]{ 2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01, 2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01, 1.222414585e-01, 1.099464743e-01}); checkDensity(0.1, 2.0, x, new double[]{ 2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01, 1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02, 2.689298641e-02, 1.209399123e-02}); checkDensity(0.1, 4.0, x, new double[]{ 2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01, 5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03, 1.167143939e-03, 1.312171805e-04}); checkDensity(0.5, 0.1, x, new double[]{ 88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015, 0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793, 0.4203052841, 0.7394649088}); checkDensity(0.5, 0.5, x, new double[]{ 318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565, 0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796, 0.7957762075, 1.0610376697}); checkDensity(0.5, 1.0, x, new double[]{ 500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077, 0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778, 0.5590166450, 0.5270459839}); checkDensity(0.5, 2.0, x, new double[]{ 749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881, 0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859, 0.16770415497, 0.07905610701}); checkDensity(0.5, 4.0, x, new double[]{ 1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01, 3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02, 9.782644546e-03, 1.152878503e-03}); checkDensity(1.0, 0.1, x, new double[]{ 0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403, 0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768, 0.7943353837}); checkDensity(1.0, 0.5, x, new double[]{ 0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623, 0.7071074883, 0.7905704033, 0.9128724506, 1.1180367838, 1.5811467358}); checkDensity(1, 1, x, new double[]{ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}); checkDensity(1, 2, x, new double[]{ 1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998, 0.599998, 0.399998, 0.199998}); checkDensity(1, 4, x, new double[]{ 3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008, 0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004, 0.031999520002, 0.003999880001}); checkDensity(2.0, 0.1, x, new double[]{ 1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02, 6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01, 3.745917198e-01, 7.863929037e-01}); checkDensity(2.0, 0.5, x, new double[]{ 7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01, 3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01, 1.341645818e+00, 2.134537420613655}); checkDensity(2, 1, x, new double[]{ 0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002, 1.400002, 1.600002, 1.800002}); checkDensity(2, 2, x, new double[]{ 5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00, 1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00, 9.5999640e-01, 5.3999520e-01}); checkDensity(2, 4, x, new double[]{ 0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998, 1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001, 0.12799824001, 0.01799948000}); checkDensity(4.0, 0.1, x, new double[]{ 1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03, 1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01, 2.601171405e-01, 6.911229392e-01}); checkDensity(4.0, 0.5, x, new double[]{ 1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02, 9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01, 1.252205894e+00, 2.52142232809988}); checkDensity(4, 1, x, new double[]{ 4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01, 2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00, 2.048007680e+00, 2.916009720e+00}); checkDensity(4, 2, x, new double[]{ 1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01, 7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00, 2.047997440e+00, 1.457990280e+00}); checkDensity(4, 4, x, new double[]{ 1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00, 1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00, 5.734335488e-01, 1.020572784e-01}); } private void checkDensity(double alpha, double beta, double[] x, double[] expected) throws MathException { BetaDistribution d = new BetaDistributionImpl(alpha, beta); for (int i = 0; i < x.length; i++) { assertEquals(String.format("density at x=%.1f for alpha=%.1f, beta=%.1f", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for BinomialDistribution. * Extends IntegerDistributionAbstractTest. See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class BinomialDistributionTest extends IntegerDistributionAbstractTest { /** * Constructor for BinomialDistributionTest. * @param name */ public BinomialDistributionTest(String name) { super(name); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default discrete distribution instance to use in tests. */ public IntegerDistribution makeDistribution() { return new BinomialDistributionImpl(10,0.70); } /** Creates the default probability density test input values */ public int[] makeDensityTestPoints() { return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; } /** Creates the default probability density test expected values */ public double[] makeDensityTestValues() { return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d, 0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d}; } /** Creates the default cumulative probability density test input values */ public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d, 0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d}; } /** Creates the default inverse cumulative probability test input values */ public double[] makeInverseCumulativeTestPoints() { return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d,1}; } /** Creates the default inverse cumulative probability density test expected values */ public int[] makeInverseCumulativeTestValues() { return new int[] {-1, 1, 2, 3, 4, 4, 9, 9, 9, 8, 8, Integer.MAX_VALUE}; } //----------------- Additional test cases --------------------------------- /** Test degenerate case p = 0 */ public void testDegenerate0() throws Exception { setDistribution(new BinomialDistributionImpl(5,0.0d)); setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 }); setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 10, 11}); setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {-1, -1}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } /** Test degenerate case p = 1 */ public void testDegenerate1() throws Exception { setDistribution(new BinomialDistributionImpl(5,1.0d)); setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 }); setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10}); setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 1d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {4, 4}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; import junit.framework.TestCase; /** * Abstract base class for {@link IntegerDistribution} tests. * <p> * To create a concrete test class for an integer distribution implementation, * implement makeDistribution() to return a distribution instance to use in * tests and each of the test data generation methods below. In each case, the * test points and test values arrays returned represent parallel arrays of * inputs and expected values for the distribution returned by makeDistribution(). * <p> * makeDensityTestPoints() -- arguments used to test probability density calculation * makeDensityTestValues() -- expected probability densities * makeCumulativeTestPoints() -- arguments used to test cumulative probabilities * makeCumulativeTestValues() -- expected cumulative probabilites * makeInverseCumulativeTestPoints() -- arguments used to test inverse cdf evaluation * makeInverseCumulativeTestValues() -- expected inverse cdf values * <p> * To implement additional test cases with different distribution instances and test data, * use the setXxx methods for the instance data in test cases and call the verifyXxx methods * to verify results. * * @version $Revision$ $Date$ */ public abstract class IntegerDistributionAbstractTest extends TestCase { //-------------------- Private test instance data ------------------------- /** Discrete distribution instance used to perform tests */ private IntegerDistribution distribution; /** Tolerance used in comparing expected and returned values */ private double tolerance = 1E-4; /** Arguments used to test probability density calculations */ private int[] densityTestPoints; /** Values used to test probability density calculations */ private double[] densityTestValues; /** Arguments used to test cumulative probability density calculations */ private int[] cumulativeTestPoints; /** Values used to test cumulative probability density calculations */ private double[] cumulativeTestValues; /** Arguments used to test inverse cumulative probability density calculations */ private double[] inverseCumulativeTestPoints; /** Values used to test inverse cumulative probability density calculations */ private int[] inverseCumulativeTestValues; //------------------------------------------------------------------------- /** * Constructor for IntegerDistributionAbstractTest. * @param name */ public IntegerDistributionAbstractTest(String name) { super(name); } //-------------------- Abstract methods ----------------------------------- /** Creates the default discrete distribution instance to use in tests. */ public abstract IntegerDistribution makeDistribution(); /** Creates the default probability density test input values */ public abstract int[] makeDensityTestPoints(); /** Creates the default probability density test expected values */ public abstract double[] makeDensityTestValues(); /** Creates the default cumulative probability density test input values */ public abstract int[] makeCumulativeTestPoints(); /** Creates the default cumulative probability density test expected values */ public abstract double[] makeCumulativeTestValues(); /** Creates the default inverse cumulative probability test input values */ public abstract double[] makeInverseCumulativeTestPoints(); /** Creates the default inverse cumulative probability density test expected values */ public abstract int[] makeInverseCumulativeTestValues(); //-------------------- Setup / tear down ---------------------------------- /** * Setup sets all test instance data to default values */ protected void setUp() throws Exception { super.setUp(); distribution = makeDistribution(); densityTestPoints = makeDensityTestPoints(); densityTestValues = makeDensityTestValues(); cumulativeTestPoints = makeCumulativeTestPoints(); cumulativeTestValues = makeCumulativeTestValues(); inverseCumulativeTestPoints = makeInverseCumulativeTestPoints(); inverseCumulativeTestValues = makeInverseCumulativeTestValues(); } /** * Cleans up test instance data */ protected void tearDown() throws Exception { super.tearDown(); distribution = null; densityTestPoints = null; densityTestValues = null; cumulativeTestPoints = null; cumulativeTestValues = null; inverseCumulativeTestPoints = null; inverseCumulativeTestValues = null; } //-------------------- Verification methods ------------------------------- /** * Verifies that probability density calculations match expected values * using current test instance data */ protected void verifyDensities() throws Exception { for (int i = 0; i < densityTestPoints.length; i++) { assertEquals("Incorrect density value returned for " + densityTestPoints[i], densityTestValues[i], distribution.probability(densityTestPoints[i]), tolerance); } } /** * Verifies that cumulative probability density calculations match expected values * using current test instance data */ protected void verifyCumulativeProbabilities() throws Exception { for (int i = 0; i < cumulativeTestPoints.length; i++) { assertEquals("Incorrect cumulative probability value returned for " + cumulativeTestPoints[i], cumulativeTestValues[i], distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance); } } /** * Verifies that inverse cumulative probability density calculations match expected values * using current test instance data */ protected void verifyInverseCumulativeProbabilities() throws Exception { for (int i = 0; i < inverseCumulativeTestPoints.length; i++) { assertEquals("Incorrect inverse cumulative probability value returned for " + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i])); } } //------------------------ Default test cases ----------------------------- /** * Verifies that probability density calculations match expected values * using default test instance data */ public void testDensities() throws Exception { verifyDensities(); } /** * Verifies that cumulative probability density calculations match expected values * using default test instance data */ public void testCumulativeProbabilities() throws Exception { verifyCumulativeProbabilities(); } /** * Verifies that floating point arguments are correctly handled by * cumulativeProbablility(-,-) * JIRA: MATH-184 */ public void testFloatingPointArguments() throws Exception { for (int i = 0; i < cumulativeTestPoints.length; i++) { double arg = (double) cumulativeTestPoints[i]; assertEquals( "Incorrect cumulative probability value returned for " + cumulativeTestPoints[i], cumulativeTestValues[i], distribution.cumulativeProbability(arg), tolerance); if (i < cumulativeTestPoints.length - 1) { double arg2 = (double) cumulativeTestPoints[i + 1]; assertEquals("Inconsistent probability for discrete range " + "[ " + arg + "," + arg2 + " ]", distribution.cumulativeProbability( cumulativeTestPoints[i], cumulativeTestPoints[i + 1]), distribution.cumulativeProbability(arg, arg2), tolerance); arg = arg - Math.random(); arg2 = arg2 + Math.random(); assertEquals("Inconsistent probability for discrete range " + "[ " + arg + "," + arg2 + " ]", distribution.cumulativeProbability( cumulativeTestPoints[i], cumulativeTestPoints[i + 1]), distribution.cumulativeProbability(arg, arg2), tolerance); } } int one = 1; int ten = 10; int two = 2; double oned = (double) one; double twod = (double) two; double tend = (double) ten; assertEquals(distribution.cumulativeProbability(one, two), distribution.cumulativeProbability(oned, twod), tolerance); assertEquals(distribution.cumulativeProbability(one, two), distribution.cumulativeProbability(oned - tolerance, twod + 0.9), tolerance); assertEquals(distribution.cumulativeProbability(two, ten), distribution.cumulativeProbability(twod, tend), tolerance); assertEquals(distribution.cumulativeProbability(two, ten), distribution.cumulativeProbability(twod - tolerance, tend + 0.9), tolerance); } /** * Verifies that inverse cumulative probability density calculations match expected values * using default test instance data */ public void testInverseCumulativeProbabilities() throws Exception { verifyInverseCumulativeProbabilities(); } /** * Verifies that illegal arguments are correctly handled */ public void testIllegalArguments() throws Exception { try { distribution.cumulativeProbability(1, 0); fail("Expecting IllegalArgumentException for bad cumulativeProbability interval"); } catch (IllegalArgumentException ex) { // expected } try { distribution.inverseCumulativeProbability(-1); fail("Expecting IllegalArgumentException for p = -1"); } catch (IllegalArgumentException ex) { // expected } try { distribution.inverseCumulativeProbability(2); fail("Expecting IllegalArgumentException for p = 2"); } catch (IllegalArgumentException ex) { // expected } } //------------------ Getters / Setters for test instance data ----------- /** * @return Returns the cumulativeTestPoints. */ protected int[] getCumulativeTestPoints() { return cumulativeTestPoints; } /** * @param cumulativeTestPoints The cumulativeTestPoints to set. */ protected void setCumulativeTestPoints(int[] cumulativeTestPoints) { this.cumulativeTestPoints = cumulativeTestPoints; } /** * @return Returns the cumulativeTestValues. */ protected double[] getCumulativeTestValues() { return cumulativeTestValues; } /** * @param cumulativeTestValues The cumulativeTestValues to set. */ protected void setCumulativeTestValues(double[] cumulativeTestValues) { this.cumulativeTestValues = cumulativeTestValues; } /** * @return Returns the densityTestPoints. */ protected int[] getDensityTestPoints() { return densityTestPoints; } /** * @param densityTestPoints The densityTestPoints to set. */ protected void setDensityTestPoints(int[] densityTestPoints) { this.densityTestPoints = densityTestPoints; } /** * @return Returns the densityTestValues. */ protected double[] getDensityTestValues() { return densityTestValues; } /** * @param densityTestValues The densityTestValues to set. */ protected void setDensityTestValues(double[] densityTestValues) { this.densityTestValues = densityTestValues; } /** * @return Returns the distribution. */ protected IntegerDistribution getDistribution() { return distribution; } /** * @param distribution The distribution to set. */ protected void setDistribution(IntegerDistribution distribution) { this.distribution = distribution; } /** * @return Returns the inverseCumulativeTestPoints. */ protected double[] getInverseCumulativeTestPoints() { return inverseCumulativeTestPoints; } /** * @param inverseCumulativeTestPoints The inverseCumulativeTestPoints to set. */ protected void setInverseCumulativeTestPoints(double[] inverseCumulativeTestPoints) { this.inverseCumulativeTestPoints = inverseCumulativeTestPoints; } /** * @return Returns the inverseCumulativeTestValues. */ protected int[] getInverseCumulativeTestValues() { return inverseCumulativeTestValues; } /** * @param inverseCumulativeTestValues The inverseCumulativeTestValues to set. */ protected void setInverseCumulativeTestValues(int[] inverseCumulativeTestValues) { this.inverseCumulativeTestValues = inverseCumulativeTestValues; } /** * @return Returns the tolerance. */ protected double getTolerance() { return tolerance; } /** * @param tolerance The tolerance to set. */ protected void setTolerance(double tolerance) { this.tolerance = tolerance; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for NormalDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class NormalDistributionTest extends ContinuousDistributionAbstractTest { /** * Constructor for NormalDistributionTest. * @param arg0 */ public NormalDistributionTest(String arg0) { super(arg0); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ public ContinuousDistribution makeDistribution() { return new NormalDistributionImpl(2.1, 1.4); } /** Creates the default cumulative probability distribution test input values */ public double[] makeCumulativeTestPoints() { // quantiles computed using R return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d, 6.426325d, 5.356887d, 4.84395d, 4.402795d, 3.894172d}; } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d}; } // --------------------- Override tolerance -------------- protected void setUp() throws Exception { super.setUp(); setTolerance(1E-6); } //---------------------------- Additional test cases ------------------------- private void verifyQuantiles() throws Exception { NormalDistribution distribution = (NormalDistribution) getDistribution(); double mu = distribution.getMean(); double sigma = distribution.getStandardDeviation(); setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma, mu, mu + sigma, mu +2 * sigma, mu +3 * sigma, mu + 4 * sigma, mu + 5 * sigma}); // Quantiles computed using R (same as Mathematica) setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447, 0.9772499, 0.9986501, 0.9999683, 0.9999997}); verifyCumulativeProbabilities(); } public void testQuantiles() throws Exception { verifyQuantiles(); setDistribution(new NormalDistributionImpl(0, 1)); verifyQuantiles(); setDistribution(new NormalDistributionImpl(0, 0.1)); verifyQuantiles(); } public void testInverseCumulativeProbabilityExtremes() throws Exception { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues( new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } public void testGetMean() { NormalDistribution distribution = (NormalDistribution) getDistribution(); assertEquals(2.1, distribution.getMean(), 0); } public void testSetMean() throws Exception { double mu = Math.random(); NormalDistribution distribution = (NormalDistribution) getDistribution(); distribution.setMean(mu); verifyQuantiles(); } public void testGetStandardDeviation() { NormalDistribution distribution = (NormalDistribution) getDistribution(); assertEquals(1.4, distribution.getStandardDeviation(), 0); } public void testSetStandardDeviation() throws Exception { double sigma = 0.1d + Math.random(); NormalDistribution distribution = (NormalDistribution) getDistribution(); distribution.setStandardDeviation(sigma); assertEquals(sigma, distribution.getStandardDeviation(), 0); verifyQuantiles(); try { distribution.setStandardDeviation(0); fail("Expecting IllegalArgumentException for sd = 0"); } catch (IllegalArgumentException ex) { // Expected } } public void testDensity() { double [] x = new double[]{-2, -1, 0, 1, 2}; // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10) checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651}); // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10) checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899}); } private void checkDensity(double mean, double sd, double[] x, double[] expected) { NormalDistribution d = new NormalDistributionImpl(mean, sd); for (int i = 0; i < x.length; i++) { assertEquals(expected[i], d.density(x[i]), 1e-9); } } /** * Check to make sure top-coding of extreme values works correctly. * Verifies fix for JIRA MATH-167 */ public void testExtremeValues() throws Exception { NormalDistribution distribution = (NormalDistribution) getDistribution(); distribution.setMean(0); distribution.setStandardDeviation(1); for (int i = 0; i < 100; i+=5) { // make sure no convergence exception double lowerTail = distribution.cumulativeProbability((double)-i); double upperTail = distribution.cumulativeProbability((double) i); if (i < 10) { // make sure not top-coded assertTrue(lowerTail > 0.0d); assertTrue(upperTail < 1.0d); } else { // make sure top coding not reversed assertTrue(lowerTail < 0.00001); assertTrue(upperTail > 0.99999); } } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; import org.apache.commons.math.MathException; /** * <code>PoissonDistributionTest</code> * * @version $Revision$ $Date$ */ public class PoissonDistributionTest extends IntegerDistributionAbstractTest { /** * Poisson parameter value for the test distribution. */ private static final double DEFAULT_TEST_POISSON_PARAMETER = 4.0; /** * Constructor. * @param name */ public PoissonDistributionTest(String name) { super(name); setTolerance(1e-12); } /** * Creates the default discrete distribution instance to use in tests. */ public IntegerDistribution makeDistribution() { return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER); } /** * Creates the default probability density test input values. */ public int[] makeDensityTestPoints() { return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20}; } /** * Creates the default probability density test expected values. * These and all other test values are generated by R, version 1.8.1 */ public double[] makeDensityTestValues() { return new double[] { 0d, 0.0183156388887d, 0.073262555555d, 0.14652511111d, 0.195366814813d, 0.195366814813, 0.156293451851d, 0.00529247667642d, 8.27746364655e-09}; } /** * Creates the default cumulative probability density test input values. */ public int[] makeCumulativeTestPoints() { return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20 }; } /** * Creates the default cumulative probability density test expected values. */ public double[] makeCumulativeTestValues() { return new double[] { 0d, 0.0183156388887d, 0.0915781944437d, 0.238103305554d, 0.433470120367d, 0.62883693518, 0.78513038703d, 0.99716023388d, 0.999999998077 }; } /** * Creates the default inverse cumulative probability test input values. * Increased 3rd and 7th values slightly as computed cumulative * probabilities for corresponding values exceeds the target value (still * within tolerance). */ public double[] makeInverseCumulativeTestPoints() { return new double[] { 0d, 0.018315638889d, 0.0915781944437d, 0.238103305554d, 0.433470120367d, 0.62883693518, 0.78513038704d, 0.99716023388d, 0.999999998077 }; } /** * Creates the default inverse cumulative probability density test expected values. */ public int[] makeInverseCumulativeTestValues() { return new int[] { -1, 0, 1, 2, 3, 4, 5, 10, 20}; } /** * Test the normal approximation of the Poisson distribution by * calculating P(90 &le; X &le; 110) for X = Po(100) and * P(9900 &le; X &le; 10200) for X = Po(10000) */ public void testNormalApproximateProbability() throws Exception { PoissonDistribution dist = new PoissonDistributionImpl(100); double result = dist.normalApproximateProbability(110) - dist.normalApproximateProbability(89); assertEquals(0.706281887248, result, 1E-10); dist.setMean(10000); result = dist.normalApproximateProbability(10200) - dist.normalApproximateProbability(9899); assertEquals(0.820070051552, result, 1E-10); } /** * Test the degenerate cases of a 0.0 and 1.0 inverse cumulative probability. * @throws Exception */ public void testDegenerateInverseCumulativeProbability() throws Exception { PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER); assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d)); assertEquals(-1, dist.inverseCumulativeProbability(0d)); } public void testMean() { PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER); try { dist.setMean(-1); fail("negative mean. IllegalArgumentException expected"); } catch(IllegalArgumentException ex) { } dist.setMean(10.0); assertEquals(10.0, dist.getMean(), 0.0); } public void testLargeMeanCumulativeProbability() { PoissonDistribution dist = new PoissonDistributionImpl(1.0); double mean = 1.0; while (mean <= 10000000.0) { dist.setMean(mean); double x = mean * 2.0; double dx = x / 10.0; while (x >= 0) { try { dist.cumulativeProbability(x); } catch (MathException ex) { fail("mean of " + mean + " and x of " + x + " caused " + ex.getMessage()); } x -= dx; } mean *= 10.0; } } public void testLargeMeanInverseCumulativeProbability() { PoissonDistribution dist = new PoissonDistributionImpl(1.0); double mean = 1.0; while (mean <= 10000000.0) { dist.setMean(mean); double p = 0.1; double dp = p; while (p < 1.0) { try { dist.inverseCumulativeProbability(p); } catch (MathException ex) { fail("mean of " + mean + " and p of " + p + " caused " + ex.getMessage()); } p += dp; } mean *= 10.0; } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for TDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class TDistributionTest extends ContinuousDistributionAbstractTest { /** * Constructor for TDistributionTest. * @param name */ public TDistributionTest(String name) { super(name); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ public ContinuousDistribution makeDistribution() { return new TDistributionImpl(5.0); } /** Creates the default cumulative probability distribution test input values */ public double[] makeCumulativeTestPoints() { // quantiles computed using R version 1.8.1 (linux version) return new double[] {-5.89343,-3.36493, -2.570582, -2.015048, -1.475884, 0.0, 5.89343, 3.36493, 2.570582, 2.015048, 1.475884}; } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.5d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d}; } // --------------------- Override tolerance -------------- protected void setUp() throws Exception { super.setUp(); setTolerance(1E-6); } //---------------------------- Additional test cases ------------------------- /** * @see <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=27243"> * Bug report that prompted this unit test.</a> */ public void testCumulativeProbabilityAgaintStackOverflow() throws Exception { TDistributionImpl td = new TDistributionImpl(5.); td.cumulativeProbability(.1); td.cumulativeProbability(.01); } public void testSmallDf() throws Exception { setDistribution(new TDistributionImpl(1d)); setTolerance(1E-4); // quantiles computed using R version 1.8.1 (linux version) setCumulativeTestPoints(new double[] {-318.3088, -31.82052, -12.70620, -6.313752, -3.077684, 0.0, 318.3088, 31.82052, 12.70620, 6.313752, 3.077684}); setInverseCumulativeTestValues(getCumulativeTestPoints()); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } public void testInverseCumulativeProbabilityExtremes() throws Exception { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues( new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } public void testDfAccessors() { TDistribution distribution = (TDistribution) getDistribution(); assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE); distribution.setDegreesOfFreedom(4d); assertEquals(4d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE); try { distribution.setDegreesOfFreedom(0d); fail("Expecting IllegalArgumentException for df = 0"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for PascalDistribution. * Extends IntegerDistributionAbstractTest. See class javadoc for * IntegerDistributionAbstractTest for details. * * @version $Revision:$ $Date:$ */ public class PascalDistributionTest extends IntegerDistributionAbstractTest { /** * Constructor for PascalDistributionTest. * @param name */ public PascalDistributionTest(String name) { super(name); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default discrete distribution instance to use in tests. */ public IntegerDistribution makeDistribution() { return new PascalDistributionImpl(10,0.70); } /** Creates the default probability density test input values */ public int[] makeDensityTestPoints() { return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; } /** Creates the default probability density test expected values */ public double[] makeDensityTestValues() { return new double[] {0d, 0.02824d, 0.08474d, 0.13982d, 0.16779d, 0.16359d, 0.1374d, 0.10306d, 0.070673d, 0.04505d, 0.02703d, 0.01540d, 0.0084}; } /** Creates the default cumulative probability density test input values */ public int[] makeCumulativeTestPoints() { return makeDensityTestPoints(); } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0d, 0.02824d, 0.11299d, 0.25281d, 0.42060d, 0.58420d, 0.72162d, 0.82468d, 0.89535d, 0.94041d, 0.967446d, 0.98285, 0.99125d}; } /** Creates the default inverse cumulative probability test input values */ public double[] makeInverseCumulativeTestPoints() { return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d, 1}; } /** Creates the default inverse cumulative probability density test expected values */ public int[] makeInverseCumulativeTestValues() { return new int[] {-1, -1, -1, -1, 0, 0, 13, 10, 9, 8, 7, Integer.MAX_VALUE}; } //----------------- Additional test cases --------------------------------- /** Test degenerate case p = 0 */ public void testDegenerate0() throws Exception { setDistribution(new PascalDistributionImpl(5,0.0d)); setCumulativeTestPoints(new int[] {-1, 0, 1, 5, 10 }); setCumulativeTestValues(new double[] {0d, 0d, 0d, 0d, 0d}); setDensityTestPoints(new int[] {-1, 0, 1, 10, 11}); setDensityTestValues(new double[] {0d, 0d, 0d, 0d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } /** Test degenerate case p = 1 */ public void testDegenerate1() throws Exception { setDistribution(new PascalDistributionImpl(5,1.0d)); setCumulativeTestPoints(new int[] {-1, 0, 1, 2, 5, 10 }); setCumulativeTestValues(new double[] {0d, 1d, 1d, 1d, 1d, 1d}); setDensityTestPoints(new int[] {-1, 0, 1, 2, 5, 10}); setDensityTestValues(new double[] {0d, 1d, 0d, 0d, 0d, 0d}); setInverseCumulativeTestPoints(new double[] {0.1d, 0.5d}); setInverseCumulativeTestValues(new int[] {-1, -1}); verifyDensities(); verifyCumulativeProbabilities(); verifyInverseCumulativeProbabilities(); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; /** * Test cases for WeibullDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class WeibullDistributionTest extends ContinuousDistributionAbstractTest { /** * Constructor for CauchyDistributionTest. * @param arg0 */ public WeibullDistributionTest(String arg0) { super(arg0); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ public ContinuousDistribution makeDistribution() { return new WeibullDistributionImpl(1.2, 2.1); } /** Creates the default cumulative probability distribution test input values */ public double[] makeCumulativeTestPoints() { // quantiles computed using Mathematica return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d, 0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d, 6.232056007d, 7.497630467d, 10.51154969d}; } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d, 0.975d, 0.990d, 0.999d}; } //---------------------------- Additional test cases ------------------------- public void testInverseCumulativeProbabilityExtremes() throws Exception { setInverseCumulativeTestPoints(new double[] {0.0, 1.0}); setInverseCumulativeTestValues( new double[] {0.0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } public void testAlpha() { WeibullDistribution distribution = (WeibullDistribution) getDistribution(); double expected = Math.random(); distribution.setShape(expected); assertEquals(expected, distribution.getShape(), 0.0); } public void testBeta() { WeibullDistribution distribution = (WeibullDistribution) getDistribution(); double expected = Math.random(); distribution.setScale(expected); assertEquals(expected, distribution.getScale(), 0.0); } public void testSetAlpha() { WeibullDistribution distribution = (WeibullDistribution) getDistribution(); try { distribution.setShape(0.0); fail("Can not have 0.0 alpha."); } catch (IllegalArgumentException ex) { // success } try { distribution.setShape(-1.0); fail("Can not have negative alpha."); } catch (IllegalArgumentException ex) { // success } } public void testSetBeta() { WeibullDistribution distribution = (WeibullDistribution) getDistribution(); try { distribution.setScale(0.0); fail("Can not have 0.0 beta."); } catch (IllegalArgumentException ex) { // success } try { distribution.setScale(-1.0); fail("Can not have negative beta."); } catch (IllegalArgumentException ex) { // success } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.distribution; import org.apache.commons.math.MathException; /** * Test cases for ExponentialDistribution. * Extends ContinuousDistributionAbstractTest. See class javadoc for * ContinuousDistributionAbstractTest for details. * * @version $Revision$ $Date$ */ public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest { /** * Constructor for ExponentialDistributionTest. * @param name */ public ExponentialDistributionTest(String name) { super(name); } //-------------- Implementations for abstract methods ----------------------- /** Creates the default continuous distribution instance to use in tests. */ public ContinuousDistribution makeDistribution() { return new ExponentialDistributionImpl(5.0); } /** Creates the default cumulative probability distribution test input values */ public double[] makeCumulativeTestPoints() { // quantiles computed using R version 1.8.1 (linux version) return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d, 34.53878d, 23.02585d, 18.44440d, 14.97866d, 11.51293d}; } /** Creates the default cumulative probability density test expected values */ public double[] makeCumulativeTestValues() { return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d, 0.990d, 0.975d, 0.950d, 0.900d}; } //------------ Additional tests ------------------------------------------- public void testCumulativeProbabilityExtremes() throws Exception { setCumulativeTestPoints(new double[] {-2, 0}); setCumulativeTestValues(new double[] {0, 0}); verifyCumulativeProbabilities(); } public void testInverseCumulativeProbabilityExtremes() throws Exception { setInverseCumulativeTestPoints(new double[] {0, 1}); setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY}); verifyInverseCumulativeProbabilities(); } public void testCumulativeProbability2() throws Exception { double actual = getDistribution().cumulativeProbability(0.25, 0.75); assertEquals(0.0905214, actual, 10e-4); } public void testDensity() throws MathException { ExponentialDistribution d1 = new ExponentialDistributionImpl(1); assertEquals(0.0, d1.density(-1e-9)); assertEquals(1.0, d1.density(0.0)); assertEquals(0.0, d1.density(1000.0)); assertEquals(Math.exp(-1), d1.density(1.0)); assertEquals(Math.exp(-2), d1.density(2.0)); ExponentialDistribution d2 = new ExponentialDistributionImpl(3); assertEquals(1/3.0, d2.density(0.0)); // computed using print(dexp(1, rate=1/3), digits=10) in R 2.5 assertEquals(0.2388437702, d2.density(1.0), 1e-8); // computed using print(dexp(2, rate=1/3), digits=10) in R 2.5 assertEquals(0.1711390397, d2.density(2.0), 1e-8); } public void testMeanAccessors() { ExponentialDistribution distribution = (ExponentialDistribution) getDistribution(); assertEquals(5d, distribution.getMean(), Double.MIN_VALUE); distribution.setMean(2d); assertEquals(2d, distribution.getMean(), Double.MIN_VALUE); try { distribution.setMean(0); fail("Expecting IllegalArgumentException for 0 mean"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.estimation; import java.util.ArrayList; import java.util.HashSet; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class GaussNewtonEstimatorTest extends TestCase { public GaussNewtonEstimatorTest(String name) { super(name); } public void testTrivial() throws EstimationException { LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { new EstimatedParameter("p0", 0) }, 3.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals(1.5, problem.getUnboundParameters()[0].getEstimate(), 1.0e-10); } public void testQRColumnsPermutation() throws EstimationException { EstimatedParameter[] x = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { x[0], x[1] }, 4.0), new LinearMeasurement(new double[] { 2.0 }, new EstimatedParameter[] { x[1] }, 6.0), new LinearMeasurement(new double[] { 1.0, -2.0 }, new EstimatedParameter[] { x[0], x[1] }, 1.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals(7.0, x[0].getEstimate(), 1.0e-10); assertEquals(3.0, x[1].getEstimate(), 1.0e-10); } public void testNoDependency() throws EstimationException { EstimatedParameter[] p = new EstimatedParameter[] { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0), new EstimatedParameter("p2", 0), new EstimatedParameter("p3", 0), new EstimatedParameter("p4", 0), new EstimatedParameter("p5", 0) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); for (int i = 0; i < p.length; ++i) { assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10); } } public void testOneSet() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0), new EstimatedParameter("p2", 0) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0 }, new EstimatedParameter[] { p[0] }, 1.0), new LinearMeasurement(new double[] { -1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1] }, 1.0), new LinearMeasurement(new double[] { -1.0, 1.0 }, new EstimatedParameter[] { p[1], p[2] }, 1.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals(1.0, p[0].getEstimate(), 1.0e-10); assertEquals(2.0, p[1].getEstimate(), 1.0e-10); assertEquals(3.0, p[2].getEstimate(), 1.0e-10); } public void testTwoSets() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 1), new EstimatedParameter("p2", 2), new EstimatedParameter("p3", 3), new EstimatedParameter("p4", 4), new EstimatedParameter("p5", 5) }; double epsilon = 1.0e-7; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { // 4 elements sub-problem new LinearMeasurement(new double[] { 2.0, 1.0, 4.0 }, new EstimatedParameter[] { p[0], p[1], p[3] }, 2.0), new LinearMeasurement(new double[] { -4.0, -2.0, 3.0, -7.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, -9.0), new LinearMeasurement(new double[] { 4.0, 1.0, -2.0, 8.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 2.0), new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 }, new EstimatedParameter[] { p[1], p[2], p[3] }, 2.0), // 2 elements sub-problem new LinearMeasurement(new double[] { epsilon, 1.0 }, new EstimatedParameter[] { p[4], p[5] }, 1.0 + epsilon * epsilon), new LinearMeasurement(new double[] { 1.0, 1.0 }, new EstimatedParameter[] { p[4], p[5] }, 2.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals( 3.0, p[0].getEstimate(), 1.0e-10); assertEquals( 4.0, p[1].getEstimate(), 1.0e-10); assertEquals(-1.0, p[2].getEstimate(), 1.0e-10); assertEquals(-2.0, p[3].getEstimate(), 1.0e-10); assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10); assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10); } public void testNonInversible() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0), new EstimatedParameter("p2", 0) }; LinearMeasurement[] m = new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 2.0, -3.0 }, new EstimatedParameter[] { p[0], p[1], p[2] }, 1.0), new LinearMeasurement(new double[] { 2.0, 1.0, 3.0 }, new EstimatedParameter[] { p[0], p[1], p[2] }, 1.0), new LinearMeasurement(new double[] { -3.0, -9.0 }, new EstimatedParameter[] { p[0], p[2] }, 1.0) }; LinearProblem problem = new LinearProblem(m); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); try { estimator.estimate(problem); fail("an exception should have been caught"); } catch (EstimationException ee) { // expected behavior } catch (Exception e) { fail("wrong exception type caught"); } } public void testIllConditioned() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 1), new EstimatedParameter("p2", 2), new EstimatedParameter("p3", 3) }; LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 10.0, 7.0, 8.0, 7.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 32.0), new LinearMeasurement(new double[] { 7.0, 5.0, 6.0, 5.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 23.0), new LinearMeasurement(new double[] { 8.0, 6.0, 10.0, 9.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 33.0), new LinearMeasurement(new double[] { 7.0, 5.0, 9.0, 10.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 31.0) }); GaussNewtonEstimator estimator1 = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator1.estimate(problem1); assertEquals(0, estimator1.getRMS(problem1), 1.0e-10); assertEquals(1.0, p[0].getEstimate(), 1.0e-10); assertEquals(1.0, p[1].getEstimate(), 1.0e-10); assertEquals(1.0, p[2].getEstimate(), 1.0e-10); assertEquals(1.0, p[3].getEstimate(), 1.0e-10); LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 10.0, 7.0, 8.1, 7.2 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 32.0), new LinearMeasurement(new double[] { 7.08, 5.04, 6.0, 5.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 23.0), new LinearMeasurement(new double[] { 8.0, 5.98, 9.89, 9.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 33.0), new LinearMeasurement(new double[] { 6.99, 4.99, 9.0, 9.98 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 31.0) }); GaussNewtonEstimator estimator2 = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator2.estimate(problem2); assertEquals(0, estimator2.getRMS(problem2), 1.0e-10); assertEquals(-81.0, p[0].getEstimate(), 1.0e-8); assertEquals(137.0, p[1].getEstimate(), 1.0e-8); assertEquals(-34.0, p[2].getEstimate(), 1.0e-8); assertEquals( 22.0, p[3].getEstimate(), 1.0e-8); } public void testMoreEstimatedParametersSimple() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 7), new EstimatedParameter("p1", 6), new EstimatedParameter("p2", 5), new EstimatedParameter("p3", 4) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 3.0, 2.0 }, new EstimatedParameter[] { p[0], p[1] }, 7.0), new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 }, new EstimatedParameter[] { p[1], p[2], p[3] }, 3.0), new LinearMeasurement(new double[] { 2.0, 1.0 }, new EstimatedParameter[] { p[0], p[2] }, 5.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); try { estimator.estimate(problem); fail("an exception should have been caught"); } catch (EstimationException ee) { // expected behavior } catch (Exception e) { fail("wrong exception type caught"); } } public void testMoreEstimatedParametersUnsorted() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 2), new EstimatedParameter("p1", 2), new EstimatedParameter("p2", 2), new EstimatedParameter("p3", 2), new EstimatedParameter("p4", 2), new EstimatedParameter("p5", 2) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1] }, 3.0), new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 }, new EstimatedParameter[] { p[2], p[3], p[4] }, 12.0), new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { p[4], p[5] }, -1.0), new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 }, new EstimatedParameter[] { p[3], p[2], p[5] }, 7.0), new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { p[4], p[3] }, 1.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); try { estimator.estimate(problem); fail("an exception should have been caught"); } catch (EstimationException ee) { // expected behavior } catch (Exception e) { fail("wrong exception type caught"); } } public void testRedundantEquations() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 1), new EstimatedParameter("p1", 1) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1] }, 3.0), new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { p[0], p[1] }, 1.0), new LinearMeasurement(new double[] { 1.0, 3.0 }, new EstimatedParameter[] { p[0], p[1] }, 5.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); EstimatedParameter[] all = problem.getAllParameters(); for (int i = 0; i < all.length; ++i) { assertEquals(all[i].getName().equals("p0") ? 2.0 : 1.0, all[i].getEstimate(), 1.0e-10); } } public void testInconsistentEquations() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 1), new EstimatedParameter("p1", 1) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1] }, 3.0), new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { p[0], p[1] }, 1.0), new LinearMeasurement(new double[] { 1.0, 3.0 }, new EstimatedParameter[] { p[0], p[1] }, 4.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator.estimate(problem); assertTrue(estimator.getRMS(problem) > 0.1); } public void testBoundParameters() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("unbound0", 2, false), new EstimatedParameter("unbound1", 2, false), new EstimatedParameter("bound", 2, true) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1], p[2] }, 3.0), new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1], p[2] }, 1.0), new LinearMeasurement(new double[] { 1.0, 3.0, 2.0 }, new EstimatedParameter[] { p[0], p[1], p[2] }, 7.0) }); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); estimator.estimate(problem); assertTrue(estimator.getRMS(problem) < 1.0e-10); double[][] covariances = estimator.getCovariances(problem); int i0 = 0, i1 = 1; if (problem.getUnboundParameters()[0].getName().endsWith("1")) { i0 = 1; i1 = 0; } assertEquals(11.0 / 24, covariances[i0][i0], 1.0e-10); assertEquals(-3.0 / 24, covariances[i0][i1], 1.0e-10); assertEquals(-3.0 / 24, covariances[i1][i0], 1.0e-10); assertEquals( 3.0 / 24, covariances[i1][i1], 1.0e-10); double[] errors = estimator.guessParametersErrors(problem); assertEquals(0, errors[i0], 1.0e-10); assertEquals(0, errors[i1], 1.0e-10); } public void testMaxIterations() { Circle circle = new Circle(98.680, 47.345); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); try { GaussNewtonEstimator estimator = new GaussNewtonEstimator(4, 1.0e-14, 1.0e-14); estimator.estimate(circle); fail("an exception should have been caught"); } catch (EstimationException ee) { // expected behavior } catch (Exception e) { fail("wrong exception type caught"); } } public void testCircleFitting() throws EstimationException { Circle circle = new Circle(98.680, 47.345); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-10, 1.0e-10); estimator.estimate(circle); double rms = estimator.getRMS(circle); assertEquals(1.768262623567235, Math.sqrt(circle.getM()) * rms, 1.0e-10); assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10); assertEquals(96.07590211815305, circle.getX(), 1.0e-10); assertEquals(48.13516790438953, circle.getY(), 1.0e-10); } public void testCircleFittingBadInit() throws EstimationException { Circle circle = new Circle(-12, -12); double[][] points = new double[][] { {-0.312967, 0.072366}, {-0.339248, 0.132965}, {-0.379780, 0.202724}, {-0.390426, 0.260487}, {-0.361212, 0.328325}, {-0.346039, 0.392619}, {-0.280579, 0.444306}, {-0.216035, 0.470009}, {-0.149127, 0.493832}, {-0.075133, 0.483271}, {-0.007759, 0.452680}, { 0.060071, 0.410235}, { 0.103037, 0.341076}, { 0.118438, 0.273884}, { 0.131293, 0.192201}, { 0.115869, 0.129797}, { 0.072223, 0.058396}, { 0.022884, 0.000718}, {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862}, {-0.278592, -0.005008}, {-0.337655, 0.056658}, {-0.385899, 0.112526}, {-0.405517, 0.186957}, {-0.415374, 0.262071}, {-0.387482, 0.343398}, {-0.347322, 0.397943}, {-0.287623, 0.458425}, {-0.223502, 0.475513}, {-0.135352, 0.478186}, {-0.061221, 0.483371}, { 0.003711, 0.422737}, { 0.065054, 0.375830}, { 0.108108, 0.297099}, { 0.123882, 0.222850}, { 0.117729, 0.134382}, { 0.085195, 0.056820}, { 0.029800, -0.019138}, {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578}, {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561, 0.014926}, {-0.471036, 0.074716}, {-0.488638, 0.182508}, {-0.485990, 0.254068}, {-0.463943, 0.338438}, {-0.406453, 0.404704}, {-0.334287, 0.466119}, {-0.254244, 0.503188}, {-0.161548, 0.495769}, {-0.075733, 0.495560}, { 0.001375, 0.434937}, { 0.082787, 0.385806}, { 0.115490, 0.323807}, { 0.141089, 0.223450}, { 0.138693, 0.131703}, { 0.126415, 0.049174}, { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635}, {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251}, {-0.405195, -0.000895}, {-0.444937, 0.085456}, {-0.484357, 0.175597}, {-0.472453, 0.248681}, {-0.438580, 0.347463}, {-0.402304, 0.422428}, {-0.326777, 0.479438}, {-0.247797, 0.505581}, {-0.152676, 0.519380}, {-0.071754, 0.516264}, { 0.015942, 0.472802}, { 0.076608, 0.419077}, { 0.127673, 0.330264}, { 0.159951, 0.262150}, { 0.153530, 0.172681}, { 0.140653, 0.089229}, { 0.078666, 0.024981}, { 0.023807, -0.037022}, {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526} }; for (int i = 0; i < points.length; ++i) { circle.addPoint(points[i][0], points[i][1]); } GaussNewtonEstimator estimator = new GaussNewtonEstimator(100, 1.0e-6, 1.0e-6); try { estimator.estimate(circle); fail("an exception should have been caught"); } catch (EstimationException ee) { // expected behavior } catch (Exception e) { fail("wrong exception type caught"); } } private static class LinearProblem extends SimpleEstimationProblem { public LinearProblem(LinearMeasurement[] measurements) { HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>(); for (int i = 0; i < measurements.length; ++i) { addMeasurement(measurements[i]); EstimatedParameter[] parameters = measurements[i].getParameters(); for (int j = 0; j < parameters.length; ++j) { set.add(parameters[j]); } } for (EstimatedParameter p : set) { addParameter(p); } } } private static class LinearMeasurement extends WeightedMeasurement { public LinearMeasurement(double[] factors, EstimatedParameter[] parameters, double setPoint) { super(1.0, setPoint, true); this.factors = factors; this.parameters = parameters; setIgnored(false); } public double getTheoreticalValue() { double v = 0; for (int i = 0; i < factors.length; ++i) { v += factors[i] * parameters[i].getEstimate(); } return v; } public double getPartial(EstimatedParameter parameter) { for (int i = 0; i < parameters.length; ++i) { if (parameters[i] == parameter) { return factors[i]; } } return 0; } public EstimatedParameter[] getParameters() { return parameters; } private double[] factors; private EstimatedParameter[] parameters; private static final long serialVersionUID = -3922448707008868580L; } private static class Circle implements EstimationProblem { public Circle(double cx, double cy) { this.cx = new EstimatedParameter("cx", cx); this.cy = new EstimatedParameter(new EstimatedParameter("cy", cy)); points = new ArrayList<PointModel>(); } public void addPoint(double px, double py) { points.add(new PointModel(px, py)); } public int getM() { return points.size(); } public WeightedMeasurement[] getMeasurements() { return (WeightedMeasurement[]) points.toArray(new PointModel[points.size()]); } public EstimatedParameter[] getAllParameters() { return new EstimatedParameter[] { cx, cy }; } public EstimatedParameter[] getUnboundParameters() { return new EstimatedParameter[] { cx, cy }; } public double getPartialRadiusX() { double dRdX = 0; for (PointModel point : points) { dRdX += point.getPartialDiX(); } return dRdX / points.size(); } public double getPartialRadiusY() { double dRdY = 0; for (PointModel point : points) { dRdY += point.getPartialDiY(); } return dRdY / points.size(); } public double getRadius() { double r = 0; for (PointModel point : points) { r += point.getCenterDistance(); } return r / points.size(); } public double getX() { return cx.getEstimate(); } public double getY() { return cy.getEstimate(); } private class PointModel extends WeightedMeasurement { public PointModel(double px, double py) { super(1.0, 0.0); this.px = px; this.py = py; } public double getPartial(EstimatedParameter parameter) { if (parameter == cx) { return getPartialDiX() - getPartialRadiusX(); } else if (parameter == cy) { return getPartialDiY() - getPartialRadiusY(); } return 0; } public double getCenterDistance() { double dx = px - cx.getEstimate(); double dy = py - cy.getEstimate(); return Math.sqrt(dx * dx + dy * dy); } public double getPartialDiX() { return (cx.getEstimate() - px) / getCenterDistance(); } public double getPartialDiY() { return (cy.getEstimate() - py) / getCenterDistance(); } public double getTheoreticalValue() { return getCenterDistance() - getRadius(); } private double px; private double py; private static final long serialVersionUID = 1L; } private EstimatedParameter cx; private EstimatedParameter cy; private ArrayList<PointModel> points; } public static Test suite() { return new TestSuite(GaussNewtonEstimatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.estimation; import org.apache.commons.math.estimation.EstimatedParameter; import junit.framework.*; public class EstimatedParameterTest extends TestCase { public EstimatedParameterTest(String name) { super(name); } public void testConstruction() { EstimatedParameter p1 = new EstimatedParameter("p1", 1.0); assertTrue(p1.getName().equals("p1")); checkValue(p1.getEstimate(), 1.0); assertTrue(! p1.isBound()); EstimatedParameter p2 = new EstimatedParameter("p2", 2.0, true); assertTrue(p2.getName().equals("p2")); checkValue(p2.getEstimate(), 2.0); assertTrue(p2.isBound()); } public void testBound() { EstimatedParameter p = new EstimatedParameter("p", 0.0); assertTrue(! p.isBound()); p.setBound(true); assertTrue(p.isBound()); p.setBound(false); assertTrue(! p.isBound()); } public void testEstimate() { EstimatedParameter p = new EstimatedParameter("p", 0.0); checkValue(p.getEstimate(), 0.0); for (double e = 0.0; e < 10.0; e += 0.5) { p.setEstimate(e); checkValue(p.getEstimate(), e); } } public static Test suite() { return new TestSuite(EstimatedParameterTest.class); } private void checkValue(double value, double expected) { assertTrue(Math.abs(value - expected) < 1.0e-10); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.estimation; import java.util.Arrays; import org.apache.commons.math.estimation.EstimatedParameter; import org.apache.commons.math.estimation.EstimationException; import org.apache.commons.math.estimation.EstimationProblem; import org.apache.commons.math.estimation.LevenbergMarquardtEstimator; import org.apache.commons.math.estimation.WeightedMeasurement; import junit.framework.*; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class MinpackTest extends TestCase { public MinpackTest(String name) { super(name); } public void testMinpackLinearFullRank() throws EstimationException { minpackTest(new LinearFullRankFunction(10, 5, 1.0, 5.0, 2.23606797749979), false); minpackTest(new LinearFullRankFunction(50, 5, 1.0, 8.06225774829855, 6.70820393249937), false); } public void testMinpackLinearRank1() throws EstimationException { minpackTest(new LinearRank1Function(10, 5, 1.0, 291.521868819476, 1.4638501094228), false); minpackTest(new LinearRank1Function(50, 5, 1.0, 3101.60039334535, 3.48263016573496), false); } public void testMinpackLinearRank1ZeroColsAndRows() throws EstimationException { minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false); minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false); } public void testMinpackRosenbrok() throws EstimationException { minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 }, Math.sqrt(24.2)), false); minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 }, Math.sqrt(1795769.0)), false); minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 }, 11.0 * Math.sqrt(169000121.0)), false); } public void testMinpackHelicalValley() throws EstimationException { minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 }, 50.0), false); minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 }, 102.95630140987), false); minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0}, 991.261822123701), false); } public void testMinpackPowellSingular() throws EstimationException { minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 }, 14.6628782986152), false); minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 }, 1270.9838708654), false); minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 }, 126887.903284750), false); } public void testMinpackFreudensteinRoth() throws EstimationException { minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 }, 20.0124960961895, 6.99887517584575, new double[] { 11.4124844654993, -0.896827913731509 }), false); minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 }, 12432.833948863, 6.9988751744895, new double[] { 11.4130046614746, -0.896796038685958 }), false); minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 }, 11426454.595762, 6.99887517242903, new double[] { 11.4127817857886, -0.89680510749204 }), false); } public void testMinpackBard() throws EstimationException { minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466, new double[] { 0.0824105765758334, 1.1330366534715, 2.34369463894115 }), false); minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539, new double[] { 0.840666673818329, -158848033.259565, -164378671.653535 }), false); minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969, new double[] { 0.840666673867645, -158946167.205518, -164464906.857771 }), false); } public void testMinpackKowalikOsborne() throws EstimationException { minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 }, 0.0728915102882945, 0.017535837721129, new double[] { 0.192807810476249, 0.191262653354071, 0.123052801046931, 0.136053221150517 }), false); minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 }, 2.97937007555202, 0.032052192917937, new double[] { 728675.473768287, -14.0758803129393, -32977797.7841797, -20571594.1977912 }), false); minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 }, 29.9590617016037, 0.0175364017658228, new double[] { 0.192948328597594, 0.188053165007911, 0.122430604321144, 0.134575665392506 }), true); } public void testMinpackMeyer() throws EstimationException { minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 }, 41153.4665543031, 9.37794514651874, new double[] { 0.00560963647102661, 6181.34634628659, 345.223634624144 }), false); minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 }, 4168216.89130846, 792.917871779501, new double[] { 1.42367074157994e-11, 33695.7133432541, 901.268527953801 }), true); } public void testMinpackWatson() throws EstimationException { minpackTest(new WatsonFunction(6, 0.0, 5.47722557505166, 0.0478295939097601, new double[] { -0.0157249615083782, 1.01243488232965, -0.232991722387673, 1.26043101102818, -1.51373031394421, 0.99299727291842 }), false); minpackTest(new WatsonFunction(6, 10.0, 6433.12578950026, 0.0478295939096951, new double[] { -0.0157251901386677, 1.01243485860105, -0.232991545843829, 1.26042932089163, -1.51372776706575, 0.99299573426328 }), false); minpackTest(new WatsonFunction(6, 100.0, 674256.040605213, 0.047829593911544, new double[] { -0.0157247019712586, 1.01243490925658, -0.232991922761641, 1.26043292929555, -1.51373320452707, 0.99299901922322 }), false); minpackTest(new WatsonFunction(9, 0.0, 5.47722557505166, 0.00118311459212420, new double[] { -0.153070644166722e-4, 0.999789703934597, 0.0147639634910978, 0.146342330145992, 1.00082109454817, -2.61773112070507, 4.10440313943354, -3.14361226236241, 1.05262640378759 }), false); minpackTest(new WatsonFunction(9, 10.0, 12088.127069307, 0.00118311459212513, new double[] { -0.153071334849279e-4, 0.999789703941234, 0.0147639629786217, 0.146342334818836, 1.00082107321386, -2.61773107084722, 4.10440307655564, -3.14361222178686, 1.05262639322589 }), false); minpackTest(new WatsonFunction(9, 100.0, 1269109.29043834, 0.00118311459212384, new double[] { -0.153069523352176e-4, 0.999789703958371, 0.0147639625185392, 0.146342341096326, 1.00082104729164, -2.61773101573645, 4.10440301427286, -3.14361218602503, 1.05262638516774 }), false); minpackTest(new WatsonFunction(12, 0.0, 5.47722557505166, 0.217310402535861e-4, new double[] { -0.660266001396382e-8, 1.00000164411833, -0.000563932146980154, 0.347820540050756, -0.156731500244233, 1.05281515825593, -3.24727109519451, 7.2884347837505, -10.271848098614, 9.07411353715783, -4.54137541918194, 1.01201187975044 }), false); minpackTest(new WatsonFunction(12, 10.0, 19220.7589790951, 0.217310402518509e-4, new double[] { -0.663710223017410e-8, 1.00000164411787, -0.000563932208347327, 0.347820540486998, -0.156731503955652, 1.05281517654573, -3.2472711515214, 7.28843489430665, -10.2718482369638, 9.07411364383733, -4.54137546533666, 1.01201188830857 }), false); minpackTest(new WatsonFunction(12, 100.0, 2018918.04462367, 0.217310402539845e-4, new double[] { -0.663806046485249e-8, 1.00000164411786, -0.000563932210324959, 0.347820540503588, -0.156731504091375, 1.05281517718031, -3.24727115337025, 7.28843489775302, -10.2718482410813, 9.07411364688464, -4.54137546660822, 1.0120118885369 }), false); } public void testMinpackBox3Dimensional() throws EstimationException { minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 }, 32.1115837449572), false); } public void testMinpackJennrichSampson() throws EstimationException { minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 }, 64.5856498144943, 11.1517793413499, new double[] { 0.257819926636811, 0.257829976764542 }), false); } public void testMinpackBrownDennis() throws EstimationException { minpackTest(new BrownDennisFunction(20, new double[] { 25.0, 5.0, -5.0, -1.0 }, 2815.43839161816, 292.954288244866, new double[] { -11.59125141003, 13.2024883984741, -0.403574643314272, 0.236736269844604 }), false); minpackTest(new BrownDennisFunction(20, new double[] { 250.0, 50.0, -50.0, -10.0 }, 555073.354173069, 292.954270581415, new double[] { -11.5959274272203, 13.2041866926242, -0.403417362841545, 0.236771143410386 }), false); minpackTest(new BrownDennisFunction(20, new double[] { 2500.0, 500.0, -500.0, -100.0 }, 61211252.2338581, 292.954306151134, new double[] { -11.5902596937374, 13.2020628854665, -0.403688070279258, 0.236665033746463 }), false); } public void testMinpackChebyquad() throws EstimationException { minpackTest(new ChebyquadFunction(1, 8, 1.0, 1.88623796907732, 1.88623796907732, new double[] { 0.5 }), false); minpackTest(new ChebyquadFunction(1, 8, 10.0, 5383344372.34005, 1.88424820499951, new double[] { 0.9817314924684 }), false); minpackTest(new ChebyquadFunction(1, 8, 100.0, 0.118088726698392e19, 1.88424820499347, new double[] { 0.9817314852934 }), false); minpackTest(new ChebyquadFunction(8, 8, 1.0, 0.196513862833975, 0.0593032355046727, new double[] { 0.0431536648587336, 0.193091637843267, 0.266328593812698, 0.499999334628884, 0.500000665371116, 0.733671406187302, 0.806908362156733, 0.956846335141266 }), false); minpackTest(new ChebyquadFunction(9, 9, 1.0, 0.16994993465202, 0.0, new double[] { 0.0442053461357828, 0.199490672309881, 0.23561910847106, 0.416046907892598, 0.5, 0.583953092107402, 0.764380891528940, 0.800509327690119, 0.955794653864217 }), false); minpackTest(new ChebyquadFunction(10, 10, 1.0, 0.183747831178711, 0.0806471004038253, new double[] { 0.0596202671753563, 0.166708783805937, 0.239171018813509, 0.398885290346268, 0.398883667870681, 0.601116332129320, 0.60111470965373, 0.760828981186491, 0.833291216194063, 0.940379732824644 }), false); } public void testMinpackBrownAlmostLinear() throws EstimationException { minpackTest(new BrownAlmostLinearFunction(10, 0.5, 16.5302162063499, 0.0, new double[] { 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 0.979430303349862, 1.20569696650138 }), false); minpackTest(new BrownAlmostLinearFunction(10, 5.0, 9765624.00089211, 0.0, new double[] { 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 0.979430303349865, 1.20569696650135 }), false); minpackTest(new BrownAlmostLinearFunction(10, 50.0, 0.9765625e17, 0.0, new double[] { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }), false); minpackTest(new BrownAlmostLinearFunction(30, 0.5, 83.476044467848, 0.0, new double[] { 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 0.997754216442807, 1.06737350671578 }), false); minpackTest(new BrownAlmostLinearFunction(40, 0.5, 128.026364472323, 0.0, new double[] { 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 1.00000000000002, 0.999999999999121 }), false); } public void testMinpackOsborne1() throws EstimationException { minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, }, 0.937564021037838, 0.00739249260904843, new double[] { 0.375410049244025, 1.93584654543108, -1.46468676748716, 0.0128675339110439, 0.0221227011813076 }), false); } public void testMinpackOsborne2() throws EstimationException { minpackTest(new Osborne2Function(new double[] { 1.3, 0.65, 0.65, 0.7, 0.6, 3.0, 5.0, 7.0, 2.0, 4.5, 5.5 }, 1.44686540984712, 0.20034404483314, new double[] { 1.30997663810096, 0.43155248076, 0.633661261602859, 0.599428560991695, 0.754179768272449, 0.904300082378518, 1.36579949521007, 4.82373199748107, 2.39868475104871, 4.56887554791452, 5.67534206273052 }), false); } private void minpackTest(MinpackFunction function, boolean exceptionExpected) { LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.setMaxCostEval(100 * (function.getN() + 1)); estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16)); estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16)); estimator.setOrthoTolerance(2.22044604926e-16); assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function))); try { estimator.estimate(function); assertFalse(exceptionExpected); } catch (EstimationException lsse) { assertTrue(exceptionExpected); } assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function))); assertTrue(function.checkTheoreticalMinParams()); } private static abstract class MinpackFunction implements EstimationProblem { protected MinpackFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { this.m = m; this.n = startParams.length; parameters = new EstimatedParameter[n]; for (int i = 0; i < n; ++i) { parameters[i] = new EstimatedParameter("p" + i, startParams[i]); } this.theoreticalStartCost = theoreticalStartCost; this.theoreticalMinCost = theoreticalMinCost; this.theoreticalMinParams = theoreticalMinParams; this.costAccuracy = 1.0e-8; this.paramsAccuracy = 1.0e-5; } protected static double[] buildArray(int n, double x) { double[] array = new double[n]; Arrays.fill(array, x); return array; } protected void setCostAccuracy(double costAccuracy) { this.costAccuracy = costAccuracy; } protected void setParamsAccuracy(double paramsAccuracy) { this.paramsAccuracy = paramsAccuracy; } public int getN() { return parameters.length; } public boolean checkTheoreticalStartCost(double rms) { double threshold = costAccuracy * (1.0 + theoreticalStartCost); return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold; } public boolean checkTheoreticalMinCost(double rms) { double threshold = costAccuracy * (1.0 + theoreticalMinCost); return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold; } public boolean checkTheoreticalMinParams() { if (theoreticalMinParams != null) { for (int i = 0; i < theoreticalMinParams.length; ++i) { double mi = theoreticalMinParams[i]; double vi = parameters[i].getEstimate(); if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) { return false; } } } return true; } public WeightedMeasurement[] getMeasurements() { WeightedMeasurement[] measurements = new WeightedMeasurement[m]; for (int i = 0; i < m; ++i) { measurements[i] = new MinpackMeasurement(i); } return measurements; } public EstimatedParameter[] getUnboundParameters() { return parameters; } public EstimatedParameter[] getAllParameters() { return parameters; } protected abstract double[][] getJacobian(); protected abstract double[] getResiduals(); private class MinpackMeasurement extends WeightedMeasurement { public MinpackMeasurement(int index) { super(1.0, 0.0); this.index = index; } public double getTheoreticalValue() { // this is obviously NOT efficient as we recompute the whole vector // each time we need only one element, but it is only for test // purposes and is simpler to check. // This implementation should NOT be taken as an example, it is ugly! return getResiduals()[index]; } public double getPartial(EstimatedParameter parameter) { // this is obviously NOT efficient as we recompute the whole jacobian // each time we need only one element, but it is only for test // purposes and is simpler to check. // This implementation should NOT be taken as an example, it is ugly! for (int j = 0; j < n; ++j) { if (parameter == parameters[j]) { return getJacobian()[index][j]; } } return 0; } private int index; private static final long serialVersionUID = 1L; } protected int n; protected int m; protected EstimatedParameter[] parameters; protected double theoreticalStartCost; protected double theoreticalMinCost; protected double[] theoreticalMinParams; protected double costAccuracy; protected double paramsAccuracy; } private static class LinearFullRankFunction extends MinpackFunction { public LinearFullRankFunction(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, buildArray(n, -1.0)); } protected double[][] getJacobian() { double t = 2.0 / m; double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = (i == j) ? (1 - t) : -t; } } return jacobian; } protected double[] getResiduals() { double sum = 0; for (int i = 0; i < n; ++i) { sum += parameters[i].getEstimate(); } double t = 1 + 2 * sum / m; double[] f = new double[m]; for (int i = 0; i < n; ++i) { f[i] = parameters[i].getEstimate() - t; } Arrays.fill(f, n, m, -t); return f; } } private static class LinearRank1Function extends MinpackFunction { public LinearRank1Function(int m, int n, double x0, double theoreticalStartCost, double theoreticalMinCost) { super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null); } protected double[][] getJacobian() { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = (i + 1) * (j + 1); } } return jacobian; } protected double[] getResiduals() { double[] f = new double[m]; double sum = 0; for (int i = 0; i < n; ++i) { sum += (i + 1) * parameters[i].getEstimate(); } for (int i = 0; i < m; ++i) { f[i] = (i + 1) * sum - 1; } return f; } } private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction { public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) { super(m, buildArray(n, x0), Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0), Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))), null); } protected double[][] getJacobian() { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; jacobian[i][0] = 0; for (int j = 1; j < (n - 1); ++j) { if (i == 0) { jacobian[i][j] = 0; } else if (i != (m - 1)) { jacobian[i][j] = i * (j + 1); } else { jacobian[i][j] = 0; } } jacobian[i][n - 1] = 0; } return jacobian; } protected double[] getResiduals() { double[] f = new double[m]; double sum = 0; for (int i = 1; i < (n - 1); ++i) { sum += (i + 1) * parameters[i].getEstimate(); } for (int i = 0; i < (m - 1); ++i) { f[i] = i * sum - 1; } f[m - 1] = -1; return f; } } private static class RosenbrockFunction extends MinpackFunction { public RosenbrockFunction(double[] startParams, double theoreticalStartCost) { super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0)); } protected double[][] getJacobian() { double x1 = parameters[0].getEstimate(); return new double[][] { { -20 * x1, 10 }, { -1, 0 } }; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); return new double[] { 10 * (x2 - x1 * x1), 1 - x1 }; } } private static class HelicalValleyFunction extends MinpackFunction { public HelicalValleyFunction(double[] startParams, double theoreticalStartCost) { super(3, startParams, theoreticalStartCost, 0.0, new double[] { 1.0, 0.0, 0.0 }); } protected double[][] getJacobian() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double tmpSquare = x1 * x1 + x2 * x2; double tmp1 = twoPi * tmpSquare; double tmp2 = Math.sqrt(tmpSquare); return new double[][] { { 100 * x2 / tmp1, -100 * x1 / tmp1, 10 }, { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 }, { 0, 0, 1 } }; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double tmp1; if (x1 == 0) { tmp1 = (x2 >= 0) ? 0.25 : -0.25; } else { tmp1 = Math.atan(x2 / x1) / twoPi; if (x1 < 0) { tmp1 += 0.5; } } double tmp2 = Math.sqrt(x1 * x1 + x2 * x2); return new double[] { 10.0 * (x3 - 10 * tmp1), 10.0 * (tmp2 - 1), x3 }; } private static final double twoPi = 2.0 * Math.PI; } private static class PowellSingularFunction extends MinpackFunction { public PowellSingularFunction(double[] startParams, double theoreticalStartCost) { super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0)); } protected double[][] getJacobian() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double x4 = parameters[3].getEstimate(); return new double[][] { { 1, 10, 0, 0 }, { 0, 0, sqrt5, -sqrt5 }, { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 }, { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) } }; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double x4 = parameters[3].getEstimate(); return new double[] { x1 + 10 * x2, sqrt5 * (x3 - x4), (x2 - 2 * x3) * (x2 - 2 * x3), sqrt10 * (x1 - x4) * (x1 - x4) }; } private static final double sqrt5 = Math.sqrt( 5.0); private static final double sqrt10 = Math.sqrt(10.0); } private static class FreudensteinRothFunction extends MinpackFunction { public FreudensteinRothFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(2, startParams, theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double x2 = parameters[1].getEstimate(); return new double[][] { { 1, x2 * (10 - 3 * x2) - 2 }, { 1, x2 * ( 2 + 3 * x2) - 14, } }; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); return new double[] { -13.0 + x1 + ((5.0 - x2) * x2 - 2.0) * x2, -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2 }; } } private static class BardFunction extends MinpackFunction { public BardFunction(double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(15, buildArray(3, x0), theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp1 = i + 1; double tmp2 = 15 - i; double tmp3 = (i <= 7) ? tmp1 : tmp2; double tmp4 = x2 * tmp2 + x3 * tmp3; tmp4 *= tmp4; jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 }; } return jacobian; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double[] f = new double[m]; for (int i = 0; i < m; ++i) { double tmp1 = i + 1; double tmp2 = 15 - i; double tmp3 = (i <= 7) ? tmp1 : tmp2; f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3)); } return f; } private static final double[] y = { 0.14, 0.18, 0.22, 0.25, 0.29, 0.32, 0.35, 0.39, 0.37, 0.58, 0.73, 0.96, 1.34, 2.10, 4.39 }; } private static class KowalikOsborneFunction extends MinpackFunction { public KowalikOsborneFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(11, startParams, theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); if (theoreticalStartCost > 20.0) { setCostAccuracy(2.0e-4); setParamsAccuracy(5.0e-3); } } protected double[][] getJacobian() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double x4 = parameters[3].getEstimate(); double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp = v[i] * (v[i] + x3) + x4; double j1 = -v[i] * (v[i] + x2) / tmp; double j2 = -v[i] * x1 / tmp; double j3 = j1 * j2; double j4 = j3 / v[i]; jacobian[i] = new double[] { j1, j2, j3, j4 }; } return jacobian; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double x4 = parameters[3].getEstimate(); double[] f = new double[m]; for (int i = 0; i < m; ++i) { f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4); } return f; } private static final double[] v = { 4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625 }; private static final double[] y = { 0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627, 0.0456, 0.0342, 0.0323, 0.0235, 0.0246 }; } private static class MeyerFunction extends MinpackFunction { public MeyerFunction(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(16, startParams, theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); if (theoreticalStartCost > 1.0e6) { setCostAccuracy(7.0e-3); setParamsAccuracy(2.0e-2); } } protected double[][] getJacobian() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = 5.0 * (i + 1) + 45.0 + x3; double tmp1 = x2 / temp; double tmp2 = Math.exp(tmp1); double tmp3 = x1 * tmp2 / temp; jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 }; } return jacobian; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double[] f = new double[m]; for (int i = 0; i < m; ++i) { f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i]; } return f; } private static final double[] y = { 34780.0, 28610.0, 23650.0, 19630.0, 16370.0, 13720.0, 11540.0, 9744.0, 8261.0, 7030.0, 6005.0, 5147.0, 4427.0, 3820.0, 3307.0, 2872.0 }; } private static class WatsonFunction extends MinpackFunction { public WatsonFunction(int n, double x0, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(31, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double[][] jacobian = new double[m][]; for (int i = 0; i < (m - 2); ++i) { double div = (i + 1) / 29.0; double s2 = 0.0; double dx = 1.0; for (int j = 0; j < n; ++j) { s2 += dx * parameters[j].getEstimate(); dx *= div; } double temp= 2 * div * s2; dx = 1.0 / div; jacobian[i] = new double[n]; for (int j = 0; j < n; ++j) { jacobian[i][j] = dx * (j - temp); dx *= div; } } jacobian[m - 2] = new double[n]; jacobian[m - 2][0] = 1; jacobian[m - 1] = new double[n]; jacobian[m - 1][0]= -2 * parameters[0].getEstimate(); jacobian[m - 1][1]= 1; return jacobian; } protected double[] getResiduals() { double[] f = new double[m]; for (int i = 0; i < (m - 2); ++i) { double div = (i + 1) / 29.0; double s1 = 0; double dx = 1; for (int j = 1; j < n; ++j) { s1 += j * dx * parameters[j].getEstimate(); dx *= div; } double s2 =0; dx =1; for (int j = 0; j < n; ++j) { s2 += dx * parameters[j].getEstimate(); dx *= div; } f[i] = s1 - s2 * s2 - 1; } double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); f[m - 2] = x1; f[m - 1] = x2 - x1 * x1 - 1; return f; } } private static class Box3DimensionalFunction extends MinpackFunction { public Box3DimensionalFunction(int m, double[] startParams, double theoreticalStartCost) { super(m, startParams, theoreticalStartCost, 0.0, new double[] { 1.0, 10.0, 1.0 }); } protected double[][] getJacobian() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double tmp = (i + 1) / 10.0; jacobian[i] = new double[] { -tmp * Math.exp(-tmp * x1), tmp * Math.exp(-tmp * x2), Math.exp(-i - 1) - Math.exp(-tmp) }; } return jacobian; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double[] f = new double[m]; for (int i = 0; i < m; ++i) { double tmp = (i + 1) / 10.0; f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2) + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3; } return f; } } private static class JennrichSampsonFunction extends MinpackFunction { public JennrichSampsonFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, startParams, theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double t = i + 1; jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) }; } return jacobian; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = i + 1; f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2); } return f; } } private static class BrownDennisFunction extends MinpackFunction { public BrownDennisFunction(int m, double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, startParams, theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double x4 = parameters[3].getEstimate(); double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = (i + 1) / 5.0; double ti = Math.sin(temp); double tmp1 = x1 + temp * x2 - Math.exp(temp); double tmp2 = x3 + ti * x4 - Math.cos(temp); jacobian[i] = new double[] { 2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2 }; } return jacobian; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double x4 = parameters[3].getEstimate(); double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = (i + 1) / 5.0; double tmp1 = x1 + temp * x2 - Math.exp(temp); double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp); f[i] = tmp1 * tmp1 + tmp2 * tmp2; } return f; } } private static class ChebyquadFunction extends MinpackFunction { private static double[] buildChebyquadArray(int n, double factor) { double[] array = new double[n]; double inv = factor / (n + 1); for (int i = 0; i < n; ++i) { array[i] = (i + 1) * inv; } return array; } public ChebyquadFunction(int n, int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, buildChebyquadArray(n, factor), theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; } double dx = 1.0 / n; for (int j = 0; j < n; ++j) { double tmp1 = 1; double tmp2 = 2 * parameters[j].getEstimate() - 1; double temp = 2 * tmp2; double tmp3 = 0; double tmp4 = 2; for (int i = 0; i < m; ++i) { jacobian[i][j] = dx * tmp4; double ti = 4 * tmp2 + temp * tmp4 - tmp3; tmp3 = tmp4; tmp4 = ti; ti = temp * tmp2 - tmp1; tmp1 = tmp2; tmp2 = ti; } } return jacobian; } protected double[] getResiduals() { double[] f = new double[m]; for (int j = 0; j < n; ++j) { double tmp1 = 1; double tmp2 = 2 * parameters[j].getEstimate() - 1; double temp = 2 * tmp2; for (int i = 0; i < m; ++i) { f[i] += tmp2; double ti = temp * tmp2 - tmp1; tmp1 = tmp2; tmp2 = ti; } } double dx = 1.0 / n; boolean iev = false; for (int i = 0; i < m; ++i) { f[i] *= dx; if (iev) { f[i] += 1.0 / (i * (i + 2)); } iev = ! iev; } return f; } } private static class BrownAlmostLinearFunction extends MinpackFunction { public BrownAlmostLinearFunction(int m, double factor, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(m, buildArray(m, factor), theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { jacobian[i] = new double[n]; } double prod = 1; for (int j = 0; j < n; ++j) { prod *= parameters[j].getEstimate(); for (int i = 0; i < n; ++i) { jacobian[i][j] = 1; } jacobian[j][j] = 2; } for (int j = 0; j < n; ++j) { EstimatedParameter vj = parameters[j]; double temp = vj.getEstimate(); if (temp == 0) { temp = 1; prod = 1; for (int k = 0; k < n; ++k) { if (k != j) { prod *= parameters[k].getEstimate(); } } } jacobian[n - 1][j] = prod / temp; } return jacobian; } protected double[] getResiduals() { double[] f = new double[m]; double sum = -(n + 1); double prod = 1; for (int j = 0; j < n; ++j) { sum += parameters[j].getEstimate(); prod *= parameters[j].getEstimate(); } for (int i = 0; i < n; ++i) { f[i] = parameters[i].getEstimate() + sum; } f[n - 1] = prod - 1; return f; } } private static class Osborne1Function extends MinpackFunction { public Osborne1Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(33, startParams, theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double x4 = parameters[3].getEstimate(); double x5 = parameters[4].getEstimate(); double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = 10.0 * i; double tmp1 = Math.exp(-temp * x4); double tmp2 = Math.exp(-temp * x5); jacobian[i] = new double[] { -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2 }; } return jacobian; } protected double[] getResiduals() { double x1 = parameters[0].getEstimate(); double x2 = parameters[1].getEstimate(); double x3 = parameters[2].getEstimate(); double x4 = parameters[3].getEstimate(); double x5 = parameters[4].getEstimate(); double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = 10.0 * i; double tmp1 = Math.exp(-temp * x4); double tmp2 = Math.exp(-temp * x5); f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2); } return f; } private static final double[] y = { 0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751, 0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490, 0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406 }; } private static class Osborne2Function extends MinpackFunction { public Osborne2Function(double[] startParams, double theoreticalStartCost, double theoreticalMinCost, double[] theoreticalMinParams) { super(65, startParams, theoreticalStartCost, theoreticalMinCost, theoreticalMinParams); } protected double[][] getJacobian() { double x01 = parameters[0].getEstimate(); double x02 = parameters[1].getEstimate(); double x03 = parameters[2].getEstimate(); double x04 = parameters[3].getEstimate(); double x05 = parameters[4].getEstimate(); double x06 = parameters[5].getEstimate(); double x07 = parameters[6].getEstimate(); double x08 = parameters[7].getEstimate(); double x09 = parameters[8].getEstimate(); double x10 = parameters[9].getEstimate(); double x11 = parameters[10].getEstimate(); double[][] jacobian = new double[m][]; for (int i = 0; i < m; ++i) { double temp = i / 10.0; double tmp1 = Math.exp(-x05 * temp); double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09)); double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10)); double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11)); jacobian[i] = new double[] { -tmp1, -tmp2, -tmp3, -tmp4, temp * x01 * tmp1, x02 * (temp - x09) * (temp - x09) * tmp2, x03 * (temp - x10) * (temp - x10) * tmp3, x04 * (temp - x11) * (temp - x11) * tmp4, -2 * x02 * x06 * (temp - x09) * tmp2, -2 * x03 * x07 * (temp - x10) * tmp3, -2 * x04 * x08 * (temp - x11) * tmp4 }; } return jacobian; } protected double[] getResiduals() { double x01 = parameters[0].getEstimate(); double x02 = parameters[1].getEstimate(); double x03 = parameters[2].getEstimate(); double x04 = parameters[3].getEstimate(); double x05 = parameters[4].getEstimate(); double x06 = parameters[5].getEstimate(); double x07 = parameters[6].getEstimate(); double x08 = parameters[7].getEstimate(); double x09 = parameters[8].getEstimate(); double x10 = parameters[9].getEstimate(); double x11 = parameters[10].getEstimate(); double[] f = new double[m]; for (int i = 0; i < m; ++i) { double temp = i / 10.0; double tmp1 = Math.exp(-x05 * temp); double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09)); double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10)); double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11)); f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4); } return f; } private static final double[] y = { 1.366, 1.191, 1.112, 1.013, 0.991, 0.885, 0.831, 0.847, 0.786, 0.725, 0.746, 0.679, 0.608, 0.655, 0.616, 0.606, 0.602, 0.626, 0.651, 0.724, 0.649, 0.649, 0.694, 0.644, 0.624, 0.661, 0.612, 0.558, 0.533, 0.495, 0.500, 0.423, 0.395, 0.375, 0.372, 0.391, 0.396, 0.405, 0.428, 0.429, 0.523, 0.562, 0.607, 0.653, 0.672, 0.708, 0.633, 0.668, 0.645, 0.632, 0.591, 0.559, 0.597, 0.625, 0.739, 0.710, 0.729, 0.720, 0.636, 0.581, 0.428, 0.292, 0.162, 0.098, 0.054 }; } public static Test suite() { return new TestSuite(MinpackTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.estimation; import java.util.ArrayList; import java.util.HashSet; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * <p>Some of the unit tests are re-implementations of the MINPACK <a * href="http://www.netlib.org/minpack/ex/file17">file17</a> and <a * href="http://www.netlib.org/minpack/ex/file22">file22</a> test files. * The redistribution policy for MINPACK is available <a * href="http://www.netlib.org/minpack/disclaimer">here</a>, for * convenience, it is reproduced below.</p> * <table border="0" width="80%" cellpadding="10" align="center" bgcolor="#E0E0E0"> * <tr><td> * Minpack Copyright Notice (1999) University of Chicago. * All rights reserved * </td></tr> * <tr><td> * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * <ol> * <li>Redistributions of source code must retain the above copyright * notice, this list of conditions and the following disclaimer.</li> * <li>Redistributions in binary form must reproduce the above * copyright notice, this list of conditions and the following * disclaimer in the documentation and/or other materials provided * with the distribution.</li> * <li>The end-user documentation included with the redistribution, if any, * must include the following acknowledgment: * <code>This product includes software developed by the University of * Chicago, as Operator of Argonne National Laboratory.</code> * Alternately, this acknowledgment may appear in the software itself, * if and wherever such third-party acknowledgments normally appear.</li> * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED "AS IS" * WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE * UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND * THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE * OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY * OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR * USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF * THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) * DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION * UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL * BE CORRECTED.</strong></li> * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT * HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF * ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, * INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF * ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF * PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER * SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT * (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, * EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE * POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li> * <ol></td></tr> * </table> * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests) * @author Burton S. Garbow (original fortran minpack tests) * @author Kenneth E. Hillstrom (original fortran minpack tests) * @author Jorge J. More (original fortran minpack tests) * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation) */ public class LevenbergMarquardtEstimatorTest extends TestCase { public LevenbergMarquardtEstimatorTest(String name) { super(name); } public void testTrivial() throws EstimationException { LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { new EstimatedParameter("p0", 0) }, 3.0) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); try { estimator.guessParametersErrors(problem); fail("an exception should have been thrown"); } catch (EstimationException ee) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } assertEquals(1.5, problem.getUnboundParameters()[0].getEstimate(), 1.0e-10); } public void testQRColumnsPermutation() throws EstimationException { EstimatedParameter[] x = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { x[0], x[1] }, 4.0), new LinearMeasurement(new double[] { 2.0 }, new EstimatedParameter[] { x[1] }, 6.0), new LinearMeasurement(new double[] { 1.0, -2.0 }, new EstimatedParameter[] { x[0], x[1] }, 1.0) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals(7.0, x[0].getEstimate(), 1.0e-10); assertEquals(3.0, x[1].getEstimate(), 1.0e-10); } public void testNoDependency() throws EstimationException { EstimatedParameter[] p = new EstimatedParameter[] { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0), new EstimatedParameter("p2", 0), new EstimatedParameter("p3", 0), new EstimatedParameter("p4", 0), new EstimatedParameter("p5", 0) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[0] }, 0.0), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[1] }, 1.1), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[2] }, 2.2), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[3] }, 3.3), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[4] }, 4.4), new LinearMeasurement(new double[] {2}, new EstimatedParameter[] { p[5] }, 5.5) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); for (int i = 0; i < p.length; ++i) { assertEquals(0.55 * i, p[i].getEstimate(), 1.0e-10); } } public void testOneSet() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0), new EstimatedParameter("p2", 0) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0 }, new EstimatedParameter[] { p[0] }, 1.0), new LinearMeasurement(new double[] { -1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1] }, 1.0), new LinearMeasurement(new double[] { -1.0, 1.0 }, new EstimatedParameter[] { p[1], p[2] }, 1.0) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals(1.0, p[0].getEstimate(), 1.0e-10); assertEquals(2.0, p[1].getEstimate(), 1.0e-10); assertEquals(3.0, p[2].getEstimate(), 1.0e-10); } public void testTwoSets() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 1), new EstimatedParameter("p2", 2), new EstimatedParameter("p3", 3), new EstimatedParameter("p4", 4), new EstimatedParameter("p5", 5) }; double epsilon = 1.0e-7; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { // 4 elements sub-problem new LinearMeasurement(new double[] { 2.0, 1.0, 4.0 }, new EstimatedParameter[] { p[0], p[1], p[3] }, 2.0), new LinearMeasurement(new double[] { -4.0, -2.0, 3.0, -7.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, -9.0), new LinearMeasurement(new double[] { 4.0, 1.0, -2.0, 8.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 2.0), new LinearMeasurement(new double[] { -3.0, -12.0, -1.0 }, new EstimatedParameter[] { p[1], p[2], p[3] }, 2.0), // 2 elements sub-problem new LinearMeasurement(new double[] { epsilon, 1.0 }, new EstimatedParameter[] { p[4], p[5] }, 1.0 + epsilon * epsilon), new LinearMeasurement(new double[] { 1.0, 1.0 }, new EstimatedParameter[] { p[4], p[5] }, 2.0) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals( 3.0, p[0].getEstimate(), 1.0e-10); assertEquals( 4.0, p[1].getEstimate(), 1.0e-10); assertEquals(-1.0, p[2].getEstimate(), 1.0e-10); assertEquals(-2.0, p[3].getEstimate(), 1.0e-10); assertEquals( 1.0 + epsilon, p[4].getEstimate(), 1.0e-10); assertEquals( 1.0 - epsilon, p[5].getEstimate(), 1.0e-10); } public void testNonInversible() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 0), new EstimatedParameter("p2", 0) }; LinearMeasurement[] m = new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 2.0, -3.0 }, new EstimatedParameter[] { p[0], p[1], p[2] }, 1.0), new LinearMeasurement(new double[] { 2.0, 1.0, 3.0 }, new EstimatedParameter[] { p[0], p[1], p[2] }, 1.0), new LinearMeasurement(new double[] { -3.0, -9.0 }, new EstimatedParameter[] { p[0], p[2] }, 1.0) }; LinearProblem problem = new LinearProblem(m); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); double initialCost = estimator.getRMS(problem); estimator.estimate(problem); assertTrue(estimator.getRMS(problem) < initialCost); assertTrue(Math.sqrt(m.length) * estimator.getRMS(problem) > 0.6); try { estimator.getCovariances(problem); fail("an exception should have been thrown"); } catch (EstimationException ee) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } double dJ0 = 2 * (m[0].getResidual() * m[0].getPartial(p[0]) + m[1].getResidual() * m[1].getPartial(p[0]) + m[2].getResidual() * m[2].getPartial(p[0])); double dJ1 = 2 * (m[0].getResidual() * m[0].getPartial(p[1]) + m[1].getResidual() * m[1].getPartial(p[1])); double dJ2 = 2 * (m[0].getResidual() * m[0].getPartial(p[2]) + m[1].getResidual() * m[1].getPartial(p[2]) + m[2].getResidual() * m[2].getPartial(p[2])); assertEquals(0, dJ0, 1.0e-10); assertEquals(0, dJ1, 1.0e-10); assertEquals(0, dJ2, 1.0e-10); } public void testIllConditioned() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 0), new EstimatedParameter("p1", 1), new EstimatedParameter("p2", 2), new EstimatedParameter("p3", 3) }; LinearProblem problem1 = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 10.0, 7.0, 8.0, 7.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 32.0), new LinearMeasurement(new double[] { 7.0, 5.0, 6.0, 5.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 23.0), new LinearMeasurement(new double[] { 8.0, 6.0, 10.0, 9.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 33.0), new LinearMeasurement(new double[] { 7.0, 5.0, 9.0, 10.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 31.0) }); LevenbergMarquardtEstimator estimator1 = new LevenbergMarquardtEstimator(); estimator1.estimate(problem1); assertEquals(0, estimator1.getRMS(problem1), 1.0e-10); assertEquals(1.0, p[0].getEstimate(), 1.0e-10); assertEquals(1.0, p[1].getEstimate(), 1.0e-10); assertEquals(1.0, p[2].getEstimate(), 1.0e-10); assertEquals(1.0, p[3].getEstimate(), 1.0e-10); LinearProblem problem2 = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 10.0, 7.0, 8.1, 7.2 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 32.0), new LinearMeasurement(new double[] { 7.08, 5.04, 6.0, 5.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 23.0), new LinearMeasurement(new double[] { 8.0, 5.98, 9.89, 9.0 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 33.0), new LinearMeasurement(new double[] { 6.99, 4.99, 9.0, 9.98 }, new EstimatedParameter[] { p[0], p[1], p[2], p[3] }, 31.0) }); LevenbergMarquardtEstimator estimator2 = new LevenbergMarquardtEstimator(); estimator2.estimate(problem2); assertEquals(0, estimator2.getRMS(problem2), 1.0e-10); assertEquals(-81.0, p[0].getEstimate(), 1.0e-8); assertEquals(137.0, p[1].getEstimate(), 1.0e-8); assertEquals(-34.0, p[2].getEstimate(), 1.0e-8); assertEquals( 22.0, p[3].getEstimate(), 1.0e-8); } public void testMoreEstimatedParametersSimple() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 7), new EstimatedParameter("p1", 6), new EstimatedParameter("p2", 5), new EstimatedParameter("p3", 4) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 3.0, 2.0 }, new EstimatedParameter[] { p[0], p[1] }, 7.0), new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 }, new EstimatedParameter[] { p[1], p[2], p[3] }, 3.0), new LinearMeasurement(new double[] { 2.0, 1.0 }, new EstimatedParameter[] { p[0], p[2] }, 5.0) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); } public void testMoreEstimatedParametersUnsorted() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 2), new EstimatedParameter("p1", 2), new EstimatedParameter("p2", 2), new EstimatedParameter("p3", 2), new EstimatedParameter("p4", 2), new EstimatedParameter("p5", 2) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1] }, 3.0), new LinearMeasurement(new double[] { 1.0, 1.0, 1.0 }, new EstimatedParameter[] { p[2], p[3], p[4] }, 12.0), new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { p[4], p[5] }, -1.0), new LinearMeasurement(new double[] { 1.0, -1.0, 1.0 }, new EstimatedParameter[] { p[3], p[2], p[5] }, 7.0), new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { p[4], p[3] }, 1.0) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals(3.0, p[2].getEstimate(), 1.0e-10); assertEquals(4.0, p[3].getEstimate(), 1.0e-10); assertEquals(5.0, p[4].getEstimate(), 1.0e-10); assertEquals(6.0, p[5].getEstimate(), 1.0e-10); } public void testRedundantEquations() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 1), new EstimatedParameter("p1", 1) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1] }, 3.0), new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { p[0], p[1] }, 1.0), new LinearMeasurement(new double[] { 1.0, 3.0 }, new EstimatedParameter[] { p[0], p[1] }, 5.0) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertEquals(0, estimator.getRMS(problem), 1.0e-10); assertEquals(2.0, p[0].getEstimate(), 1.0e-10); assertEquals(1.0, p[1].getEstimate(), 1.0e-10); } public void testInconsistentEquations() throws EstimationException { EstimatedParameter[] p = { new EstimatedParameter("p0", 1), new EstimatedParameter("p1", 1) }; LinearProblem problem = new LinearProblem(new LinearMeasurement[] { new LinearMeasurement(new double[] { 1.0, 1.0 }, new EstimatedParameter[] { p[0], p[1] }, 3.0), new LinearMeasurement(new double[] { 1.0, -1.0 }, new EstimatedParameter[] { p[0], p[1] }, 1.0), new LinearMeasurement(new double[] { 1.0, 3.0 }, new EstimatedParameter[] { p[0], p[1] }, 4.0) }); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(problem); assertTrue(estimator.getRMS(problem) > 0.1); } public void testControlParameters() throws EstimationException { Circle circle = new Circle(98.680, 47.345); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); checkEstimate(circle, 0.1, 10, 1.0e-14, 1.0e-16, 1.0e-10, false); checkEstimate(circle, 0.1, 10, 1.0e-15, 1.0e-17, 1.0e-10, true); checkEstimate(circle, 0.1, 5, 1.0e-15, 1.0e-16, 1.0e-10, true); circle.addPoint(300, -300); checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true); } private void checkEstimate(EstimationProblem problem, double initialStepBoundFactor, int maxCostEval, double costRelativeTolerance, double parRelativeTolerance, double orthoTolerance, boolean shouldFail) { try { LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.setInitialStepBoundFactor(initialStepBoundFactor); estimator.setMaxCostEval(maxCostEval); estimator.setCostRelativeTolerance(costRelativeTolerance); estimator.setParRelativeTolerance(parRelativeTolerance); estimator.setOrthoTolerance(orthoTolerance); estimator.estimate(problem); assertTrue(! shouldFail); } catch (EstimationException ee) { assertTrue(shouldFail); } catch (Exception e) { fail("wrong exception type caught"); } } public void testCircleFitting() throws EstimationException { Circle circle = new Circle(98.680, 47.345); circle.addPoint( 30.0, 68.0); circle.addPoint( 50.0, -6.0); circle.addPoint(110.0, -20.0); circle.addPoint( 35.0, 15.0); circle.addPoint( 45.0, 97.0); LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(circle); assertTrue(estimator.getCostEvaluations() < 10); assertTrue(estimator.getJacobianEvaluations() < 10); double rms = estimator.getRMS(circle); assertEquals(1.768262623567235, Math.sqrt(circle.getM()) * rms, 1.0e-10); assertEquals(69.96016176931406, circle.getRadius(), 1.0e-10); assertEquals(96.07590211815305, circle.getX(), 1.0e-10); assertEquals(48.13516790438953, circle.getY(), 1.0e-10); double[][] cov = estimator.getCovariances(circle); assertEquals(1.839, cov[0][0], 0.001); assertEquals(0.731, cov[0][1], 0.001); assertEquals(cov[0][1], cov[1][0], 1.0e-14); assertEquals(0.786, cov[1][1], 0.001); double[] errors = estimator.guessParametersErrors(circle); assertEquals(1.384, errors[0], 0.001); assertEquals(0.905, errors[1], 0.001); // add perfect measurements and check errors are reduced double cx = circle.getX(); double cy = circle.getY(); double r = circle.getRadius(); for (double d= 0; d < 2 * Math.PI; d += 0.01) { circle.addPoint(cx + r * Math.cos(d), cy + r * Math.sin(d)); } estimator = new LevenbergMarquardtEstimator(); estimator.estimate(circle); cov = estimator.getCovariances(circle); assertEquals(0.004, cov[0][0], 0.001); assertEquals(6.40e-7, cov[0][1], 1.0e-9); assertEquals(cov[0][1], cov[1][0], 1.0e-14); assertEquals(0.003, cov[1][1], 0.001); errors = estimator.guessParametersErrors(circle); assertEquals(0.004, errors[0], 0.001); assertEquals(0.004, errors[1], 0.001); } public void testCircleFittingBadInit() throws EstimationException { Circle circle = new Circle(-12, -12); double[][] points = new double[][] { {-0.312967, 0.072366}, {-0.339248, 0.132965}, {-0.379780, 0.202724}, {-0.390426, 0.260487}, {-0.361212, 0.328325}, {-0.346039, 0.392619}, {-0.280579, 0.444306}, {-0.216035, 0.470009}, {-0.149127, 0.493832}, {-0.075133, 0.483271}, {-0.007759, 0.452680}, { 0.060071, 0.410235}, { 0.103037, 0.341076}, { 0.118438, 0.273884}, { 0.131293, 0.192201}, { 0.115869, 0.129797}, { 0.072223, 0.058396}, { 0.022884, 0.000718}, {-0.053355, -0.020405}, {-0.123584, -0.032451}, {-0.216248, -0.032862}, {-0.278592, -0.005008}, {-0.337655, 0.056658}, {-0.385899, 0.112526}, {-0.405517, 0.186957}, {-0.415374, 0.262071}, {-0.387482, 0.343398}, {-0.347322, 0.397943}, {-0.287623, 0.458425}, {-0.223502, 0.475513}, {-0.135352, 0.478186}, {-0.061221, 0.483371}, { 0.003711, 0.422737}, { 0.065054, 0.375830}, { 0.108108, 0.297099}, { 0.123882, 0.222850}, { 0.117729, 0.134382}, { 0.085195, 0.056820}, { 0.029800, -0.019138}, {-0.027520, -0.072374}, {-0.102268, -0.091555}, {-0.200299, -0.106578}, {-0.292731, -0.091473}, {-0.356288, -0.051108}, {-0.420561, 0.014926}, {-0.471036, 0.074716}, {-0.488638, 0.182508}, {-0.485990, 0.254068}, {-0.463943, 0.338438}, {-0.406453, 0.404704}, {-0.334287, 0.466119}, {-0.254244, 0.503188}, {-0.161548, 0.495769}, {-0.075733, 0.495560}, { 0.001375, 0.434937}, { 0.082787, 0.385806}, { 0.115490, 0.323807}, { 0.141089, 0.223450}, { 0.138693, 0.131703}, { 0.126415, 0.049174}, { 0.066518, -0.010217}, {-0.005184, -0.070647}, {-0.080985, -0.103635}, {-0.177377, -0.116887}, {-0.260628, -0.100258}, {-0.335756, -0.056251}, {-0.405195, -0.000895}, {-0.444937, 0.085456}, {-0.484357, 0.175597}, {-0.472453, 0.248681}, {-0.438580, 0.347463}, {-0.402304, 0.422428}, {-0.326777, 0.479438}, {-0.247797, 0.505581}, {-0.152676, 0.519380}, {-0.071754, 0.516264}, { 0.015942, 0.472802}, { 0.076608, 0.419077}, { 0.127673, 0.330264}, { 0.159951, 0.262150}, { 0.153530, 0.172681}, { 0.140653, 0.089229}, { 0.078666, 0.024981}, { 0.023807, -0.037022}, {-0.048837, -0.077056}, {-0.127729, -0.075338}, {-0.221271, -0.067526} }; for (int i = 0; i < points.length; ++i) { circle.addPoint(points[i][0], points[i][1]); } LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator(); estimator.estimate(circle); assertTrue(estimator.getCostEvaluations() < 15); assertTrue(estimator.getJacobianEvaluations() < 10); assertEquals( 0.030184491196225207, estimator.getRMS(circle), 1.0e-9); assertEquals( 0.2922350065939634, circle.getRadius(), 1.0e-9); assertEquals(-0.15173845023862165, circle.getX(), 1.0e-8); assertEquals( 0.20750021499570379, circle.getY(), 1.0e-8); } public void testMath199() { try { QuadraticProblem problem = new QuadraticProblem(); problem.addPoint (0, -3.182591015485607, 0.0); problem.addPoint (1, -2.5581184967730577, 4.4E-323); problem.addPoint (2, -2.1488478161387325, 1.0); problem.addPoint (3, -1.9122489313410047, 4.4E-323); problem.addPoint (4, 1.7785661310051026, 0.0); new LevenbergMarquardtEstimator().estimate(problem); fail("an exception should have been thrown"); } catch (EstimationException ee) { // expected behavior } } private static class LinearProblem implements EstimationProblem { public LinearProblem(LinearMeasurement[] measurements) { this.measurements = measurements; } public WeightedMeasurement[] getMeasurements() { return measurements; } public EstimatedParameter[] getUnboundParameters() { return getAllParameters(); } public EstimatedParameter[] getAllParameters() { HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>(); for (int i = 0; i < measurements.length; ++i) { EstimatedParameter[] parameters = measurements[i].getParameters(); for (int j = 0; j < parameters.length; ++j) { set.add(parameters[j]); } } return (EstimatedParameter[]) set.toArray(new EstimatedParameter[set.size()]); } private LinearMeasurement[] measurements; } private static class LinearMeasurement extends WeightedMeasurement { public LinearMeasurement(double[] factors, EstimatedParameter[] parameters, double setPoint) { super(1.0, setPoint); this.factors = factors; this.parameters = parameters; } public double getTheoreticalValue() { double v = 0; for (int i = 0; i < factors.length; ++i) { v += factors[i] * parameters[i].getEstimate(); } return v; } public double getPartial(EstimatedParameter parameter) { for (int i = 0; i < parameters.length; ++i) { if (parameters[i] == parameter) { return factors[i]; } } return 0; } public EstimatedParameter[] getParameters() { return parameters; } private double[] factors; private EstimatedParameter[] parameters; private static final long serialVersionUID = -3922448707008868580L; } private static class Circle implements EstimationProblem { public Circle(double cx, double cy) { this.cx = new EstimatedParameter("cx", cx); this.cy = new EstimatedParameter("cy", cy); points = new ArrayList<PointModel>(); } public void addPoint(double px, double py) { points.add(new PointModel(px, py)); } public int getM() { return points.size(); } public WeightedMeasurement[] getMeasurements() { return (WeightedMeasurement[]) points.toArray(new PointModel[points.size()]); } public EstimatedParameter[] getAllParameters() { return new EstimatedParameter[] { cx, cy }; } public EstimatedParameter[] getUnboundParameters() { return new EstimatedParameter[] { cx, cy }; } public double getPartialRadiusX() { double dRdX = 0; for (PointModel point : points) { dRdX += point.getPartialDiX(); } return dRdX / points.size(); } public double getPartialRadiusY() { double dRdY = 0; for (PointModel point : points) { dRdY += point.getPartialDiY(); } return dRdY / points.size(); } public double getRadius() { double r = 0; for (PointModel point : points) { r += point.getCenterDistance(); } return r / points.size(); } public double getX() { return cx.getEstimate(); } public double getY() { return cy.getEstimate(); } private class PointModel extends WeightedMeasurement { public PointModel(double px, double py) { super(1.0, 0.0); this.px = px; this.py = py; } public double getPartial(EstimatedParameter parameter) { if (parameter == cx) { return getPartialDiX() - getPartialRadiusX(); } else if (parameter == cy) { return getPartialDiY() - getPartialRadiusY(); } return 0; } public double getCenterDistance() { double dx = px - cx.getEstimate(); double dy = py - cy.getEstimate(); return Math.sqrt(dx * dx + dy * dy); } public double getPartialDiX() { return (cx.getEstimate() - px) / getCenterDistance(); } public double getPartialDiY() { return (cy.getEstimate() - py) / getCenterDistance(); } public double getTheoreticalValue() { return getCenterDistance() - getRadius(); } private double px; private double py; private static final long serialVersionUID = 1L; } private EstimatedParameter cx; private EstimatedParameter cy; private ArrayList<PointModel> points; } private static class QuadraticProblem extends SimpleEstimationProblem { private EstimatedParameter a; private EstimatedParameter b; private EstimatedParameter c; public QuadraticProblem() { a = new EstimatedParameter("a", 0.0); b = new EstimatedParameter("b", 0.0); c = new EstimatedParameter("c", 0.0); addParameter(a); addParameter(b); addParameter(c); } public void addPoint(double x, double y, double w) { addMeasurement(new LocalMeasurement(x, y, w)); } public double getA() { return a.getEstimate(); } public double getB() { return b.getEstimate(); } public double getC() { return c.getEstimate(); } public double theoreticalValue(double x) { return ( (a.getEstimate() * x + b.getEstimate() ) * x + c.getEstimate()); } private double partial(double x, EstimatedParameter parameter) { if (parameter == a) { return x * x; } else if (parameter == b) { return x; } else { return 1.0; } } private class LocalMeasurement extends WeightedMeasurement { private static final long serialVersionUID = 1555043155023729130L; private final double x; // constructor public LocalMeasurement(double x, double y, double w) { super(w, y); this.x = x; } public double getTheoreticalValue() { return theoreticalValue(x); } public double getPartial(EstimatedParameter parameter) { return partial(x, parameter); } } } public static Test suite() { return new TestSuite(LevenbergMarquardtEstimatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.estimation; import org.apache.commons.math.estimation.EstimatedParameter; import org.apache.commons.math.estimation.WeightedMeasurement; import junit.framework.*; public class WeightedMeasurementTest extends TestCase { public WeightedMeasurementTest(String name) { super(name); p1 = null; p2 = null; } public void testConstruction() { WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this); checkValue(m.getWeight(), 3.0); checkValue(m.getMeasuredValue(), theoretical() + 0.1); } public void testIgnored() { WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this); assertTrue(!m.isIgnored()); m.setIgnored(true); assertTrue(m.isIgnored()); m.setIgnored(false); assertTrue(!m.isIgnored()); } public void testTheory() { WeightedMeasurement m = new MyMeasurement(3.0, theoretical() + 0.1, this); checkValue(m.getTheoreticalValue(), theoretical()); checkValue(m.getResidual(), 0.1); double oldP1 = p1.getEstimate(); p1.setEstimate(oldP1 + m.getResidual() / m.getPartial(p1)); checkValue(m.getResidual(), 0.0); p1.setEstimate(oldP1); checkValue(m.getResidual(), 0.1); double oldP2 = p2.getEstimate(); p2.setEstimate(oldP2 + m.getResidual() / m.getPartial(p2)); checkValue(m.getResidual(), 0.0); p2.setEstimate(oldP2); checkValue(m.getResidual(), 0.1); } public static Test suite() { return new TestSuite(WeightedMeasurementTest.class); } public void setUp() { p1 = new EstimatedParameter("p1", 1.0); p2 = new EstimatedParameter("p2", 2.0); } public void tearDown() { p1 = null; p2 = null; } private void checkValue(double value, double expected) { assertTrue(Math.abs(value - expected) < 1.0e-10); } private double theoretical() { return 3 * p1.getEstimate() - p2.getEstimate(); } private double partial(EstimatedParameter p) { if (p == p1) { return 3.0; } else if (p == p2) { return -1.0; } else { return 0.0; } } private static class MyMeasurement extends WeightedMeasurement { public MyMeasurement(double weight, double measuredValue, WeightedMeasurementTest testInstance) { super(weight, measuredValue); this.testInstance = testInstance; } public double getTheoreticalValue() { return testInstance.theoretical(); } public double getPartial(EstimatedParameter p) { return testInstance.partial(p); } private transient WeightedMeasurementTest testInstance; private static final long serialVersionUID = -246712922500792332L; } private EstimatedParameter p1; private EstimatedParameter p2; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.transform; import org.apache.commons.math.analysis.*; import org.apache.commons.math.complex.*; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for fast Fourier transformer. * <p> * FFT algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Revision$ $Date$ */ public final class FastFourierTransformerTest extends TestCase { /** * Test of transformer for the ad hoc data taken from Mathematica. */ public void testAdHocData() throws MathException { FastFourierTransformer transformer = new FastFourierTransformer(); Complex result[]; double tolerance = 1E-12; double x[] = {1.3, 2.4, 1.7, 4.1, 2.9, 1.7, 5.1, 2.7}; Complex y[] = { new Complex(21.9, 0.0), new Complex(-2.09497474683058, 1.91507575950825), new Complex(-2.6, 2.7), new Complex(-1.10502525316942, -4.88492424049175), new Complex(0.1, 0.0), new Complex(-1.10502525316942, 4.88492424049175), new Complex(-2.6, -2.7), new Complex(-2.09497474683058, -1.91507575950825)}; result = transformer.transform(x); for (int i = 0; i < result.length; i++) { assertEquals(y[i].getReal(), result[i].getReal(), tolerance); assertEquals(y[i].getImaginary(), result[i].getImaginary(), tolerance); } result = transformer.inversetransform(y); for (int i = 0; i < result.length; i++) { assertEquals(x[i], result[i].getReal(), tolerance); assertEquals(0.0, result[i].getImaginary(), tolerance); } double x2[] = {10.4, 21.6, 40.8, 13.6, 23.2, 32.8, 13.6, 19.2}; FastFourierTransformer.scaleArray(x2, 1.0 / Math.sqrt(x2.length)); Complex y2[] = y; result = transformer.transform2(y2); for (int i = 0; i < result.length; i++) { assertEquals(x2[i], result[i].getReal(), tolerance); assertEquals(0.0, result[i].getImaginary(), tolerance); } result = transformer.inversetransform2(x2); for (int i = 0; i < result.length; i++) { assertEquals(y2[i].getReal(), result[i].getReal(), tolerance); assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance); } } /** * Test of transformer for the sine function. */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); FastFourierTransformer transformer = new FastFourierTransformer(); Complex result[]; int N = 1 << 8; double min, max, tolerance = 1E-12; min = 0.0; max = 2.0 * Math.PI; result = transformer.transform(f, min, max, N); assertEquals(0.0, result[1].getReal(), tolerance); assertEquals(-(N >> 1), result[1].getImaginary(), tolerance); assertEquals(0.0, result[N-1].getReal(), tolerance); assertEquals(N >> 1, result[N-1].getImaginary(), tolerance); for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) { assertEquals(0.0, result[i].getReal(), tolerance); assertEquals(0.0, result[i].getImaginary(), tolerance); } min = -Math.PI; max = Math.PI; result = transformer.inversetransform(f, min, max, N); assertEquals(0.0, result[1].getReal(), tolerance); assertEquals(-0.5, result[1].getImaginary(), tolerance); assertEquals(0.0, result[N-1].getReal(), tolerance); assertEquals(0.5, result[N-1].getImaginary(), tolerance); for (int i = 0; i < N-1; i += (i == 0 ? 2 : 1)) { assertEquals(0.0, result[i].getReal(), tolerance); assertEquals(0.0, result[i].getImaginary(), tolerance); } } /** * Test of parameters for the transformer. */ public void testParameters() throws Exception { UnivariateRealFunction f = new SinFunction(); FastFourierTransformer transformer = new FastFourierTransformer(); try { // bad interval transformer.transform(f, 1, -1, 64); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 0); fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 100); fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.transform; import org.apache.commons.math.analysis.*; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for fast cosine transformer. * <p> * FCT algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Revision$ $Date$ */ public final class FastCosineTransformerTest extends TestCase { /** * Test of transformer for the ad hoc data. */ public void testAdHocData() throws MathException { FastCosineTransformer transformer = new FastCosineTransformer(); double result[], tolerance = 1E-12; double x[] = { 0.0, 1.0, 4.0, 9.0, 16.0, 25.0, 36.0, 49.0, 64.0 }; double y[] = { 172.0, -105.096569476353, 27.3137084989848, -12.9593152353742, 8.0, -5.78585076868676, 4.68629150101524, -4.15826451958632, 4.0 }; result = transformer.transform(x); for (int i = 0; i < result.length; i++) { assertEquals(y[i], result[i], tolerance); } result = transformer.inversetransform(y); for (int i = 0; i < result.length; i++) { assertEquals(x[i], result[i], tolerance); } FastFourierTransformer.scaleArray(x, Math.sqrt(0.5 * (x.length-1))); result = transformer.transform2(y); for (int i = 0; i < result.length; i++) { assertEquals(x[i], result[i], tolerance); } result = transformer.inversetransform2(x); for (int i = 0; i < result.length; i++) { assertEquals(y[i], result[i], tolerance); } } /** * Test of transformer for the sine function. */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); FastCosineTransformer transformer = new FastCosineTransformer(); double min, max, result[], tolerance = 1E-12; int N = 9; double expected[] = { 0.0, 3.26197262739567, 0.0, -2.17958042710327, 0.0, -0.648846697642915, 0.0, -0.433545502649478, 0.0 }; min = 0.0; max = 2.0 * Math.PI * N / (N-1); result = transformer.transform(f, min, max, N); for (int i = 0; i < N; i++) { assertEquals(expected[i], result[i], tolerance); } min = -Math.PI; max = Math.PI * (N+1) / (N-1); result = transformer.transform(f, min, max, N); for (int i = 0; i < N; i++) { assertEquals(-expected[i], result[i], tolerance); } } /** * Test of parameters for the transformer. */ public void testParameters() throws Exception { UnivariateRealFunction f = new SinFunction(); FastCosineTransformer transformer = new FastCosineTransformer(); try { // bad interval transformer.transform(f, 1, -1, 65); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 1); fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 64); fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.transform; import org.apache.commons.math.analysis.*; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for fast sine transformer. * <p> * FST algorithm is exact, the small tolerance number is used only * to account for round-off errors. * * @version $Revision$ $Date$ */ public final class FastSineTransformerTest extends TestCase { /** * Test of transformer for the ad hoc data. */ public void testAdHocData() throws MathException { FastSineTransformer transformer = new FastSineTransformer(); double result[], tolerance = 1E-12; double x[] = { 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0 }; double y[] = { 0.0, 20.1093579685034, -9.65685424949238, 5.98642305066196, -4.0, 2.67271455167720, -1.65685424949238, 0.795649469518633 }; result = transformer.transform(x); for (int i = 0; i < result.length; i++) { assertEquals(y[i], result[i], tolerance); } result = transformer.inversetransform(y); for (int i = 0; i < result.length; i++) { assertEquals(x[i], result[i], tolerance); } FastFourierTransformer.scaleArray(x, Math.sqrt(x.length / 2.0)); result = transformer.transform2(y); for (int i = 0; i < result.length; i++) { assertEquals(x[i], result[i], tolerance); } result = transformer.inversetransform2(x); for (int i = 0; i < result.length; i++) { assertEquals(y[i], result[i], tolerance); } } /** * Test of transformer for the sine function. */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); FastSineTransformer transformer = new FastSineTransformer(); double min, max, result[], tolerance = 1E-12; int N = 1 << 8; min = 0.0; max = 2.0 * Math.PI; result = transformer.transform(f, min, max, N); assertEquals(N >> 1, result[2], tolerance); for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) { assertEquals(0.0, result[i], tolerance); } min = -Math.PI; max = Math.PI; result = transformer.transform(f, min, max, N); assertEquals(-(N >> 1), result[2], tolerance); for (int i = 0; i < N; i += (i == 1 ? 2 : 1)) { assertEquals(0.0, result[i], tolerance); } } /** * Test of parameters for the transformer. */ public void testParameters() throws Exception { UnivariateRealFunction f = new SinFunction(); FastSineTransformer transformer = new FastSineTransformer(); try { // bad interval transformer.transform(f, 1, -1, 64); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 0); fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } try { // bad samples number transformer.transform(f, -1, 1, 100); fail("Expecting IllegalArgumentException - bad samples number"); } catch (IllegalArgumentException ex) { // expected } } }
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements. See the NOTICE file //distributed with this work for additional information //regarding copyright ownership. The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License. You may obtain a copy of the License at //http://www.apache.org/licenses/LICENSE-2.0 //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied. See the License for the //specific language governing permissions and limitations //under the License. package org.apache.commons.math.random; import org.apache.commons.math.DimensionMismatchException; import org.apache.commons.math.linear.RealMatrix; import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance; import org.apache.commons.math.stat.descriptive.moment.VectorialMean; import junit.framework.*; public class UncorrelatedRandomVectorGeneratorTest extends TestCase { public UncorrelatedRandomVectorGeneratorTest(String name) { super(name); mean = null; standardDeviation = null; generator = null; } public void testMeanAndCorrelation() throws DimensionMismatchException { VectorialMean meanStat = new VectorialMean(mean.length); VectorialCovariance covStat = new VectorialCovariance(mean.length, true); for (int i = 0; i < 10000; ++i) { double[] v = generator.nextVector(); meanStat.increment(v); covStat.increment(v); } double[] estimatedMean = meanStat.getResult(); double scale; RealMatrix estimatedCorrelation = covStat.getResult(); for (int i = 0; i < estimatedMean.length; ++i) { assertEquals(mean[i], estimatedMean[i], 0.07); for (int j = 0; j < i; ++j) { scale = standardDeviation[i] * standardDeviation[j]; assertEquals(0, estimatedCorrelation.getEntry(i, j) / scale, 0.03); } scale = standardDeviation[i] * standardDeviation[i]; assertEquals(1, estimatedCorrelation.getEntry(i, i) / scale, 0.025); } } public void setUp() { mean = new double[] {0.0, 1.0, -3.0, 2.3}; standardDeviation = new double[] {1.0, 2.0, 10.0, 0.1}; RandomGenerator rg = new JDKRandomGenerator(); rg.setSeed(17399225432l); generator = new UncorrelatedRandomVectorGenerator(mean, standardDeviation, new GaussianRandomGenerator(rg)); } public void tearDown() { mean = null; standardDeviation = null; generator = null; } public static Test suite() { return new TestSuite(UncorrelatedRandomVectorGeneratorTest.class); } private double[] mean; private double[] standardDeviation; private UncorrelatedRandomVectorGenerator generator; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.random; import junit.framework.Test; import junit.framework.TestSuite; import java.util.Random; /** * Test cases for the RandomAdaptor class * * @version $Revision:$ $Date$ */ public class RandomAdaptorTest extends RandomDataTest { public RandomAdaptorTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(RandomAdaptorTest.class); suite.setName("RandomAdaptor Tests"); return suite; } public void testAdaptor() { ConstantGenerator generator = new ConstantGenerator(); Random random = RandomAdaptor.createAdaptor(generator); checkConstant(random); RandomAdaptor randomAdaptor = new RandomAdaptor(generator); checkConstant(randomAdaptor); } private void checkConstant(Random random) { byte[] bytes = new byte[] {0}; random.nextBytes(bytes); assertEquals(0, bytes[0]); assertEquals(false, random.nextBoolean()); assertEquals(0, random.nextDouble(), 0); assertEquals(0, random.nextFloat(), 0); assertEquals(0, random.nextGaussian(), 0); assertEquals(0, random.nextInt()); assertEquals(0, random.nextInt(1)); assertEquals(0, random.nextLong()); random.setSeed(100); assertEquals(0, random.nextDouble(), 0); } /* * "Constant" generator to test Adaptor delegation. * "Powered by Eclipse ;-)" * */ private static class ConstantGenerator implements RandomGenerator { private static final long serialVersionUID = 5936262220824971138L; public boolean nextBoolean() { return false; } public void nextBytes(byte[] bytes) { } public double nextDouble() { return 0; } public float nextFloat() { return 0; } public double nextGaussian() { return 0; } public int nextInt() { return 0; } public int nextInt(int n) { return 0; } public long nextLong() { return 0; } public void setSeed(long seed) { } } }
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements. See the NOTICE file //distributed with this work for additional information //regarding copyright ownership. The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License. You may obtain a copy of the License at //http://www.apache.org/licenses/LICENSE-2.0 //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied. See the License for the //specific language governing permissions and limitations //under the License. package org.apache.commons.math.random; import org.apache.commons.math.DimensionMismatchException; import org.apache.commons.math.linear.RealMatrix; import org.apache.commons.math.linear.RealMatrixImpl; import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance; import org.apache.commons.math.stat.descriptive.moment.VectorialMean; import junit.framework.*; public class CorrelatedRandomVectorGeneratorTest extends TestCase { public CorrelatedRandomVectorGeneratorTest(String name) { super(name); mean = null; covariance = null; generator = null; } public void testRank() { assertEquals(3, generator.getRank()); } public void testMath226() throws DimensionMismatchException, NotPositiveDefiniteMatrixException { double[] mean = { 1, 1, 10, 1 }; double[][] cov = { { 1, 3, 2, 6 }, { 3, 13, 16, 2 }, { 2, 16, 38, -1 }, { 6, 2, -1, 197 } }; RealMatrix covRM = new RealMatrixImpl(cov, false); JDKRandomGenerator jg = new JDKRandomGenerator(); jg.setSeed(5322145245211l); NormalizedRandomGenerator rg = new GaussianRandomGenerator(jg); CorrelatedRandomVectorGenerator sg = new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg); for (int i = 0; i < 10; i++) { double[] generated = sg.nextVector(); assertTrue(Math.abs(generated[0] - 1) > 0.1); } } public void testRootMatrix() { RealMatrix b = generator.getRootMatrix(); RealMatrix bbt = b.multiply(b.transpose()); for (int i = 0; i < covariance.getRowDimension(); ++i) { for (int j = 0; j < covariance.getColumnDimension(); ++j) { assertEquals(covariance.getEntry(i, j), bbt.getEntry(i, j), 1.0e-12); } } } public void testMeanAndCovariance() throws DimensionMismatchException { VectorialMean meanStat = new VectorialMean(mean.length); VectorialCovariance covStat = new VectorialCovariance(mean.length, true); for (int i = 0; i < 5000; ++i) { double[] v = generator.nextVector(); meanStat.increment(v); covStat.increment(v); } double[] estimatedMean = meanStat.getResult(); RealMatrix estimatedCovariance = covStat.getResult(); for (int i = 0; i < estimatedMean.length; ++i) { assertEquals(mean[i], estimatedMean[i], 0.07); for (int j = 0; j <= i; ++j) { assertEquals(covariance.getEntry(i, j), estimatedCovariance.getEntry(i, j), 0.1 * (1.0 + Math.abs(mean[i])) * (1.0 + Math.abs(mean[j]))); } } } public void setUp() { try { mean = new double[] { 0.0, 1.0, -3.0, 2.3}; RealMatrixImpl b = new RealMatrixImpl(4, 3); double[][] bData = b.getDataRef(); int counter = 0; for (int i = 0; i < bData.length; ++i) { double[] bi = bData[i]; for (int j = 0; j < b.getColumnDimension(); ++j) { bi[j] = 1.0 + 0.1 * ++counter; } } RealMatrix bbt = b.multiply(b.transpose()); covariance = new RealMatrixImpl(mean.length, mean.length); double[][] covData = covariance.getDataRef(); for (int i = 0; i < covariance.getRowDimension(); ++i) { covData[i][i] = bbt.getEntry(i, i); for (int j = 0; j < covariance.getColumnDimension(); ++j) { double s = bbt.getEntry(i, j); covData[i][j] = s; covData[j][i] = s; } } RandomGenerator rg = new JDKRandomGenerator(); rg.setSeed(17399225432l); GaussianRandomGenerator rawGenerator = new GaussianRandomGenerator(rg); generator = new CorrelatedRandomVectorGenerator(mean, covariance, 1.0e-12 * covariance.getNorm(), rawGenerator); } catch (DimensionMismatchException e) { fail(e.getMessage()); } catch (NotPositiveDefiniteMatrixException e) { fail("not positive definite matrix"); } } public void tearDown() { mean = null; covariance = null; generator = null; } public static Test suite() { return new TestSuite(CorrelatedRandomVectorGeneratorTest.class); } private double[] mean; private RealMatrixImpl covariance; private CorrelatedRandomVectorGenerator generator; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.random; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader; import java.net.URL; import java.util.ArrayList; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.MathRuntimeException; import org.apache.commons.math.RetryTestCase; import org.apache.commons.math.TestUtils; import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * Test cases for the EmpiricalDistribution class * * @version $Revision$ $Date$ */ public final class EmpiricalDistributionTest extends RetryTestCase { protected EmpiricalDistribution empiricalDistribution = null; protected EmpiricalDistribution empiricalDistribution2 = null; protected File file = null; protected URL url = null; protected double[] dataArray = null; public EmpiricalDistributionTest(String name) { super(name); } public void setUp() throws IOException { empiricalDistribution = new EmpiricalDistributionImpl(100); url = getClass().getResource("testData.txt"); empiricalDistribution2 = new EmpiricalDistributionImpl(100); BufferedReader in = new BufferedReader(new InputStreamReader( url.openStream())); String str = null; ArrayList<Double> list = new ArrayList<Double>(); while ((str = in.readLine()) != null) { list.add(Double.valueOf(str)); } in.close(); in = null; dataArray = new double[list.size()]; int i = 0; for (Double data : list) { dataArray[i] = data.doubleValue(); i++; } } public static Test suite() { TestSuite suite = new TestSuite(EmpiricalDistributionTest.class); suite.setName("EmpiricalDistribution Tests"); return suite; } /** * Test EmpiricalDistrbution.load() using sample data file.<br> * Check that the sampleCount, mu and sigma match data in * the sample data file. */ public void testLoad() throws Exception { empiricalDistribution.load(url); // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1 // Make sure that loaded distribution matches this assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7); //TODO: replace with statistical tests assertEquals (empiricalDistribution.getSampleStats().getMean(), 5.069831575018909,10E-7); assertEquals (empiricalDistribution.getSampleStats().getStandardDeviation(), 1.0173699343977738,10E-7); } /** * Test EmpiricalDistrbution.load(double[]) using data taken from * sample data file.<br> * Check that the sampleCount, mu and sigma match data in * the sample data file. */ public void testDoubleLoad() throws Exception { empiricalDistribution2.load(dataArray); // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1 // Make sure that loaded distribution matches this assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7); //TODO: replace with statistical tests assertEquals (empiricalDistribution2.getSampleStats().getMean(), 5.069831575018909,10E-7); assertEquals (empiricalDistribution2.getSampleStats().getStandardDeviation(), 1.0173699343977738,10E-7); double[] bounds = empiricalDistribution2.getUpperBounds(); assertEquals(bounds.length, 100); assertEquals(bounds[99], 1.0, 10e-12); } /** * Generate 1000 random values and make sure they look OK.<br> * Note that there is a non-zero (but very small) probability that * these tests will fail even if the code is working as designed. */ public void testNext() throws Exception { tstGen(0.1); tstDoubleGen(0.1); } /** * Make sure exception thrown if digest getNext is attempted * before loading empiricalDistribution. */ public void testNexFail() { try { empiricalDistribution.getNextValue(); empiricalDistribution2.getNextValue(); fail("Expecting IllegalStateException"); } catch (IllegalStateException ex) { // expected } catch (Exception e) { fail("wrong exception caught"); } } /** * Make sure we can handle a grid size that is too fine */ public void testGridTooFine() throws Exception { empiricalDistribution = new EmpiricalDistributionImpl(1001); tstGen(0.1); empiricalDistribution2 = new EmpiricalDistributionImpl(1001); tstDoubleGen(0.1); } /** * How about too fat? */ public void testGridTooFat() throws Exception { empiricalDistribution = new EmpiricalDistributionImpl(1); tstGen(5); // ridiculous tolerance; but ridiculous grid size // really just checking to make sure we do not bomb empiricalDistribution2 = new EmpiricalDistributionImpl(1); tstDoubleGen(5); } /** * Test bin index overflow problem (BZ 36450) */ public void testBinIndexOverflow() throws Exception { double[] x = new double[] {9474.94326071674, 2080107.8865462579}; new EmpiricalDistributionImpl().load(x); } public void testSerialization() { // Empty EmpiricalDistribution dist = new EmpiricalDistributionImpl(); EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist); verifySame(dist, dist2); // Loaded empiricalDistribution2.load(dataArray); dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2); verifySame(empiricalDistribution2, dist2); } public void testLoadNullDoubleArray() { EmpiricalDistribution dist = new EmpiricalDistributionImpl(); try { dist.load((double[]) null); fail("load((double[]) null) expected RuntimeException"); } catch (MathRuntimeException e) { // expected } catch (Exception e) { fail("wrong exception caught"); } } public void testLoadNullURL() throws Exception { EmpiricalDistribution dist = new EmpiricalDistributionImpl(); try { dist.load((URL) null); fail("load((URL) null) expected NullPointerException"); } catch (NullPointerException e) { // expected } catch (Exception e) { fail("wrong exception caught"); } } public void testLoadNullFile() throws Exception { EmpiricalDistribution dist = new EmpiricalDistributionImpl(); try { dist.load((File) null); fail("load((File) null) expected NullPointerException"); } catch (NullPointerException e) { // expected } catch (Exception e) { fail("wrong exception caught"); } } private void verifySame(EmpiricalDistribution d1, EmpiricalDistribution d2) { assertEquals(d1.isLoaded(), d2.isLoaded()); assertEquals(d1.getBinCount(), d2.getBinCount()); assertEquals(d1.getSampleStats(), d2.getSampleStats()); if (d1.isLoaded()) { for (int i = 0; i < d1.getUpperBounds().length; i++) { assertEquals(d1.getUpperBounds()[i], d2.getUpperBounds()[i], 0); } assertEquals(d1.getBinStats(), d2.getBinStats()); } } private void tstGen(double tolerance)throws Exception { empiricalDistribution.load(url); SummaryStatistics stats = new SummaryStatistics(); for (int i = 1; i < 1000; i++) { stats.addValue(empiricalDistribution.getNextValue()); } assertEquals("mean", stats.getMean(),5.069831575018909,tolerance); assertEquals ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance); } private void tstDoubleGen(double tolerance)throws Exception { empiricalDistribution2.load(dataArray); SummaryStatistics stats = new SummaryStatistics(); for (int i = 1; i < 1000; i++) { stats.addValue(empiricalDistribution2.getNextValue()); } assertEquals("mean", stats.getMean(),5.069831575018909,tolerance); assertEquals ("std dev", stats.getStandardDeviation(),1.0173699343977738,tolerance); } }
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements. See the NOTICE file //distributed with this work for additional information //regarding copyright ownership. The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License. You may obtain a copy of the License at //http://www.apache.org/licenses/LICENSE-2.0 //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied. See the License for the //specific language governing permissions and limitations //under the License. package org.apache.commons.math.random; import org.apache.commons.math.stat.StatUtils; import junit.framework.*; public class UniformRandomGeneratorTest extends TestCase { public UniformRandomGeneratorTest(String name) { super(name); } public void testMeanAndStandardDeviation() { RandomGenerator rg = new JDKRandomGenerator(); rg.setSeed(17399225432l); UniformRandomGenerator generator = new UniformRandomGenerator(rg); double[] sample = new double[10000]; for (int i = 0; i < sample.length; ++i) { sample[i] = generator.nextNormalizedDouble(); } assertEquals(0.0, StatUtils.mean(sample), 0.07); assertEquals(1.0, StatUtils.variance(sample), 0.02); } public static Test suite() { return new TestSuite(UniformRandomGeneratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.random; import junit.framework.Test; import junit.framework.TestSuite; import java.security.NoSuchProviderException; import java.security.NoSuchAlgorithmException; import java.util.HashSet; import org.apache.commons.math.RetryTestCase; import org.apache.commons.math.stat.Frequency; import org.apache.commons.math.stat.inference.ChiSquareTestImpl; import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * Test cases for the RandomData class. * * @version $Revision$ $Date$ */ public class RandomDataTest extends RetryTestCase { public RandomDataTest(String name) { super(name); randomData = new RandomDataImpl(); } protected long smallSampleSize = 1000; protected double[] expected = {250,250,250,250}; protected int largeSampleSize = 10000; private String[] hex = {"0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"}; protected RandomDataImpl randomData = null; protected ChiSquareTestImpl testStatistic = new ChiSquareTestImpl(); public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(RandomDataTest.class); suite.setName("RandomData Tests"); return suite; } public void testNextIntExtremeValues() { int x = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE); int y = randomData.nextInt(Integer.MIN_VALUE, Integer.MAX_VALUE); assertFalse(x == y); } public void testNextLongExtremeValues() { long x = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE); long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE); assertFalse(x == y); } /** test dispersion and failure modes for nextInt() */ public void testNextInt() { try { randomData.nextInt(4,3); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } Frequency freq = new Frequency(); int value = 0; for (int i=0;i<smallSampleSize;i++) { value = randomData.nextInt(0,3); assertTrue("nextInt range",(value >= 0) && (value <= 3)); freq.addValue(value); } long[] observed = new long[4]; for (int i=0; i<4; i++) { observed[i] = freq.getCount(i); } /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001 * Change to 11.34 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 16.27); } /** test dispersion and failure modes for nextLong() */ public void testNextLong() { try { randomData.nextLong(4,3); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } Frequency freq = new Frequency(); long value = 0; for (int i=0;i<smallSampleSize;i++) { value = randomData.nextLong(0,3); assertTrue("nextInt range",(value >= 0) && (value <= 3)); freq.addValue(value); } long[] observed = new long[4]; for (int i=0; i<4; i++) { observed[i] = freq.getCount(i); } /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001 * Change to 11.34 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 16.27); } /** test dispersion and failure modes for nextSecureLong() */ public void testNextSecureLong() { try { randomData.nextSecureLong(4,3); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } Frequency freq = new Frequency(); long value = 0; for (int i=0;i<smallSampleSize;i++) { value = randomData.nextSecureLong(0,3); assertTrue("nextInt range",(value >= 0) && (value <= 3)); freq.addValue(value); } long[] observed = new long[4]; for (int i=0; i<4; i++) { observed[i] = freq.getCount(i); } /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001 * Change to 11.34 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 16.27); } /** test dispersion and failure modes for nextSecureInt() */ public void testNextSecureInt() { try { randomData.nextSecureInt(4,3); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } Frequency freq = new Frequency(); int value = 0; for (int i=0;i<smallSampleSize;i++) { value = randomData.nextSecureInt(0,3); assertTrue("nextInt range",(value >= 0) && (value <= 3)); freq.addValue(value); } long[] observed = new long[4]; for (int i=0; i<4; i++) { observed[i] = freq.getCount(i); } /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001 * Change to 11.34 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 16.27); } /** * Make sure that empirical distribution of random Poisson(4)'s * has P(X <= 5) close to actual cumulative Poisson probablity * and that nextPoisson fails when mean is non-positive * TODO: replace with statistical test, adding test stat to TestStatistic */ public void testNextPoisson() { try { randomData.nextPoisson(0); fail("zero mean -- expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } Frequency f = new Frequency(); for (int i = 0; i<largeSampleSize; i++) { try { f.addValue(randomData.nextPoisson(4.0d)); } catch (Exception ex) { fail(ex.getMessage()); } } long cumFreq = f.getCount(0) + f.getCount(1) + f.getCount(2) + f.getCount(3) + f.getCount(4) + f.getCount(5); long sumFreq = f.getSumFreq(); double cumPct = Double.valueOf(cumFreq).doubleValue()/Double.valueOf(sumFreq).doubleValue(); assertEquals("cum Poisson(4)",cumPct,0.7851,0.2); try { randomData.nextPoisson(-1); fail("negative mean supplied -- IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } try { randomData.nextPoisson(0); fail("0 mean supplied -- IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } } /** test dispersion and failute modes for nextHex() */ public void testNextHex() { try { randomData.nextHexString(-1); fail("negative length supplied -- IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } try { randomData.nextHexString(0); fail("zero length supplied -- IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } String hexString = randomData.nextHexString(3); if (hexString.length() != 3) { fail("incorrect length for generated string"); } hexString = randomData.nextHexString(1); if (hexString.length() != 1) { fail("incorrect length for generated string"); } try { hexString = randomData.nextHexString(0); fail("zero length requested -- expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } if (hexString.length() != 1) { fail("incorrect length for generated string"); } Frequency f = new Frequency(); for (int i = 0; i < smallSampleSize; i++) { hexString = randomData.nextHexString(100); if (hexString.length() != 100) { fail("incorrect length for generated string"); } for (int j = 0; j < hexString.length(); j++) { f.addValue(hexString.substring(j,j+1)); } } double[] expected = new double[16]; long[] observed = new long[16]; for (int i = 0; i < 16; i++) { expected[i] = (double)smallSampleSize*100/(double)16; observed[i] = f.getCount(hex[i]); } /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001 * Change to 30.58 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 37.70); } /** test dispersion and failute modes for nextHex() */ public void testNextSecureHex() { try { randomData.nextSecureHexString(-1); fail("negative length -- IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } try { randomData.nextSecureHexString(0); fail("zero length -- IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } String hexString = randomData.nextSecureHexString(3); if (hexString.length() != 3) { fail("incorrect length for generated string"); } hexString = randomData.nextSecureHexString(1); if (hexString.length() != 1) { fail("incorrect length for generated string"); } try { hexString = randomData.nextSecureHexString(0); fail("zero length requested -- expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } if (hexString.length() != 1) { fail("incorrect length for generated string"); } Frequency f = new Frequency(); for (int i = 0; i < smallSampleSize; i++) { hexString = randomData.nextSecureHexString(100); if (hexString.length() != 100) { fail("incorrect length for generated string"); } for (int j = 0; j < hexString.length(); j++) { f.addValue(hexString.substring(j,j+1)); } } double[] expected = new double[16]; long[] observed = new long[16]; for (int i = 0; i < 16; i++) { expected[i] = (double)smallSampleSize*100/(double)16; observed[i] = f.getCount(hex[i]); } /* Use ChiSquare dist with df = 16-1 = 15, alpha = .001 * Change to 30.58 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 37.70); } /** test failure modes and dispersion of nextUniform() */ public void testNextUniform() { try { randomData.nextUniform(4,3); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } try { randomData.nextUniform(3,3); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } double[] expected = {500,500}; long[] observed = {0,0}; double lower = -1d; double upper = 20d; double midpoint = (lower + upper)/2d; double result = 0; for (int i = 0; i < 1000; i++) { result = randomData.nextUniform(lower,upper); if ((result == lower) || (result == upper)) { fail("generated value equal to an endpoint: " + result); } if (result < midpoint) { observed[0]++; } else { observed[1]++; } } /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001 * Change to 6.64 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 10.83); } /** test exclusive endpoints of nextUniform **/ public void testNextUniformExclusiveEndpoints() { for (int i = 0; i < 1000; i++) { double u = randomData.nextUniform(0.99, 1); assertTrue(u > 0.99 && u < 1); } } /** test failure modes and distribution of nextGaussian() */ public void testNextGaussian() { try { randomData.nextGaussian(0,0); fail("zero sigma -- IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } SummaryStatistics u = new SummaryStatistics(); for (int i = 0; i<largeSampleSize; i++) { u.addValue(randomData.nextGaussian(0,1)); } double xbar = u.getMean(); double s = u.getStandardDeviation(); double n = (double) u.getN(); /* t-test at .001-level TODO: replace with externalized t-test, with * test statistic defined in TestStatistic */ assertTrue(Math.abs(xbar)/(s/Math.sqrt(n))< 3.29); } /** test failure modes and distribution of nextExponential() */ public void testNextExponential() { try { randomData.nextExponential(-1); fail("negative mean -- expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } assertEquals("0 mean", 0,randomData.nextExponential(0),10E-8); long cumFreq = 0; double v = 0; for (int i = 0; i < largeSampleSize; i++) { v = randomData.nextExponential(1); assertTrue("exponential deviate postive", v > 0); if (v < 2) cumFreq++; } /* TODO: Replace with a statistical test, with statistic added to * TestStatistic. Check below compares observed cumulative distribution * evaluated at 2 with exponential CDF */ assertEquals("exponential cumulative distribution", (double)cumFreq/(double)largeSampleSize,0.8646647167633873,.2); } /** test reseeding, algorithm/provider games */ public void testConfig() throws NoSuchProviderException, NoSuchAlgorithmException { randomData.reSeed(1000); double v = randomData.nextUniform(0,1); randomData.reSeed(); assertTrue("different seeds", Math.abs(v - randomData.nextUniform(0,1)) > 10E-12); randomData.reSeed(1000); assertEquals("same seeds",v,randomData.nextUniform(0,1),10E-12); randomData.reSeedSecure(1000); String hex = randomData.nextSecureHexString(40); randomData.reSeedSecure(); assertTrue("different seeds", !hex.equals(randomData.nextSecureHexString(40))); randomData.reSeedSecure(1000); assertTrue("same seeds", !hex.equals(randomData.nextSecureHexString(40))); /* remove this test back soon, * since it takes about 4 seconds try { randomData.setSecureAlgorithm("SHA1PRNG","SUN"); } catch (NoSuchProviderException ex) { ; } assertTrue("different seeds", !hex.equals(randomData.nextSecureHexString(40))); try { randomData.setSecureAlgorithm("NOSUCHTHING","SUN"); fail("expecting NoSuchAlgorithmException"); } catch (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException ex) { ; } try { randomData.setSecureAlgorithm("SHA1PRNG","NOSUCHPROVIDER"); fail("expecting NoSuchProviderException"); } catch (NoSuchProviderException ex) { ; } */ // test reseeding without first using the generators RandomDataImpl rd = new RandomDataImpl(); rd.reSeed(100); rd.nextLong(1,2); RandomDataImpl rd2 = new RandomDataImpl(); rd2.reSeedSecure(2000); rd2.nextSecureLong(1,2); rd = new RandomDataImpl(); rd.reSeed(); rd.nextLong(1,2); rd2 = new RandomDataImpl(); rd2.reSeedSecure(); rd2.nextSecureLong(1,2); } /** tests for nextSample() sampling from Collection */ public void testNextSample() { Object[][] c = {{"0","1"},{"0","2"},{"0","3"},{"0","4"},{"1","2"}, {"1","3"},{"1","4"},{"2","3"},{"2","4"},{"3","4"}}; long[] observed = {0,0,0,0,0,0,0,0,0,0}; double[] expected = {100,100,100,100,100,100,100,100,100,100}; HashSet<Object> cPop = new HashSet<Object>(); //{0,1,2,3,4} for (int i = 0; i < 5; i++) { cPop.add(Integer.toString(i)); } Object[] sets = new Object[10]; // 2-sets from 5 for (int i = 0; i < 10; i ++) { HashSet<Object> hs = new HashSet<Object>(); hs.add(c[i][0]); hs.add(c[i][1]); sets[i] = hs; } for (int i = 0; i < 1000; i ++) { Object[] cSamp = randomData.nextSample(cPop,2); observed[findSample(sets,cSamp)]++; } /* Use ChiSquare dist with df = 10-1 = 9, alpha = .001 * Change to 21.67 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 27.88); // Make sure sample of size = size of collection returns same collection HashSet<Object> hs = new HashSet<Object>(); hs.add("one"); Object[] one = randomData.nextSample(hs,1); String oneString = (String) one[0]; if ((one.length != 1) || !oneString.equals("one")){ fail("bad sample for set size = 1, sample size = 1"); } // Make sure we fail for sample size > collection size try { one = randomData.nextSample(hs,2); fail("sample size > set size, expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } // Make sure we fail for empty collection try { hs = new HashSet<Object>(); one = randomData.nextSample(hs,0); fail("n = k = 0, expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } @SuppressWarnings("unchecked") private int findSample(Object[] u, Object[] samp) { for (int i = 0; i < u.length; i++) { HashSet<Object> set = (HashSet<Object>) u[i]; HashSet<Object> sampSet = new HashSet<Object>(); for (int j = 0; j < samp.length; j++) { sampSet.add(samp[j]); } if (set.equals(sampSet)) { return i; } } fail("sample not found:{" + samp[0] + "," + samp[1] + "}"); return -1; } /** tests for nextPermutation */ public void testNextPermutation() { int[][] p = {{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}}; long[] observed = {0,0,0,0,0,0}; double[] expected = {100,100,100,100,100,100}; for (int i = 0; i < 600; i++) { int[] perm = randomData.nextPermutation(3,3); observed[findPerm(p,perm)]++; } /* Use ChiSquare dist with df = 6-1 = 5, alpha = .001 * Change to 15.09 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 20.52); // Check size = 1 boundary case int[] perm = randomData.nextPermutation(1,1); if ((perm.length != 1) || (perm[0] != 0)){ fail("bad permutation for n = 1, sample k = 1"); // Make sure we fail for k size > n try { perm = randomData.nextPermutation(2,3); fail("permutation k > n, expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } // Make sure we fail for n = 0 try { perm = randomData.nextPermutation(0,0); fail("permutation k = n = 0, expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } // Make sure we fail for k < n < 0 try { perm = randomData.nextPermutation(-1,-3); fail("permutation k < n < 0, expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } } private int findPerm(int[][] p, int[] samp) { for (int i = 0; i < p.length; i++) { boolean good = true; for (int j = 0; j < samp.length; j++) { if (samp[j] != p[i][j]) { good = false; } } if (good) { return i; } } fail("permutation not found"); return -1; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.random; import junit.framework.Test; import junit.framework.TestSuite; import java.io.EOFException; import java.net.URL; import org.apache.commons.math.RetryTestCase; import org.apache.commons.math.stat.descriptive.SummaryStatistics; /** * Test cases for the ValueServer class. * * @version $Revision$ $Date$ */ public final class ValueServerTest extends RetryTestCase { private ValueServer vs = new ValueServer(); public ValueServerTest(String name) { super(name); } public void setUp() { vs.setMode(ValueServer.DIGEST_MODE); try { URL url = getClass().getResource("testData.txt"); vs.setValuesFileURL(url); } catch (Exception ex) { fail("malformed test URL"); } } public static Test suite() { TestSuite suite = new TestSuite(ValueServerTest.class); suite.setName("ValueServer Tests"); return suite; } /** * Generate 1000 random values and make sure they look OK.<br> * Note that there is a non-zero (but very small) probability that * these tests will fail even if the code is working as designed. */ public void testNextDigest() throws Exception{ double next = 0.0; double tolerance = 0.1; vs.computeDistribution(); assertTrue("empirical distribution property", vs.getEmpiricalDistribution() != null); SummaryStatistics stats = new SummaryStatistics(); for (int i = 1; i < 1000; i++) { next = vs.getNext(); stats.addValue(next); } assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance); assertEquals ("std dev", 1.0173699343977738, stats.getStandardDeviation(), tolerance); vs.computeDistribution(500); stats = new SummaryStatistics(); for (int i = 1; i < 1000; i++) { next = vs.getNext(); stats.addValue(next); } assertEquals("mean", 5.069831575018909, stats.getMean(), tolerance); assertEquals ("std dev", 1.0173699343977738, stats.getStandardDeviation(), tolerance); } /** * Make sure exception thrown if digest getNext is attempted * before loading empiricalDistribution. */ public void testNextDigestFail() throws Exception { try { vs.getNext(); fail("Expecting IllegalStateException"); } catch (IllegalStateException ex) {;} } public void testEmptyReplayFile() { try { URL url = getClass().getResource("emptyFile.txt"); vs.setMode(ValueServer.REPLAY_MODE); vs.setValuesFileURL(url); vs.getNext(); fail("an exception should have been thrown"); } catch (EOFException eof) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } public void testEmptyDigestFile() { try { URL url = getClass().getResource("emptyFile.txt"); vs.setMode(ValueServer.DIGEST_MODE); vs.setValuesFileURL(url); vs.computeDistribution(); fail("an exception should have been thrown"); } catch (EOFException eof) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** * Test ValueServer REPLAY_MODE using values in testData file.<br> * Check that the values 1,2,1001,1002 match data file values 1 and 2. * the sample data file. */ public void testReplay() throws Exception { double firstDataValue = 4.038625496201205; double secondDataValue = 3.6485326248346936; double tolerance = 10E-15; double compareValue = 0.0d; vs.setMode(ValueServer.REPLAY_MODE); vs.resetReplayFile(); compareValue = vs.getNext(); assertEquals(compareValue,firstDataValue,tolerance); compareValue = vs.getNext(); assertEquals(compareValue,secondDataValue,tolerance); for (int i = 3; i < 1001; i++) { compareValue = vs.getNext(); } compareValue = vs.getNext(); assertEquals(compareValue,firstDataValue,tolerance); compareValue = vs.getNext(); assertEquals(compareValue,secondDataValue,tolerance); vs.closeReplayFile(); // make sure no NPE vs.closeReplayFile(); } /** * Test other ValueServer modes */ public void testModes() throws Exception { vs.setMode(ValueServer.CONSTANT_MODE); vs.setMu(0); assertEquals("constant mode test",vs.getMu(),vs.getNext(),Double.MIN_VALUE); vs.setMode(ValueServer.UNIFORM_MODE); vs.setMu(2); double val = vs.getNext(); assertTrue(val > 0 && val < 4); vs.setSigma(1); vs.setMode(ValueServer.GAUSSIAN_MODE); val = vs.getNext(); assertTrue("gaussian value close enough to mean", val < vs.getMu() + 100*vs.getSigma()); vs.setMode(ValueServer.EXPONENTIAL_MODE); val = vs.getNext(); assertTrue(val > 0); try { vs.setMode(1000); vs.getNext(); fail("bad mode, expecting IllegalStateException"); } catch (IllegalStateException ex) { ; } } /** * Test fill */ public void testFill() throws Exception { vs.setMode(ValueServer.CONSTANT_MODE); vs.setMu(2); double[] val = new double[5]; vs.fill(val); for (int i = 0; i < 5; i++) { assertEquals("fill test in place",2,val[i],Double.MIN_VALUE); } double v2[] = vs.fill(3); for (int i = 0; i < 3; i++) { assertEquals("fill test in place",2,v2[i],Double.MIN_VALUE); } } /** * Test getters to make Clover happy */ public void testProperties() throws Exception { vs.setMode(ValueServer.CONSTANT_MODE); assertEquals("mode test",ValueServer.CONSTANT_MODE,vs.getMode()); vs.setValuesFileURL("http://www.apache.org"); URL url = vs.getValuesFileURL(); assertEquals("valuesFileURL test","http://www.apache.org",url.toString()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.random; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.stat.Frequency; /** * Test cases for the AbstractRandomGenerator class * * @version $Revision:$ $Date$ */ public class AbstractRandomGeneratorTest extends RandomDataTest { protected TestRandomGenerator testGenerator = new TestRandomGenerator(); public AbstractRandomGeneratorTest(String name) { super(name); randomData = new RandomDataImpl(testGenerator); } public static Test suite() { TestSuite suite = new TestSuite(AbstractRandomGeneratorTest.class); suite.setName("AbstractRandomGenerator Tests"); return suite; } public void testNextInt() { try { testGenerator.nextInt(-1); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } Frequency freq = new Frequency(); int value = 0; for (int i=0; i<smallSampleSize; i++) { value = testGenerator.nextInt(4); assertTrue("nextInt range",(value >= 0) && (value <= 3)); freq.addValue(value); } long[] observed = new long[4]; for (int i=0; i<4; i++) { observed[i] = freq.getCount(i); } /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001 * Change to 11.34 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 16.27); } public void testNextLong() { long q1 = Long.MAX_VALUE/4; long q2 = 2 * q1; long q3 = 3 * q1; Frequency freq = new Frequency(); long val = 0; int value = 0; for (int i=0; i<smallSampleSize; i++) { val = testGenerator.nextLong(); if (val < q1) { value = 0; } else if (val < q2) { value = 1; } else if (val < q3) { value = 2; } else { value = 3; } freq.addValue(value); } long[] observed = new long[4]; for (int i=0; i<4; i++) { observed[i] = freq.getCount(i); } /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001 * Change to 11.34 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 16.27); } public void testNextBoolean() { long halfSampleSize = smallSampleSize / 2; double[] expected = {halfSampleSize, halfSampleSize}; long[] observed = new long[2]; for (int i=0; i<smallSampleSize; i++) { if (testGenerator.nextBoolean()) { observed[0]++; } else { observed[1]++; } } /* Use ChiSquare dist with df = 2-1 = 1, alpha = .001 * Change to 6.635 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 10.828); } public void testNextFloat() { Frequency freq = new Frequency(); float val = 0; int value = 0; for (int i=0; i<smallSampleSize; i++) { val = testGenerator.nextFloat(); if (val < 0.25) { value = 0; } else if (val < 0.5) { value = 1; } else if (val < 0.75) { value = 2; } else { value = 3; } freq.addValue(value); } long[] observed = new long[4]; for (int i=0; i<4; i++) { observed[i] = freq.getCount(i); } /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001 * Change to 11.34 for alpha = .01 */ assertTrue("chi-square test -- will fail about 1 in 1000 times", testStatistic.chiSquare(expected,observed) < 16.27); } }
//Licensed to the Apache Software Foundation (ASF) under one //or more contributor license agreements. See the NOTICE file //distributed with this work for additional information //regarding copyright ownership. The ASF licenses this file //to you under the Apache License, Version 2.0 (the //"License"); you may not use this file except in compliance //with the License. You may obtain a copy of the License at //http://www.apache.org/licenses/LICENSE-2.0 //Unless required by applicable law or agreed to in writing, //software distributed under the License is distributed on an //"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY //KIND, either express or implied. See the License for the //specific language governing permissions and limitations //under the License. package org.apache.commons.math.random; import org.apache.commons.math.stat.StatUtils; import junit.framework.*; public class GaussianRandomGeneratorTest extends TestCase { public GaussianRandomGeneratorTest(String name) { super(name); } public void testMeanAndStandardDeviation() { RandomGenerator rg = new JDKRandomGenerator(); rg.setSeed(17399225432l); GaussianRandomGenerator generator = new GaussianRandomGenerator(rg); double[] sample = new double[10000]; for (int i = 0; i < sample.length; ++i) { sample[i] = generator.nextNormalizedDouble(); } assertEquals(0.0, StatUtils.mean(sample), 0.012); assertEquals(1.0, StatUtils.variance(sample), 0.01); } public static Test suite() { return new TestSuite(GaussianRandomGeneratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for Lagrange form of polynomial function. * <p> * We use n+1 points to interpolate a polynomial of degree n. This should * give us the exact same polynomial as result. Thus we can use a very * small tolerance to account only for round-off errors. * * @version $Revision$ $Date$ */ public final class PolynomialFunctionLagrangeFormTest extends TestCase { /** * Test of polynomial for the linear function. */ public void testLinearFunction() throws MathException { PolynomialFunctionLagrangeForm p; double c[], z, expected, result, tolerance = 1E-12; // p(x) = 1.5x - 4 double x[] = { 0.0, 3.0 }; double y[] = { -4.0, 0.5 }; p = new PolynomialFunctionLagrangeForm(x, y); z = 2.0; expected = -1.0; result = p.value(z); assertEquals(expected, result, tolerance); z = 4.5; expected = 2.75; result = p.value(z); assertEquals(expected, result, tolerance); z = 6.0; expected = 5.0; result = p.value(z); assertEquals(expected, result, tolerance); assertEquals(1, p.degree()); c = p.getCoefficients(); assertEquals(2, c.length); assertEquals(-4.0, c[0], tolerance); assertEquals(1.5, c[1], tolerance); } /** * Test of polynomial for the quadratic function. */ public void testQuadraticFunction() throws MathException { PolynomialFunctionLagrangeForm p; double c[], z, expected, result, tolerance = 1E-12; // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3) double x[] = { 0.0, -1.0, 0.5 }; double y[] = { -3.0, -6.0, 0.0 }; p = new PolynomialFunctionLagrangeForm(x, y); z = 1.0; expected = 4.0; result = p.value(z); assertEquals(expected, result, tolerance); z = 2.5; expected = 22.0; result = p.value(z); assertEquals(expected, result, tolerance); z = -2.0; expected = -5.0; result = p.value(z); assertEquals(expected, result, tolerance); assertEquals(2, p.degree()); c = p.getCoefficients(); assertEquals(3, c.length); assertEquals(-3.0, c[0], tolerance); assertEquals(5.0, c[1], tolerance); assertEquals(2.0, c[2], tolerance); } /** * Test of polynomial for the quintic function. */ public void testQuinticFunction() throws MathException { PolynomialFunctionLagrangeForm p; double c[], z, expected, result, tolerance = 1E-12; // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3) double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 }; double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 }; p = new PolynomialFunctionLagrangeForm(x, y); z = 0.0; expected = 0.0; result = p.value(z); assertEquals(expected, result, tolerance); z = -2.0; expected = 0.0; result = p.value(z); assertEquals(expected, result, tolerance); z = 4.0; expected = 360.0; result = p.value(z); assertEquals(expected, result, tolerance); assertEquals(5, p.degree()); c = p.getCoefficients(); assertEquals(6, c.length); assertEquals(0.0, c[0], tolerance); assertEquals(6.0, c[1], tolerance); assertEquals(1.0, c[2], tolerance); assertEquals(-7.0, c[3], tolerance); assertEquals(-1.0, c[4], tolerance); assertEquals(1.0, c[5], tolerance); } /** * Test of parameters for the polynomial. */ public void testParameters() throws Exception { try { // bad input array length double x[] = { 1.0 }; double y[] = { 2.0 }; new PolynomialFunctionLagrangeForm(x, y); fail("Expecting IllegalArgumentException - bad input array length"); } catch (IllegalArgumentException ex) { // expected } try { // mismatch input arrays double x[] = { 1.0, 2.0, 3.0, 4.0 }; double y[] = { 0.0, -4.0, -24.0 }; new PolynomialFunctionLagrangeForm(x, y); fail("Expecting IllegalArgumentException - mismatch input arrays"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import org.apache.commons.math.TestUtils; import org.apache.commons.math.complex.Complex; import junit.framework.TestCase; /** * Testcase for Laguerre solver. * <p> * Laguerre's method is very efficient in solving polynomials. Test runs * show that for a default absolute accuracy of 1E-6, it generally takes * less than 5 iterations to find one root, provided solveAll() is not * invoked, and 15 to 20 iterations to find all roots for quintic function. * * @version $Revision$ $Date$ */ public final class LaguerreSolverTest extends TestCase { /** * Test of solver for the linear function. */ public void testLinearFunction() throws MathException { double min, max, expected, result, tolerance; // p(x) = 4x - 1 double coefficients[] = { -1.0, 4.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); UnivariateRealSolver solver = new LaguerreSolver(f); min = 0.0; max = 1.0; expected = 0.25; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the quadratic function. */ public void testQuadraticFunction() throws MathException { double min, max, expected, result, tolerance; // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1) double coefficients[] = { -3.0, 5.0, 2.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); UnivariateRealSolver solver = new LaguerreSolver(f); min = 0.0; max = 2.0; expected = 0.5; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -4.0; max = -1.0; expected = -3.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function. */ public void testQuinticFunction() throws MathException { double min, max, expected, result, tolerance; // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1) double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); UnivariateRealSolver solver = new LaguerreSolver(f); min = -2.0; max = 2.0; expected = -1.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -5.0; max = -2.5; expected = -3.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = 3.0; max = 6.0; expected = 4.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function using solveAll(). */ public void testQuinticFunction2() throws MathException { double initial = 0.0, tolerance; Complex expected, result[]; // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4) double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); LaguerreSolver solver = new LaguerreSolver(f); result = solver.solveAll(coefficients, initial); expected = new Complex(0.0, -2.0); tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected.abs() * solver.getRelativeAccuracy())); TestUtils.assertContains(result, expected, tolerance); expected = new Complex(0.0, 2.0); tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected.abs() * solver.getRelativeAccuracy())); TestUtils.assertContains(result, expected, tolerance); expected = new Complex(0.5, 0.5 * Math.sqrt(3.0)); tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected.abs() * solver.getRelativeAccuracy())); TestUtils.assertContains(result, expected, tolerance); expected = new Complex(-1.0, 0.0); tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected.abs() * solver.getRelativeAccuracy())); TestUtils.assertContains(result, expected, tolerance); expected = new Complex(0.5, -0.5 * Math.sqrt(3.0)); tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected.abs() * solver.getRelativeAccuracy())); TestUtils.assertContains(result, expected, tolerance); } /** * Test of parameters for the solver. */ public void testParameters() throws Exception { double coefficients[] = { -3.0, 5.0, 2.0 }; PolynomialFunction f = new PolynomialFunction(coefficients); UnivariateRealSolver solver = new LaguerreSolver(f); try { // bad interval solver.solve(1, -1); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // no bracketing solver.solve(2, 3); fail("Expecting IllegalArgumentException - no bracketing"); } catch (IllegalArgumentException ex) { // expected } try { // bad function UnivariateRealFunction f2 = new SinFunction(); new LaguerreSolver(f2); fail("Expecting IllegalArgumentException - bad function"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for Romberg integrator. * <p> * Romberg algorithm is very fast for good behavior integrand. Test runs * show that for a default relative accuracy of 1E-6, it generally takes * takes less than 5 iterations for the integral to converge. * * @version $Revision$ $Date$ */ public final class RombergIntegratorTest extends TestCase { /** * Test of integrator for the sine function. */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); UnivariateRealIntegrator integrator = new RombergIntegrator(f); double min, max, expected, result, tolerance; min = 0; max = Math.PI; expected = 2; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = -Math.PI/3; max = 0; expected = -0.5; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); } /** * Test of integrator for the quintic function. */ public void testQuinticFunction() throws MathException { UnivariateRealFunction f = new QuinticFunction(); UnivariateRealIntegrator integrator = new RombergIntegrator(f); double min, max, expected, result, tolerance; min = 0; max = 1; expected = -1.0/48; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = 0; max = 0.5; expected = 11.0/768; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); } /** * Test of parameters for the integrator. */ public void testParameters() throws Exception { UnivariateRealFunction f = new SinFunction(); UnivariateRealIntegrator integrator = new RombergIntegrator(f); try { // bad interval integrator.integrate(1, -1); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // bad iteration limits integrator.setMinimalIterationCount(5); integrator.setMaximalIterationCount(4); integrator.integrate(-1, 1); fail("Expecting IllegalArgumentException - bad iteration limits"); } catch (IllegalArgumentException ex) { // expected } try { // bad iteration limits integrator.setMinimalIterationCount(10); integrator.setMaximalIterationCount(50); integrator.integrate(-1, 1); fail("Expecting IllegalArgumentException - bad iteration limits"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.ConvergenceException; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class UnivariateRealSolverUtilsTest extends TestCase { protected UnivariateRealFunction sin = new SinFunction(); public void testSolveNull() throws MathException { try { UnivariateRealSolverUtils.solve(null, 0.0, 4.0); fail(); } catch(IllegalArgumentException ex){ // success } } public void testSolveBadParameters() throws MathException { try { // bad endpoints UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0); } catch (IllegalArgumentException ex) { // expected } try { // bad accuracy UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0); } catch (IllegalArgumentException ex) { // expected } } public void testSolveSin() throws MathException { double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0); assertEquals(Math.PI, x, 1.0e-4); } public void testSolveAccuracyNull() throws MathException { try { double accuracy = 1.0e-6; UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy); fail(); } catch(IllegalArgumentException ex){ // success } } public void testSolveAccuracySin() throws MathException { double accuracy = 1.0e-6; double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0, accuracy); assertEquals(Math.PI, x, accuracy); } public void testSolveNoRoot() throws MathException { try { UnivariateRealSolverUtils.solve(sin, 1.0, 1.5); fail("Expecting IllegalArgumentException "); } catch (IllegalArgumentException ex) { // expected } } public void testBracketSin() throws MathException { double[] result = UnivariateRealSolverUtils.bracket(sin, 0.0, -2.0, 2.0); assertTrue(sin.value(result[0]) < 0); assertTrue(sin.value(result[1]) > 0); } public void testBracketCornerSolution() throws MathException { try { UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0); fail("Expecting ConvergenceException"); } catch (ConvergenceException ex) { // expected } } public void testBadParameters() throws MathException { try { // null function UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { // initial not between endpoints UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { // endpoints not valid UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { // bad maximum iterations UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import java.util.Arrays; import junit.framework.TestCase; import org.apache.commons.math.FunctionEvaluationException; /** * Tests the PolynomialSplineFunction implementation. * * @version $Revision$ */ public class PolynomialSplineFunctionTest extends TestCase { /** Error tolerance for tests */ protected double tolerance = 1.0e-12; /** * Quadratic polynomials used in tests: * * x^2 + x [-1, 0) * x^2 + x + 2 [0, 1) * x^2 + x + 4 [1, 2) * * Defined so that evaluation using PolynomialSplineFunction evaluation * algorithm agrees at knot point boundaries. */ protected PolynomialFunction[] polynomials = { new PolynomialFunction(new double[] {0d, 1d, 1d}), new PolynomialFunction(new double[] {2d, 1d, 1d}), new PolynomialFunction(new double[] {4d, 1d, 1d}) }; /** Knot points */ protected double[] knots = {-1, 0, 1, 2}; /** Derivative of test polynomials -- 2x + 1 */ protected PolynomialFunction dp = new PolynomialFunction(new double[] {1d, 2d}); public void testConstructor() { PolynomialSplineFunction spline = new PolynomialSplineFunction(knots, polynomials); assertTrue(Arrays.equals(knots, spline.getKnots())); assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0); assertEquals(3, spline.getN()); try { // too few knots new PolynomialSplineFunction(new double[] {0}, polynomials); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { // too many knots new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { // knots not increasing new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } public void testValues() throws Exception { PolynomialSplineFunction spline = new PolynomialSplineFunction(knots, polynomials); UnivariateRealFunction dSpline = spline.derivative(); /** * interior points -- spline value at x should equal p(x - knot) * where knot is the largest knot point less than or equal to x and p * is the polynomial defined over the knot segment to which x belongs. */ double x = -1; int index = 0; for (int i = 0; i < 10; i++) { x+=0.25; index = findKnot(knots, x); assertEquals("spline function evaluation failed for x=" + x, polynomials[index].value(x - knots[index]), spline.value(x), tolerance); assertEquals("spline derivative evaluation failed for x=" + x, dp.value(x - knots[index]), dSpline.value(x), tolerance); } // knot points -- centering should zero arguments for (int i = 0; i < 3; i++) { assertEquals("spline function evaluation failed for knot=" + knots[i], polynomials[i].value(0), spline.value(knots[i]), tolerance); assertEquals("spline function evaluation failed for knot=" + knots[i], dp.value(0), dSpline.value(knots[i]), tolerance); } try { //outside of domain -- under min x = spline.value(-1.5); fail("Expecting IllegalArgumentException"); } catch (FunctionEvaluationException ex) { // expected } try { //outside of domain -- over max x = spline.value(2.5); fail("Expecting IllegalArgumentException"); } catch (FunctionEvaluationException ex) { // expected } } /** * Do linear search to find largest knot point less than or equal to x. * Implementation does binary search. */ protected int findKnot(double[] knots, double x) { if (x < knots[0] || x >= knots[knots.length -1]) { throw new IllegalArgumentException("x is out of range"); } for (int i = 0; i < knots.length; i++) { if (knots[i] > x) { return i -1; } } throw new IllegalArgumentException("x is out of range"); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Testcase for UnivariateRealSolver. * Because Brent-Dekker is guaranteed to converge in less than the default * maximum iteration count due to bisection fallback, it is quite hard to * debug. I include measured iteration counts plus one in order to detect * regressions. On average Brent-Dekker should use 4..5 iterations for the * default absolute accuracy of 10E-8 for sinus and the quintic function around * zero, and 5..10 iterations for the other zeros. * * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $ */ public final class BrentSolverTest extends TestCase { public BrentSolverTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(BrentSolverTest.class); suite.setName("UnivariateRealSolver Tests"); return suite; } public void testSinZero() throws MathException { // The sinus function is behaved well around the root at #pi. The second // order derivative is zero, which means linar approximating methods will // still converge quadratically. UnivariateRealFunction f = new SinFunction(); double result; UnivariateRealSolver solver = new BrentSolver(f); // Somewhat benign interval. The function is monotone. result = solver.solve(3, 4); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); // 4 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 5); // Larger and somewhat less benign interval. The function is grows first. result = solver.solve(1, 4); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); // 5 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 6); solver = new SecantSolver(f); result = solver.solve(3, 4); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); // 4 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 5); result = solver.solve(1, 4); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); // 5 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 6); assertEquals(result, solver.getResult(), 0); } public void testQuinticZero() throws MathException { // The quintic function has zeros at 0, +-0.5 and +-1. // Around the root of 0 the function is well behaved, with a second derivative // of zero a 0. // The other roots are less well to find, in particular the root at 1, because // the function grows fast for x>1. // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643, // intervals containing these values are harder for the solvers. UnivariateRealFunction f = new QuinticFunction(); double result; // Brent-Dekker solver. UnivariateRealSolver solver = new BrentSolver(f); // Symmetric bracket around 0. Test whether solvers can handle hitting // the root in the first iteration. result = solver.solve(-0.2, 0.2); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0, solver.getAbsoluteAccuracy()); assertTrue(solver.getIterationCount() <= 2); // 1 iterations on i586 JDK 1.4.1. // Asymmetric bracket around 0, just for fun. Contains extremum. result = solver.solve(-0.1, 0.3); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0, solver.getAbsoluteAccuracy()); // 5 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 6); // Large bracket around 0. Contains two extrema. result = solver.solve(-0.3, 0.45); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0, solver.getAbsoluteAccuracy()); // 6 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 7); // Benign bracket around 0.5, function is monotonous. result = solver.solve(0.3, 0.7); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); // 6 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 7); // Less benign bracket around 0.5, contains one extremum. result = solver.solve(0.2, 0.6); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); // 6 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 7); // Large, less benign bracket around 0.5, contains both extrema. result = solver.solve(0.05, 0.95); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); // 8 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 9); // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1 // is still a problem. result = solver.solve(0.85, 1.25); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 8 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 9); // Less benign bracket around 1 with extremum. result = solver.solve(0.8, 1.2); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 8 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 9); // Large bracket around 1. Monotonous. result = solver.solve(0.85, 1.75); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 10 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 11); // Large bracket around 1. Interval contains extremum. result = solver.solve(0.55, 1.45); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 7 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 8); // Very large bracket around 1 for testing fast growth behaviour. result = solver.solve(0.85, 5); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 12 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 13); // Secant solver. solver = new SecantSolver(f); result = solver.solve(-0.2, 0.2); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0, solver.getAbsoluteAccuracy()); // 1 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 2); result = solver.solve(-0.1, 0.3); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0, solver.getAbsoluteAccuracy()); // 5 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 6); result = solver.solve(-0.3, 0.45); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0, solver.getAbsoluteAccuracy()); // 6 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 7); result = solver.solve(0.3, 0.7); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); // 7 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 8); result = solver.solve(0.2, 0.6); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); // 6 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 7); result = solver.solve(0.05, 0.95); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); // 8 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 9); result = solver.solve(0.85, 1.25); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 10 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 11); result = solver.solve(0.8, 1.2); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 8 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 9); result = solver.solve(0.85, 1.75); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 14 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 15); // The followig is especially slow because the solver first has to reduce // the bracket to exclude the extremum. After that, convergence is rapide. result = solver.solve(0.55, 1.45); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 7 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 8); result = solver.solve(0.85, 5); //System.out.println( // "Root: " + result + " Iterations: " + solver.getIterationCount()); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); // 14 iterations on i586 JDK 1.4.1. assertTrue(solver.getIterationCount() <= 15); // Static solve method result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2); assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3); assertEquals(result, 0, 1E-8); result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45); assertEquals(result, 0, 1E-6); result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7); assertEquals(result, 0.5, 1E-6); result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6); assertEquals(result, 0.5, 1E-6); result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95); assertEquals(result, 0.5, 1E-6); result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25); assertEquals(result, 1.0, 1E-6); result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2); assertEquals(result, 1.0, 1E-6); result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75); assertEquals(result, 1.0, 1E-6); result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45); assertEquals(result, 1.0, 1E-6); result = UnivariateRealSolverUtils.solve(f, 0.85, 5); assertEquals(result, 1.0, 1E-6); } public void testRootEndpoints() throws Exception { UnivariateRealFunction f = new SinFunction(); UnivariateRealSolver solver = new BrentSolver(f); // endpoint is root double result = solver.solve(Math.PI, 4); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); result = solver.solve(3, Math.PI); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); } public void testBadEndpoints() throws Exception { UnivariateRealFunction f = new SinFunction(); UnivariateRealSolver solver = new BrentSolver(f); try { // bad interval solver.solve(1, -1); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // no bracket solver.solve(1, 1.5); fail("Expecting IllegalArgumentException - non-bracketing"); } catch (IllegalArgumentException ex) { // expected } } public void testInitialGuess() throws MathException { MonitoredFunction f = new MonitoredFunction(new QuinticFunction()); UnivariateRealSolver solver = new BrentSolver(f); double result; // no guess result = solver.solve(0.6, 7.0); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); int referenceCallsCount = f.getCallsCount(); assertTrue(referenceCallsCount >= 13); // invalid guess (it *is* a root, but outside of the range) try { result = solver.solve(0.6, 7.0, 0.0); fail("an IllegalArgumentException was expected"); } catch (IllegalArgumentException iae) { // expected behaviour } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } // bad guess f.setCallsCount(0); result = solver.solve(0.6, 7.0, 0.61); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertTrue(f.getCallsCount() > referenceCallsCount); // good guess f.setCallsCount(0); result = solver.solve(0.6, 7.0, 0.999999); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertTrue(f.getCallsCount() < referenceCallsCount); // perfect guess f.setCallsCount(0); result = solver.solve(0.6, 7.0, 1.0); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(0, solver.getIterationCount()); assertEquals(1, f.getCallsCount()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for Ridders solver. * <p> * Ridders' method converges superlinearly, more specific, its rate of * convergence is sqrt(2). Test runs show that for a default absolute * accuracy of 1E-6, it generally takes less than 5 iterations for close * initial bracket and 5 to 10 iterations for distant initial bracket * to converge. * * @version $Revision$ $Date$ */ public final class RiddersSolverTest extends TestCase { /** * Test of solver for the sine function. */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); UnivariateRealSolver solver = new RiddersSolver(f); double min, max, expected, result, tolerance; min = 3.0; max = 4.0; expected = Math.PI; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -1.0; max = 1.5; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function. */ public void testQuinticFunction() throws MathException { UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new RiddersSolver(f); double min, max, expected, result, tolerance; min = -0.4; max = 0.2; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = 0.75; max = 1.5; expected = 1.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -0.9; max = -0.2; expected = -0.5; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the exponential function. */ public void testExpm1Function() throws MathException { UnivariateRealFunction f = new Expm1Function(); UnivariateRealSolver solver = new RiddersSolver(f); double min, max, expected, result, tolerance; min = -1.0; max = 2.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -20.0; max = 10.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -50.0; max = 100.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of parameters for the solver. */ public void testParameters() throws Exception { UnivariateRealFunction f = new SinFunction(); UnivariateRealSolver solver = new RiddersSolver(f); try { // bad interval solver.solve(1, -1); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // no bracketing solver.solve(2, 3); fail("Expecting IllegalArgumentException - no bracketing"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for Simpson integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 5 to 10 iterations for the integral to converge. * * @version $Revision$ $Date$ */ public final class SimpsonIntegratorTest extends TestCase { /** * Test of integrator for the sine function. */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); UnivariateRealIntegrator integrator = new SimpsonIntegrator(f); double min, max, expected, result, tolerance; min = 0; max = Math.PI; expected = 2; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = -Math.PI/3; max = 0; expected = -0.5; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); } /** * Test of integrator for the quintic function. */ public void testQuinticFunction() throws MathException { UnivariateRealFunction f = new QuinticFunction(); UnivariateRealIntegrator integrator = new SimpsonIntegrator(f); double min, max, expected, result, tolerance; min = 0; max = 1; expected = -1.0/48; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = 0; max = 0.5; expected = 11.0/768; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); } /** * Test of parameters for the integrator. */ public void testParameters() throws Exception { UnivariateRealFunction f = new SinFunction(); UnivariateRealIntegrator integrator = new SimpsonIntegrator(f); try { // bad interval integrator.integrate(1, -1); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // bad iteration limits integrator.setMinimalIterationCount(5); integrator.setMaximalIterationCount(4); integrator.integrate(-1, 1); fail("Expecting IllegalArgumentException - bad iteration limits"); } catch (IllegalArgumentException ex) { // expected } try { // bad iteration limits integrator.setMinimalIterationCount(10); integrator.setMaximalIterationCount(99); integrator.integrate(-1, 1); fail("Expecting IllegalArgumentException - bad iteration limits"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import org.apache.commons.math.TestUtils; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test the SplineInterpolator. * * @version $Revision$ $Date$ */ public class SplineInterpolatorTest extends TestCase { /** error tolerance for spline interpolator value at knot points */ protected double knotTolerance = 1E-12; /** error tolerance for interpolating polynomial coefficients */ protected double coefficientTolerance = 1E-6; /** error tolerance for interpolated values -- high value is from sin test */ protected double interpolationTolerance = 1E-2; public SplineInterpolatorTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(SplineInterpolatorTest.class); suite.setName("UnivariateRealInterpolator Tests"); return suite; } public void testInterpolateLinearDegenerateTwoSegment() throws Exception { double x[] = { 0.0, 0.5, 1.0 }; double y[] = { 0.0, 0.5, 1.0 }; UnivariateRealInterpolator i = new SplineInterpolator(); UnivariateRealFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); verifyConsistency((PolynomialSplineFunction) f, x); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1d, 0d, 0d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 1d, 0d, 0d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); // Check interpolation assertEquals(0.0,f.value(0.0), interpolationTolerance); assertEquals(0.4,f.value(0.4), interpolationTolerance); assertEquals(1.0,f.value(1.0), interpolationTolerance); } public void testInterpolateLinearDegenerateThreeSegment() throws Exception { double x[] = { 0.0, 0.5, 1.0, 1.5 }; double y[] = { 0.0, 0.5, 1.0, 1.5 }; UnivariateRealInterpolator i = new SplineInterpolator(); UnivariateRealFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1d, 0d, 0d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 1d, 0d, 0d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); target = new double[]{y[2], 1d, 0d, 0d}; TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance); // Check interpolation assertEquals(0,f.value(0), interpolationTolerance); assertEquals(1.4,f.value(1.4), interpolationTolerance); assertEquals(1.5,f.value(1.5), interpolationTolerance); } public void testInterpolateLinear() throws Exception { double x[] = { 0.0, 0.5, 1.0 }; double y[] = { 0.0, 0.5, 0.0 }; UnivariateRealInterpolator i = new SplineInterpolator(); UnivariateRealFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); verifyConsistency((PolynomialSplineFunction) f, x); // Verify coefficients using analytical values PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1.5d, 0d, -2d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 0d, -3d, 2d}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); } public void testInterpolateSin() throws Exception { double x[] = { 0.0, Math.PI / 6d, Math.PI / 2d, 5d * Math.PI / 6d, Math.PI, 7d * Math.PI / 6d, 3d * Math.PI / 2d, 11d * Math.PI / 6d, 2.d * Math.PI }; double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d }; UnivariateRealInterpolator i = new SplineInterpolator(); UnivariateRealFunction f = i.interpolate(x, y); verifyInterpolation(f, x, y); verifyConsistency((PolynomialSplineFunction) f, x); /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9) * * To replicate in R: * x[1] <- 0 * x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values) * g <- splinefun(x, y, "natural") * splinecoef <- eval(expression(z), envir = environment(g)) * print(splinecoef) */ PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials(); double target[] = {y[0], 1.002676d, 0d, -0.17415829d}; TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance); target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914}; TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance); target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914}; TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance); target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829}; TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance); target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829}; TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance); target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914}; TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance); target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914}; TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance); target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829}; TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance); //Check interpolation assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance); assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance); } public void testIllegalArguments() throws MathException { // Data set arrays of different size. UnivariateRealInterpolator i = new SplineInterpolator(); try { double xval[] = { 0.0, 1.0 }; double yval[] = { 0.0, 1.0, 2.0 }; i.interpolate(xval, yval); fail("Failed to detect data set array with different sizes."); } catch (IllegalArgumentException iae) { } // X values not sorted. try { double xval[] = { 0.0, 1.0, 0.5 }; double yval[] = { 0.0, 1.0, 2.0 }; i.interpolate(xval, yval); fail("Failed to detect unsorted arguments."); } catch (IllegalArgumentException iae) { } } /** * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length. */ protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[]) throws Exception{ for (int i = 0; i < x.length; i++) { assertEquals(f.value(x[i]), y[i], knotTolerance); } } /** * Verifies that interpolating polynomials satisfy consistency requirement: * adjacent polynomials must agree through two derivatives at knot points */ protected void verifyConsistency(PolynomialSplineFunction f, double x[]) throws Exception { PolynomialFunction polynomials[] = f.getPolynomials(); for (int i = 1; i < x.length - 2; i++) { // evaluate polynomials and derivatives at x[i + 1] assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1); assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]), polynomials[i + 1].derivative().value(0), 0.5); assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]), polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for Newton form of polynomial function. * <p> * The small tolerance number is used only to account for round-off errors. * * @version $Revision$ $Date$ */ public final class PolynomialFunctionNewtonFormTest extends TestCase { /** * Test of polynomial for the linear function. */ public void testLinearFunction() throws MathException { PolynomialFunctionNewtonForm p; double coefficients[], z, expected, result, tolerance = 1E-12; // p(x) = 1.5x - 4 = 2 + 1.5(x-4) double a[] = { 2.0, 1.5 }; double c[] = { 4.0 }; p = new PolynomialFunctionNewtonForm(a, c); z = 2.0; expected = -1.0; result = p.value(z); assertEquals(expected, result, tolerance); z = 4.5; expected = 2.75; result = p.value(z); assertEquals(expected, result, tolerance); z = 6.0; expected = 5.0; result = p.value(z); assertEquals(expected, result, tolerance); assertEquals(1, p.degree()); coefficients = p.getCoefficients(); assertEquals(2, coefficients.length); assertEquals(-4.0, coefficients[0], tolerance); assertEquals(1.5, coefficients[1], tolerance); } /** * Test of polynomial for the quadratic function. */ public void testQuadraticFunction() throws MathException { PolynomialFunctionNewtonForm p; double coefficients[], z, expected, result, tolerance = 1E-12; // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2) double a[] = { 4.0, 3.0, 2.0 }; double c[] = { 1.0, -2.0 }; p = new PolynomialFunctionNewtonForm(a, c); z = 1.0; expected = 4.0; result = p.value(z); assertEquals(expected, result, tolerance); z = 2.5; expected = 22.0; result = p.value(z); assertEquals(expected, result, tolerance); z = -2.0; expected = -5.0; result = p.value(z); assertEquals(expected, result, tolerance); assertEquals(2, p.degree()); coefficients = p.getCoefficients(); assertEquals(3, coefficients.length); assertEquals(-3.0, coefficients[0], tolerance); assertEquals(5.0, coefficients[1], tolerance); assertEquals(2.0, coefficients[2], tolerance); } /** * Test of polynomial for the quintic function. */ public void testQuinticFunction() throws MathException { PolynomialFunctionNewtonForm p; double coefficients[], z, expected, result, tolerance = 1E-12; // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x // = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2) double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 }; double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 }; p = new PolynomialFunctionNewtonForm(a, c); z = 0.0; expected = 0.0; result = p.value(z); assertEquals(expected, result, tolerance); z = -2.0; expected = 0.0; result = p.value(z); assertEquals(expected, result, tolerance); z = 4.0; expected = 360.0; result = p.value(z); assertEquals(expected, result, tolerance); assertEquals(5, p.degree()); coefficients = p.getCoefficients(); assertEquals(6, coefficients.length); assertEquals(0.0, coefficients[0], tolerance); assertEquals(6.0, coefficients[1], tolerance); assertEquals(1.0, coefficients[2], tolerance); assertEquals(-7.0, coefficients[3], tolerance); assertEquals(-1.0, coefficients[4], tolerance); assertEquals(1.0, coefficients[5], tolerance); } /** * Test of parameters for the polynomial. */ public void testParameters() throws Exception { try { // bad input array length double a[] = { 1.0 }; double c[] = { 2.0 }; new PolynomialFunctionNewtonForm(a, c); fail("Expecting IllegalArgumentException - bad input array length"); } catch (IllegalArgumentException ex) { // expected } try { // mismatch input arrays double a[] = { 1.0, 2.0, 3.0, 4.0 }; double c[] = { 4.0, 3.0, 2.0, 1.0 }; new PolynomialFunctionNewtonForm(a, c); fail("Expecting IllegalArgumentException - mismatch input arrays"); } catch (IllegalArgumentException ex) { // expected } } }
/* * * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class UnivariateRealSolverFactoryImplTest extends TestCase { /** solver factory */ private UnivariateRealSolverFactory factory; /** function */ private DifferentiableUnivariateRealFunction function; /** * @throws java.lang.Exception * @see junit.framework.TestCase#tearDown() */ protected void setUp() throws Exception { super.setUp(); factory = new UnivariateRealSolverFactoryImpl(); function = new SinFunction(); } /** * @throws java.lang.Exception * @see junit.framework.TestCase#tearDown() */ protected void tearDown() throws Exception { factory = null; function = null; super.tearDown(); } public void testNewBisectionSolverNull() { try { factory.newBisectionSolver(null); fail(); } catch(IllegalArgumentException ex) { // success } } public void testNewBisectionSolverValid() { UnivariateRealSolver solver = factory.newBisectionSolver(function); assertNotNull(solver); assertTrue(solver instanceof BisectionSolver); } public void testNewNewtonSolverNull() { try { factory.newNewtonSolver(null); fail(); } catch(IllegalArgumentException ex) { // success } } public void testNewNewtonSolverValid() { UnivariateRealSolver solver = factory.newNewtonSolver(function); assertNotNull(solver); assertTrue(solver instanceof NewtonSolver); } public void testNewBrentSolverNull() { try { factory.newBrentSolver(null); fail(); } catch(IllegalArgumentException ex) { // success } } public void testNewBrentSolverValid() { UnivariateRealSolver solver = factory.newBrentSolver(function); assertNotNull(solver); assertTrue(solver instanceof BrentSolver); } public void testNewSecantSolverNull() { try { factory.newSecantSolver(null); fail(); } catch(IllegalArgumentException ex) { // success } } public void testNewSecantSolverValid() { UnivariateRealSolver solver = factory.newSecantSolver(function); assertNotNull(solver); assertTrue(solver instanceof SecantSolver); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import org.apache.commons.math.TestUtils; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public final class NewtonSolverTest extends TestCase { /** * */ public void testSinZero() throws MathException { DifferentiableUnivariateRealFunction f = new SinFunction(); double result; UnivariateRealSolver solver = new NewtonSolver(f); result = solver.solve(3, 4); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); result = solver.solve(1, 4); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); //TODO: create abstract solver test class, move these there assertEquals(result, solver.getResult(), 0); assertTrue(solver.getIterationCount() > 0); } /** * */ public void testQuinticZero() throws MathException { DifferentiableUnivariateRealFunction f = new QuinticFunction(); double result; UnivariateRealSolver solver = new BisectionSolver(f); result = solver.solve(-0.2, 0.2); assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(-0.1, 0.3); assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(-0.3, 0.45); assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(0.3, 0.7); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(0.2, 0.6); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(0.05, 0.95); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(0.85, 1.25); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(0.8, 1.2); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(0.85, 1.75); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(0.55, 1.45); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(0.85, 5); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); } /** * Test Serialization and Recovery */ public void testSerialization() throws MathException { DifferentiableUnivariateRealFunction f = new QuinticFunction(); double result; NewtonSolver solver = new NewtonSolver(f); NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver); result = solver.solve(-0.2, 0.2); assertEquals(result, 0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy()); result = solver.solve(-0.1, 0.3); assertEquals(result, 0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy()); result = solver.solve(-0.3, 0.45); assertEquals(result, 0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.3, 0.7); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.2, 0.6); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.05, 0.95); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.85, 1.25); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.8, 1.2); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.85, 1.75); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.55, 1.45); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.85, 5); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy()); /* Test Reset */ double newValue = 1.0e-2; f = new QuinticFunction(); solver = new NewtonSolver(f); double oldValue = solver.getRelativeAccuracy(); solver.setRelativeAccuracy(newValue); solver.resetRelativeAccuracy(); assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2); solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver); assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2); solver2.setRelativeAccuracy(newValue); solver2.resetRelativeAccuracy(); assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for Muller solver. * <p> * Muller's method converges almost quadratically near roots, but it can * be very slow in regions far away from zeros. Test runs show that for * reasonably good initial values, for a default absolute accuracy of 1E-6, * it generally takes 5 to 10 iterations for the solver to converge. * <p> * Tests for the exponential function illustrate the situations where * Muller solver performs poorly. * * @version $Revision$ $Date$ */ public final class MullerSolverTest extends TestCase { /** * Test of solver for the sine function. */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); UnivariateRealSolver solver = new MullerSolver(f); double min, max, expected, result, tolerance; min = 3.0; max = 4.0; expected = Math.PI; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -1.0; max = 1.5; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the sine function using solve2(). */ public void testSinFunction2() throws MathException { UnivariateRealFunction f = new SinFunction(); MullerSolver solver = new MullerSolver(f); double min, max, expected, result, tolerance; min = 3.0; max = 4.0; expected = Math.PI; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve2(min, max); assertEquals(expected, result, tolerance); min = -1.0; max = 1.5; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve2(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function. */ public void testQuinticFunction() throws MathException { UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new MullerSolver(f); double min, max, expected, result, tolerance; min = -0.4; max = 0.2; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = 0.75; max = 1.5; expected = 1.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -0.9; max = -0.2; expected = -0.5; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the quintic function using solve2(). */ public void testQuinticFunction2() throws MathException { UnivariateRealFunction f = new QuinticFunction(); MullerSolver solver = new MullerSolver(f); double min, max, expected, result, tolerance; min = -0.4; max = 0.2; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve2(min, max); assertEquals(expected, result, tolerance); min = 0.75; max = 1.5; expected = 1.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve2(min, max); assertEquals(expected, result, tolerance); min = -0.9; max = -0.2; expected = -0.5; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve2(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the exponential function. * <p> * It takes 10 to 15 iterations for the last two tests to converge. * In fact, if not for the bisection alternative, the solver would * exceed the default maximal iteration of 100. */ public void testExpm1Function() throws MathException { UnivariateRealFunction f = new Expm1Function(); UnivariateRealSolver solver = new MullerSolver(f); double min, max, expected, result, tolerance; min = -1.0; max = 2.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -20.0; max = 10.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); min = -50.0; max = 100.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve(min, max); assertEquals(expected, result, tolerance); } /** * Test of solver for the exponential function using solve2(). * <p> * It takes 25 to 50 iterations for the last two tests to converge. */ public void testExpm1Function2() throws MathException { UnivariateRealFunction f = new Expm1Function(); MullerSolver solver = new MullerSolver(f); double min, max, expected, result, tolerance; min = -1.0; max = 2.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve2(min, max); assertEquals(expected, result, tolerance); min = -20.0; max = 10.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve2(min, max); assertEquals(expected, result, tolerance); min = -50.0; max = 100.0; expected = 0.0; tolerance = Math.max(solver.getAbsoluteAccuracy(), Math.abs(expected * solver.getRelativeAccuracy())); result = solver.solve2(min, max); assertEquals(expected, result, tolerance); } /** * Test of parameters for the solver. */ public void testParameters() throws Exception { UnivariateRealFunction f = new SinFunction(); UnivariateRealSolver solver = new MullerSolver(f); try { // bad interval solver.solve(1, -1); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // no bracketing solver.solve(2, 3); fail("Expecting IllegalArgumentException - no bracketing"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; // commons-math import org.apache.commons.math.MathException; // junit import junit.framework.TestCase; /** * Tests the PolynomialFunction implementation of a UnivariateRealFunction. * * @version $Revision$ * @author Matt Cliff <matt@mattcliff.com> */ public final class PolynomialFunctionTest extends TestCase { /** Error tolerance for tests */ protected double tolerance = 1.0e-12; /** * tests the value of a constant polynomial. * * <p>value of this is 2.5 everywhere.</p> */ public void testConstants() throws MathException { double[] c = { 2.5 }; PolynomialFunction f = new PolynomialFunction( c ); // verify that we are equal to c[0] at several (nonsymmetric) places assertEquals( f.value( 0.0), c[0], tolerance ); assertEquals( f.value( -1.0), c[0], tolerance ); assertEquals( f.value( -123.5), c[0], tolerance ); assertEquals( f.value( 3.0), c[0], tolerance ); assertEquals( f.value( 456.89), c[0], tolerance ); assertEquals(f.degree(), 0); assertEquals(f.derivative().value(0), 0, tolerance); assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance); } /** * tests the value of a linear polynomial. * * <p>This will test the function f(x) = 3*x - 1.5</p> * <p>This will have the values * <tt>f(0.0) = -1.5, f(-1.0) = -4.5, f(-2.5) = -9.0, * f(0.5) = 0.0, f(1.5) = 3.0</tt> and <tt>f(3.0) = 7.5</tt> * </p> */ public void testLinear() throws MathException { double[] c = { -1.5, 3.0 }; PolynomialFunction f = new PolynomialFunction( c ); // verify that we are equal to c[0] when x=0 assertEquals( f.value( 0.0), c[0], tolerance ); // now check a few other places assertEquals( -4.5, f.value( -1.0), tolerance ); assertEquals( -9.0, f.value( -2.5), tolerance ); assertEquals( 0.0, f.value( 0.5), tolerance ); assertEquals( 3.0, f.value( 1.5), tolerance ); assertEquals( 7.5, f.value( 3.0), tolerance ); assertEquals(f.degree(), 1); assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance); } /** * Tests a second order polynomial. * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p> * */ public void testQuadratic() throws MathException { double[] c = { -2.0, -3.0, 2.0 }; PolynomialFunction f = new PolynomialFunction( c ); // verify that we are equal to c[0] when x=0 assertEquals( f.value( 0.0), c[0], tolerance ); // now check a few other places assertEquals( 0.0, f.value( -0.5), tolerance ); assertEquals( 0.0, f.value( 2.0), tolerance ); assertEquals( -2.0, f.value( 1.5), tolerance ); assertEquals( 7.0, f.value( -1.5), tolerance ); assertEquals( 265.5312, f.value( 12.34), tolerance ); } /** * This will test the quintic function * f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p> * */ public void testQuintic() throws MathException { double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 }; PolynomialFunction f = new PolynomialFunction( c ); // verify that we are equal to c[0] when x=0 assertEquals( f.value( 0.0), c[0], tolerance ); // now check a few other places assertEquals( 0.0, f.value( 5.0), tolerance ); assertEquals( 0.0, f.value( 1.0), tolerance ); assertEquals( 0.0, f.value( -3.0), tolerance ); assertEquals( 54.84375, f.value( -1.5), tolerance ); assertEquals( -8.06637, f.value( 1.3), tolerance ); assertEquals(f.degree(), 5); } /** * tests the firstDerivative function by comparison * * <p>This will test the functions * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt> * and <tt>h(x) = 6x - 4</tt> */ public void testfirstDerivativeComparison() throws MathException { double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 }; double[] g_coeff = { 6.0, -4.0, 3.0 }; double[] h_coeff = { -4.0, 6.0 }; PolynomialFunction f = new PolynomialFunction( f_coeff ); PolynomialFunction g = new PolynomialFunction( g_coeff ); PolynomialFunction h = new PolynomialFunction( h_coeff ); // compare f' = g assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance ); assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance ); assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance ); assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance ); assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance ); // compare g' = h assertEquals( g.derivative().value(Math.PI), h.value(Math.PI), tolerance ); assertEquals( g.derivative().value(Math.E), h.value(Math.E), tolerance ); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for Neville interpolator. * <p> * The error of polynomial interpolation is * f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. * * @version $Revision$ $Date$ */ public final class NevilleInterpolatorTest extends TestCase { /** * Test of interpolator for the sine function. * <p> * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI] */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); UnivariateRealInterpolator interpolator = new NevilleInterpolator(); double x[], y[], z, expected, result, tolerance; // 6 interpolating points on interval [0, 2*PI] int n = 6; double min = 0.0, max = 2 * Math.PI; x = new double[n]; y = new double[n]; for (int i = 0; i < n; i++) { x[i] = min + i * (max - min) / n; y[i] = f.value(x[i]); } double derivativebound = 1.0; UnivariateRealFunction p = interpolator.interpolate(x, y); z = Math.PI / 4; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); z = Math.PI * 1.5; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); } /** * Test of interpolator for the exponential function. * <p> * |expm1^(n)(zeta)| <= e, zeta in [-1, 1] */ public void testExpm1Function() throws MathException { UnivariateRealFunction f = new Expm1Function(); UnivariateRealInterpolator interpolator = new NevilleInterpolator(); double x[], y[], z, expected, result, tolerance; // 5 interpolating points on interval [-1, 1] int n = 5; double min = -1.0, max = 1.0; x = new double[n]; y = new double[n]; for (int i = 0; i < n; i++) { x[i] = min + i * (max - min) / n; y[i] = f.value(x[i]); } double derivativebound = Math.E; UnivariateRealFunction p = interpolator.interpolate(x, y); z = 0.0; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); z = 0.5; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); z = -0.5; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); } /** * Test of parameters for the interpolator. */ public void testParameters() throws Exception { UnivariateRealInterpolator interpolator = new NevilleInterpolator(); try { // bad abscissas array double x[] = { 1.0, 2.0, 2.0, 4.0 }; double y[] = { 0.0, 4.0, 4.0, 2.5 }; UnivariateRealFunction p = interpolator.interpolate(x, y); p.value(0.0); fail("Expecting MathException - bad abscissas array"); } catch (MathException ex) { // expected } } /** * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n! */ protected double partialerror(double x[], double z) throws IllegalArgumentException { if (x.length < 1) { throw new IllegalArgumentException ("Interpolation array cannot be empty."); } double out = 1; for (int i = 0; i < x.length; i++) { out *= (z - x[i]) / (i + 1); } return out; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for trapezoid integrator. * <p> * Test runs show that for a default relative accuracy of 1E-6, it * generally takes 10 to 15 iterations for the integral to converge. * * @version $Revision$ $Date$ */ public final class TrapezoidIntegratorTest extends TestCase { /** * Test of integrator for the sine function. */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f); double min, max, expected, result, tolerance; min = 0; max = Math.PI; expected = 2; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = -Math.PI/3; max = 0; expected = -0.5; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); } /** * Test of integrator for the quintic function. */ public void testQuinticFunction() throws MathException { UnivariateRealFunction f = new QuinticFunction(); UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f); double min, max, expected, result, tolerance; min = 0; max = 1; expected = -1.0/48; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = 0; max = 0.5; expected = 11.0/768; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48; tolerance = Math.abs(expected * integrator.getRelativeAccuracy()); result = integrator.integrate(min, max); assertEquals(expected, result, tolerance); } /** * Test of parameters for the integrator. */ public void testParameters() throws Exception { UnivariateRealFunction f = new SinFunction(); UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f); try { // bad interval integrator.integrate(1, -1); fail("Expecting IllegalArgumentException - bad interval"); } catch (IllegalArgumentException ex) { // expected } try { // bad iteration limits integrator.setMinimalIterationCount(5); integrator.setMaximalIterationCount(4); integrator.integrate(-1, 1); fail("Expecting IllegalArgumentException - bad iteration limits"); } catch (IllegalArgumentException ex) { // expected } try { // bad iteration limits integrator.setMinimalIterationCount(10); integrator.setMaximalIterationCount(99); integrator.integrate(-1, 1); fail("Expecting IllegalArgumentException - bad iteration limits"); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import junit.framework.TestCase; /** * Testcase for Divided Difference interpolator. * <p> * The error of polynomial interpolation is * f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n! * where f^(n) is the n-th derivative of the approximated function and * zeta is some point in the interval determined by x[] and z. * <p> * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound * it and use the absolute value upper bound for estimates. For reference, * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2. * * @version $Revision$ $Date$ */ public final class DividedDifferenceInterpolatorTest extends TestCase { /** * Test of interpolator for the sine function. * <p> * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI] */ public void testSinFunction() throws MathException { UnivariateRealFunction f = new SinFunction(); UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator(); double x[], y[], z, expected, result, tolerance; // 6 interpolating points on interval [0, 2*PI] int n = 6; double min = 0.0, max = 2 * Math.PI; x = new double[n]; y = new double[n]; for (int i = 0; i < n; i++) { x[i] = min + i * (max - min) / n; y[i] = f.value(x[i]); } double derivativebound = 1.0; UnivariateRealFunction p = interpolator.interpolate(x, y); z = Math.PI / 4; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); z = Math.PI * 1.5; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); } /** * Test of interpolator for the exponential function. * <p> * |expm1^(n)(zeta)| <= e, zeta in [-1, 1] */ public void testExpm1Function() throws MathException { UnivariateRealFunction f = new Expm1Function(); UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator(); double x[], y[], z, expected, result, tolerance; // 5 interpolating points on interval [-1, 1] int n = 5; double min = -1.0, max = 1.0; x = new double[n]; y = new double[n]; for (int i = 0; i < n; i++) { x[i] = min + i * (max - min) / n; y[i] = f.value(x[i]); } double derivativebound = Math.E; UnivariateRealFunction p = interpolator.interpolate(x, y); z = 0.0; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); z = 0.5; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); z = -0.5; expected = f.value(z); result = p.value(z); tolerance = Math.abs(derivativebound * partialerror(x, z)); assertEquals(expected, result, tolerance); } /** * Test of parameters for the interpolator. */ public void testParameters() throws Exception { UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator(); try { // bad abscissas array double x[] = { 1.0, 2.0, 2.0, 4.0 }; double y[] = { 0.0, 4.0, 4.0, 2.5 }; UnivariateRealFunction p = interpolator.interpolate(x, y); p.value(0.0); fail("Expecting MathException - bad abscissas array"); } catch (MathException ex) { // expected } } /** * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n! */ protected double partialerror(double x[], double z) throws IllegalArgumentException { if (x.length < 1) { throw new IllegalArgumentException ("Interpolation array cannot be empty."); } double out = 1; for (int i = 0; i < x.length; i++) { out *= (z - x[i]) / (i + 1); } return out; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.analysis; import org.apache.commons.math.MathException; import org.apache.commons.math.TestUtils; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public final class BisectionSolverTest extends TestCase { /** * */ public void testSinZero() throws MathException { UnivariateRealFunction f = new SinFunction(); double result; UnivariateRealSolver solver = new BisectionSolver(f); result = solver.solve(3, 4); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); result = solver.solve(1, 4); assertEquals(result, Math.PI, solver.getAbsoluteAccuracy()); } /** * */ public void testQuinticZero() throws MathException { UnivariateRealFunction f = new QuinticFunction(); double result; UnivariateRealSolver solver = new BisectionSolver(f); result = solver.solve(-0.2, 0.2); assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(-0.1, 0.3); assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(-0.3, 0.45); assertEquals(result, 0, solver.getAbsoluteAccuracy()); result = solver.solve(0.3, 0.7); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(0.2, 0.6); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(0.05, 0.95); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); result = solver.solve(0.85, 1.25); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(0.8, 1.2); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(0.85, 1.75); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(0.55, 1.45); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); result = solver.solve(0.85, 5); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(result, solver.getResult(), 0); assertTrue(solver.getIterationCount() > 0); } /** * */ public void testSetFunctionValueAccuracy(){ double expected = 1.0e-2; UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new BisectionSolver(f); solver.setFunctionValueAccuracy(expected); assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2); } /** * */ public void testResetFunctionValueAccuracy(){ double newValue = 1.0e-2; UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new BisectionSolver(f); double oldValue = solver.getFunctionValueAccuracy(); solver.setFunctionValueAccuracy(newValue); solver.resetFunctionValueAccuracy(); assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2); } /** * */ public void testSetAbsoluteAccuracy(){ double expected = 1.0e-2; UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new BisectionSolver(f); solver.setAbsoluteAccuracy(expected); assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2); } /** * */ public void testResetAbsoluteAccuracy(){ double newValue = 1.0e-2; UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new BisectionSolver(f); double oldValue = solver.getAbsoluteAccuracy(); solver.setAbsoluteAccuracy(newValue); solver.resetAbsoluteAccuracy(); assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2); } /** * */ public void testSetMaximalIterationCount(){ int expected = 100; UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new BisectionSolver(f); solver.setMaximalIterationCount(expected); assertEquals(expected, solver.getMaximalIterationCount()); } /** * */ public void testResetMaximalIterationCount(){ int newValue = 10000; UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new BisectionSolver(f); int oldValue = solver.getMaximalIterationCount(); solver.setMaximalIterationCount(newValue); solver.resetMaximalIterationCount(); assertEquals(oldValue, solver.getMaximalIterationCount()); } /** * */ public void testSetRelativeAccuracy(){ double expected = 1.0e-2; UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new BisectionSolver(f); solver.setRelativeAccuracy(expected); assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2); } /** * */ public void testResetRelativeAccuracy(){ double newValue = 1.0e-2; UnivariateRealFunction f = new QuinticFunction(); UnivariateRealSolver solver = new BisectionSolver(f); double oldValue = solver.getRelativeAccuracy(); solver.setRelativeAccuracy(newValue); solver.resetRelativeAccuracy(); assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2); } /** * Test Serialization and Recovery */ public void testSerialization() throws MathException { UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction()); double result; BisectionSolver solver = new BisectionSolver(f); UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver); result = solver.solve(-0.2, 0.2); assertEquals(result, 0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(-0.2, 0.2), result, solver2.getAbsoluteAccuracy()); result = solver.solve(-0.1, 0.3); assertEquals(result, 0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(-0.1, 0.3), result, solver2.getAbsoluteAccuracy()); result = solver.solve(-0.3, 0.45); assertEquals(result, 0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(-0.3, 0.45), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.3, 0.7); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.3, 0.7), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.2, 0.6); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.2, 0.6), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.05, 0.95); assertEquals(result, 0.5, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.05, 0.95), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.85, 1.25); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.85, 1.25), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.8, 1.2); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.8, 1.2), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.85, 1.75); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.85, 1.75), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.55, 1.45); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.55, 1.45), result, solver2.getAbsoluteAccuracy()); result = solver.solve(0.85, 5); assertEquals(result, 1.0, solver.getAbsoluteAccuracy()); assertEquals(solver2.solve(0.85, 5), result, solver2.getAbsoluteAccuracy()); /* Test Reset */ double newValue = 1.0e-2; f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction()); solver = new BisectionSolver(f); double oldValue = solver.getRelativeAccuracy(); solver.setRelativeAccuracy(newValue); solver.resetRelativeAccuracy(); assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2); solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver); assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2); solver2.setRelativeAccuracy(newValue); solver2.resetRelativeAccuracy(); assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.fraction; import java.text.NumberFormat; import java.text.ParseException; import java.util.Locale; import junit.framework.TestCase; public class FractionFormatTest extends TestCase { FractionFormat properFormat = null; FractionFormat improperFormat = null; protected Locale getLocale() { return Locale.getDefault(); } protected void setUp() throws Exception { properFormat = FractionFormat.getProperInstance(getLocale()); improperFormat = FractionFormat.getImproperInstance(getLocale()); } public void testFormat() { Fraction c = new Fraction(1, 2); String expected = "1 / 2"; String actual = properFormat.format(c); assertEquals(expected, actual); actual = improperFormat.format(c); assertEquals(expected, actual); } public void testFormatNegative() { Fraction c = new Fraction(-1, 2); String expected = "-1 / 2"; String actual = properFormat.format(c); assertEquals(expected, actual); actual = improperFormat.format(c); assertEquals(expected, actual); } public void testFormatZero() { Fraction c = new Fraction(0, 1); String expected = "0 / 1"; String actual = properFormat.format(c); assertEquals(expected, actual); actual = improperFormat.format(c); assertEquals(expected, actual); } public void testFormatImproper() { Fraction c = new Fraction(5, 3); String actual = properFormat.format(c); assertEquals("1 2 / 3", actual); actual = improperFormat.format(c); assertEquals("5 / 3", actual); } public void testFormatImproperNegative() { Fraction c = new Fraction(-5, 3); String actual = properFormat.format(c); assertEquals("-1 2 / 3", actual); actual = improperFormat.format(c); assertEquals("-5 / 3", actual); } public void testParse() { String source = "1 / 2"; try { Fraction c = properFormat.parse(source); assertNotNull(c); assertEquals(1, c.getNumerator()); assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); assertNotNull(c); assertEquals(1, c.getNumerator()); assertEquals(2, c.getDenominator()); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseInteger() { String source = "10"; try { Fraction c = properFormat.parse(source); assertNotNull(c); assertEquals(10, c.getNumerator()); assertEquals(1, c.getDenominator()); } catch (ParseException ex) { fail(ex.getMessage()); } try { Fraction c = improperFormat.parse(source); assertNotNull(c); assertEquals(10, c.getNumerator()); assertEquals(1, c.getDenominator()); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseInvalid() { String source = "a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); fail(msg); } catch (ParseException ex) { // success } try { improperFormat.parse(source); fail(msg); } catch (ParseException ex) { // success } } public void testParseInvalidDenominator() { String source = "10 / a"; String msg = "should not be able to parse '10 / a'."; try { properFormat.parse(source); fail(msg); } catch (ParseException ex) { // success } try { improperFormat.parse(source); fail(msg); } catch (ParseException ex) { // success } } public void testParseNegative() { try { String source = "-1 / 2"; Fraction c = properFormat.parse(source); assertNotNull(c); assertEquals(-1, c.getNumerator()); assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); assertNotNull(c); assertEquals(-1, c.getNumerator()); assertEquals(2, c.getDenominator()); source = "1 / -2"; c = properFormat.parse(source); assertNotNull(c); assertEquals(-1, c.getNumerator()); assertEquals(2, c.getDenominator()); c = improperFormat.parse(source); assertNotNull(c); assertEquals(-1, c.getNumerator()); assertEquals(2, c.getDenominator()); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseProper() { String source = "1 2 / 3"; try { Fraction c = properFormat.parse(source); assertNotNull(c); assertEquals(5, c.getNumerator()); assertEquals(3, c.getDenominator()); } catch (ParseException ex) { fail(ex.getMessage()); } try { improperFormat.parse(source); fail("invalid improper fraction."); } catch (ParseException ex) { // success } } public void testParseProperNegative() { String source = "-1 2 / 3"; try { Fraction c = properFormat.parse(source); assertNotNull(c); assertEquals(-5, c.getNumerator()); assertEquals(3, c.getDenominator()); } catch (ParseException ex) { fail(ex.getMessage()); } try { improperFormat.parse(source); fail("invalid improper fraction."); } catch (ParseException ex) { // success } } public void testParseProperInvalidMinus() { String source = "2 -2 / 3"; try { properFormat.parse(source); fail("invalid minus in improper fraction."); } catch (ParseException ex) { // expected } source = "2 2 / -3"; try { properFormat.parse(source); fail("invalid minus in improper fraction."); } catch (ParseException ex) { // expected } } public void testNumeratorFormat() { NumberFormat old = properFormat.getNumeratorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setNumeratorFormat(nf); assertEquals(nf, properFormat.getNumeratorFormat()); properFormat.setNumeratorFormat(old); old = improperFormat.getNumeratorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setNumeratorFormat(nf); assertEquals(nf, improperFormat.getNumeratorFormat()); improperFormat.setNumeratorFormat(old); } public void testDenominatorFormat() { NumberFormat old = properFormat.getDenominatorFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); properFormat.setDenominatorFormat(nf); assertEquals(nf, properFormat.getDenominatorFormat()); properFormat.setDenominatorFormat(old); old = improperFormat.getDenominatorFormat(); nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); improperFormat.setDenominatorFormat(nf); assertEquals(nf, improperFormat.getDenominatorFormat()); improperFormat.setDenominatorFormat(old); } public void testWholeFormat() { ProperFractionFormat format = (ProperFractionFormat)properFormat; NumberFormat old = format.getWholeFormat(); NumberFormat nf = NumberFormat.getInstance(); nf.setParseIntegerOnly(true); format.setWholeFormat(nf); assertEquals(nf, format.getWholeFormat()); format.setWholeFormat(old); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.fraction; import org.apache.commons.math.ConvergenceException; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class FractionTest extends TestCase { private void assertFraction(int expectedNumerator, int expectedDenominator, Fraction actual) { assertEquals(expectedNumerator, actual.getNumerator()); assertEquals(expectedDenominator, actual.getDenominator()); } public void testConstructor() { assertFraction(0, 1, new Fraction(0, 1)); assertFraction(0, 1, new Fraction(0, 2)); assertFraction(0, 1, new Fraction(0, -1)); assertFraction(1, 2, new Fraction(1, 2)); assertFraction(1, 2, new Fraction(2, 4)); assertFraction(-1, 2, new Fraction(-1, 2)); assertFraction(-1, 2, new Fraction(1, -2)); assertFraction(-1, 2, new Fraction(-2, 4)); assertFraction(-1, 2, new Fraction(2, -4)); // overflow try { new Fraction(Integer.MIN_VALUE, -1); fail(); } catch (ArithmeticException ex) { // success } try { new Fraction(1, Integer.MIN_VALUE); fail(); } catch (ArithmeticException ex) { // success } try { assertFraction(0, 1, new Fraction(0.00000000000001)); assertFraction(2, 5, new Fraction(0.40000000000001)); assertFraction(15, 1, new Fraction(15.0000000000001)); } catch (ConvergenceException ex) { fail(ex.getMessage()); } } public void testGoldenRatio() { try { // the golden ratio is notoriously a difficult number for continuous fraction new Fraction((1 + Math.sqrt(5)) / 2, 1.0e-12, 25); fail("an exception should have been thrown"); } catch (ConvergenceException ce) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } // MATH-179 public void testDoubleConstructor() throws ConvergenceException { assertFraction(1, 2, new Fraction((double)1 / (double)2)); assertFraction(1, 3, new Fraction((double)1 / (double)3)); assertFraction(2, 3, new Fraction((double)2 / (double)3)); assertFraction(1, 4, new Fraction((double)1 / (double)4)); assertFraction(3, 4, new Fraction((double)3 / (double)4)); assertFraction(1, 5, new Fraction((double)1 / (double)5)); assertFraction(2, 5, new Fraction((double)2 / (double)5)); assertFraction(3, 5, new Fraction((double)3 / (double)5)); assertFraction(4, 5, new Fraction((double)4 / (double)5)); assertFraction(1, 6, new Fraction((double)1 / (double)6)); assertFraction(5, 6, new Fraction((double)5 / (double)6)); assertFraction(1, 7, new Fraction((double)1 / (double)7)); assertFraction(2, 7, new Fraction((double)2 / (double)7)); assertFraction(3, 7, new Fraction((double)3 / (double)7)); assertFraction(4, 7, new Fraction((double)4 / (double)7)); assertFraction(5, 7, new Fraction((double)5 / (double)7)); assertFraction(6, 7, new Fraction((double)6 / (double)7)); assertFraction(1, 8, new Fraction((double)1 / (double)8)); assertFraction(3, 8, new Fraction((double)3 / (double)8)); assertFraction(5, 8, new Fraction((double)5 / (double)8)); assertFraction(7, 8, new Fraction((double)7 / (double)8)); assertFraction(1, 9, new Fraction((double)1 / (double)9)); assertFraction(2, 9, new Fraction((double)2 / (double)9)); assertFraction(4, 9, new Fraction((double)4 / (double)9)); assertFraction(5, 9, new Fraction((double)5 / (double)9)); assertFraction(7, 9, new Fraction((double)7 / (double)9)); assertFraction(8, 9, new Fraction((double)8 / (double)9)); assertFraction(1, 10, new Fraction((double)1 / (double)10)); assertFraction(3, 10, new Fraction((double)3 / (double)10)); assertFraction(7, 10, new Fraction((double)7 / (double)10)); assertFraction(9, 10, new Fraction((double)9 / (double)10)); assertFraction(1, 11, new Fraction((double)1 / (double)11)); assertFraction(2, 11, new Fraction((double)2 / (double)11)); assertFraction(3, 11, new Fraction((double)3 / (double)11)); assertFraction(4, 11, new Fraction((double)4 / (double)11)); assertFraction(5, 11, new Fraction((double)5 / (double)11)); assertFraction(6, 11, new Fraction((double)6 / (double)11)); assertFraction(7, 11, new Fraction((double)7 / (double)11)); assertFraction(8, 11, new Fraction((double)8 / (double)11)); assertFraction(9, 11, new Fraction((double)9 / (double)11)); assertFraction(10, 11, new Fraction((double)10 / (double)11)); } // MATH-181 public void testDigitLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new Fraction(0.4, 9)); assertFraction(2, 5, new Fraction(0.4, 99)); assertFraction(2, 5, new Fraction(0.4, 999)); assertFraction(3, 5, new Fraction(0.6152, 9)); assertFraction(8, 13, new Fraction(0.6152, 99)); assertFraction(510, 829, new Fraction(0.6152, 999)); assertFraction(769, 1250, new Fraction(0.6152, 9999)); } public void testIntegerOverflow() { checkIntegerOverflow(0.75000000001455192); checkIntegerOverflow(1.0e10); } private void checkIntegerOverflow(double a) { try { new Fraction(a, 1.0e-12, 1000); fail("an exception should have been thrown"); } catch (ConvergenceException ce) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } public void testEpsilonLimitConstructor() throws ConvergenceException { assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100)); assertFraction(3, 5, new Fraction(0.6152, 0.02, 100)); assertFraction(8, 13, new Fraction(0.6152, 1.0e-3, 100)); assertFraction(251, 408, new Fraction(0.6152, 1.0e-4, 100)); assertFraction(251, 408, new Fraction(0.6152, 1.0e-5, 100)); assertFraction(510, 829, new Fraction(0.6152, 1.0e-6, 100)); assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100)); } public void testCompareTo() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); Fraction third = new Fraction(1, 2); assertEquals(0, first.compareTo(first)); assertEquals(0, first.compareTo(third)); assertEquals(1, first.compareTo(second)); assertEquals(-1, second.compareTo(first)); } public void testDoubleValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); assertEquals(0.5, first.doubleValue(), 0.0); assertEquals(1.0 / 3.0, second.doubleValue(), 0.0); } public void testFloatValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(1, 3); assertEquals(0.5f, first.floatValue(), 0.0f); assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f); } public void testIntValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(3, 2); assertEquals(0, first.intValue()); assertEquals(1, second.intValue()); } public void testLongValue() { Fraction first = new Fraction(1, 2); Fraction second = new Fraction(3, 2); assertEquals(0L, first.longValue()); assertEquals(1L, second.longValue()); } public void testConstructorDouble() { try { assertFraction(1, 2, new Fraction(0.5)); assertFraction(1, 3, new Fraction(1.0 / 3.0)); assertFraction(17, 100, new Fraction(17.0 / 100.0)); assertFraction(317, 100, new Fraction(317.0 / 100.0)); assertFraction(-1, 2, new Fraction(-0.5)); assertFraction(-1, 3, new Fraction(-1.0 / 3.0)); assertFraction(-17, 100, new Fraction(17.0 / -100.0)); assertFraction(-317, 100, new Fraction(-317.0 / 100.0)); } catch (ConvergenceException ex) { fail(ex.getMessage()); } } public void testAbs() { Fraction a = new Fraction(10, 21); Fraction b = new Fraction(-10, 21); Fraction c = new Fraction(10, -21); assertFraction(10, 21, a.abs()); assertFraction(10, 21, b.abs()); assertFraction(10, 21, c.abs()); } public void testReciprocal() { Fraction f = null; f = new Fraction(50, 75); f = f.reciprocal(); assertEquals(3, f.getNumerator()); assertEquals(2, f.getDenominator()); f = new Fraction(4, 3); f = f.reciprocal(); assertEquals(3, f.getNumerator()); assertEquals(4, f.getDenominator()); f = new Fraction(-15, 47); f = f.reciprocal(); assertEquals(-47, f.getNumerator()); assertEquals(15, f.getDenominator()); f = new Fraction(0, 3); try { f = f.reciprocal(); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} // large values f = new Fraction(Integer.MAX_VALUE, 1); f = f.reciprocal(); assertEquals(1, f.getNumerator()); assertEquals(Integer.MAX_VALUE, f.getDenominator()); } public void testNegate() { Fraction f = null; f = new Fraction(50, 75); f = f.negate(); assertEquals(-2, f.getNumerator()); assertEquals(3, f.getDenominator()); f = new Fraction(-50, 75); f = f.negate(); assertEquals(2, f.getNumerator()); assertEquals(3, f.getDenominator()); // large values f = new Fraction(Integer.MAX_VALUE-1, Integer.MAX_VALUE); f = f.negate(); assertEquals(Integer.MIN_VALUE+2, f.getNumerator()); assertEquals(Integer.MAX_VALUE, f.getDenominator()); f = new Fraction(Integer.MIN_VALUE, 1); try { f = f.negate(); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} } public void testAdd() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 1, a.add(a)); assertFraction(7, 6, a.add(b)); assertFraction(7, 6, b.add(a)); assertFraction(4, 3, b.add(b)); Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1); Fraction f2 = Fraction.ONE; Fraction f = f1.add(f2); assertEquals(Integer.MAX_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = new Fraction(-1, 13*13*2*2); f2 = new Fraction(-2, 13*17*2); f = f1.add(f2); assertEquals(13*13*17*2*2, f.getDenominator()); assertEquals(-17 - 2*13*2, f.getNumerator()); try { f.add(null); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) {} // if this fraction is added naively, it will overflow. // check that it doesn't. f1 = new Fraction(1,32768*3); f2 = new Fraction(1,59049); f = f1.add(f2); assertEquals(52451, f.getNumerator()); assertEquals(1934917632, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, 3); f2 = new Fraction(1,3); f = f1.add(f2); assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); assertEquals(3, f.getDenominator()); f1 = new Fraction(Integer.MAX_VALUE - 1, 1); f2 = Fraction.ONE; f = f1.add(f2); assertEquals(Integer.MAX_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f = f.add(Fraction.ONE); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (ArithmeticException ex) {} // denominator should not be a multiple of 2 or 3 to trigger overflow f1 = new Fraction(Integer.MIN_VALUE, 5); f2 = new Fraction(-1,5); try { f = f1.add(f2); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (ArithmeticException ex) {} try { f= new Fraction(-Integer.MAX_VALUE, 1); f = f.add(f); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f= new Fraction(-Integer.MAX_VALUE, 1); f = f.add(f); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} f1 = new Fraction(3,327680); f2 = new Fraction(2,59049); try { f = f1.add(f2); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (ArithmeticException ex) {} } public void testDivide() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 1, a.divide(a)); assertFraction(3, 4, a.divide(b)); assertFraction(4, 3, b.divide(a)); assertFraction(1, 1, b.divide(b)); Fraction f1 = new Fraction(3, 5); Fraction f2 = Fraction.ZERO; try { f1.divide(f2); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} f1 = new Fraction(0, 5); f2 = new Fraction(2, 7); Fraction f = f1.divide(f2); assertSame(Fraction.ZERO, f); f1 = new Fraction(2, 7); f2 = Fraction.ONE; f = f1.divide(f2); assertEquals(2, f.getNumerator()); assertEquals(7, f.getDenominator()); f1 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f1); assertEquals(1, f.getNumerator()); assertEquals(1, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE); f2 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f2); assertEquals(Integer.MIN_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f.divide(null); fail("IllegalArgumentException"); } catch (IllegalArgumentException ex) {} try { f1 = new Fraction(1, Integer.MAX_VALUE); f = f1.divide(f1.reciprocal()); // should overflow fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f1 = new Fraction(1, -Integer.MAX_VALUE); f = f1.divide(f1.reciprocal()); // should overflow fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} } public void testMultiply() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(1, 4, a.multiply(a)); assertFraction(1, 3, a.multiply(b)); assertFraction(1, 3, b.multiply(a)); assertFraction(4, 9, b.multiply(b)); Fraction f1 = new Fraction(Integer.MAX_VALUE, 1); Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE); Fraction f = f1.multiply(f2); assertEquals(Integer.MIN_VALUE, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f.multiply(null); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) {} } public void testSubtract() { Fraction a = new Fraction(1, 2); Fraction b = new Fraction(2, 3); assertFraction(0, 1, a.subtract(a)); assertFraction(-1, 6, a.subtract(b)); assertFraction(1, 6, b.subtract(a)); assertFraction(0, 1, b.subtract(b)); Fraction f = new Fraction(1,1); try { f.subtract(null); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) {} // if this fraction is subtracted naively, it will overflow. // check that it doesn't. Fraction f1 = new Fraction(1,32768*3); Fraction f2 = new Fraction(1,59049); f = f1.subtract(f2); assertEquals(-13085, f.getNumerator()); assertEquals(1934917632, f.getDenominator()); f1 = new Fraction(Integer.MIN_VALUE, 3); f2 = new Fraction(1,3).negate(); f = f1.subtract(f2); assertEquals(Integer.MIN_VALUE+1, f.getNumerator()); assertEquals(3, f.getDenominator()); f1 = new Fraction(Integer.MAX_VALUE, 1); f2 = Fraction.ONE; f = f1.subtract(f2); assertEquals(Integer.MAX_VALUE-1, f.getNumerator()); assertEquals(1, f.getDenominator()); try { f1 = new Fraction(1, Integer.MAX_VALUE); f2 = new Fraction(1, Integer.MAX_VALUE - 1); f = f1.subtract(f2); fail("expecting ArithmeticException"); //should overflow } catch (ArithmeticException ex) {} // denominator should not be a multiple of 2 or 3 to trigger overflow f1 = new Fraction(Integer.MIN_VALUE, 5); f2 = new Fraction(1,5); try { f = f1.subtract(f2); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (ArithmeticException ex) {} try { f= new Fraction(Integer.MIN_VALUE, 1); f = f.subtract(Fraction.ONE); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} try { f= new Fraction(Integer.MAX_VALUE, 1); f = f.subtract(Fraction.ONE.negate()); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) {} f1 = new Fraction(3,327680); f2 = new Fraction(2,59049); try { f = f1.subtract(f2); // should overflow fail("expecting ArithmeticException but got: " + f.toString()); } catch (ArithmeticException ex) {} } public void testEqualsAndHashCode() { Fraction zero = new Fraction(0,1); Fraction nullFraction = null; assertTrue( zero.equals(zero)); assertFalse(zero.equals(nullFraction)); assertFalse(zero.equals(Double.valueOf(0))); Fraction zero2 = new Fraction(0,2); assertTrue(zero.equals(zero2)); assertEquals(zero.hashCode(), zero2.hashCode()); Fraction one = new Fraction(1,1); assertFalse((one.equals(zero) ||zero.equals(one))); } public void testGetReducedFraction() { Fraction threeFourths = new Fraction(3, 4); assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8))); assertTrue(Fraction.ZERO.equals(Fraction.getReducedFraction(0, -1))); try { Fraction.getReducedFraction(1, 0); fail("expecting ArithmeticException"); } catch (ArithmeticException ex) { // expected } assertEquals(Fraction.getReducedFraction (2, Integer.MIN_VALUE).getNumerator(),-1); assertEquals(Fraction.getReducedFraction (1, -1).getNumerator(), -1); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderConverter; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.SecondOrderDifferentialEquations; import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator; import junit.framework.*; public class FirstOrderConverterTest extends TestCase { public FirstOrderConverterTest(String name) { super(name); } public void testDoubleDimension() { for (int i = 1; i < 10; ++i) { SecondOrderDifferentialEquations eqn2 = new Equations(i, 0.2); FirstOrderConverter eqn1 = new FirstOrderConverter(eqn2); assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension())); } } public void testDecreasingSteps() throws DerivativeException, IntegratorException { double previousError = Double.NaN; for (int i = 0; i < 10; ++i) { double step = Math.pow(2.0, -(i + 1)); double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, step) - Math.sin(4.0); if (i > 0) { assertTrue(Math.abs(error) < Math.abs(previousError)); } previousError = error; } } public void testSmallStep() throws DerivativeException, IntegratorException { double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 1.0e-4) - Math.sin(4.0); assertTrue(Math.abs(error) < 1.0e-10); } public void testBigStep() throws DerivativeException, IntegratorException { double error = integrateWithSpecifiedStep(4.0, 0.0, 1.0, 0.5) - Math.sin(4.0); assertTrue(Math.abs(error) > 0.1); } public static Test suite() { return new TestSuite(FirstOrderConverterTest.class); } private static class Equations implements SecondOrderDifferentialEquations { private int n; private double omega2; public Equations(int n, double omega) { this.n = n; omega2 = omega * omega; } public int getDimension() { return n; } public void computeSecondDerivatives(double t, double[] y, double[] yDot, double[] yDDot) { for (int i = 0; i < n; ++i) { yDDot[i] = -omega2 * y[i]; } } } private double integrateWithSpecifiedStep(double omega, double t0, double t, double step) throws DerivativeException, IntegratorException { double[] y0 = new double[2]; y0[0] = Math.sin(omega * t0); y0[1] = omega * Math.cos(omega * t0); ClassicalRungeKuttaIntegrator i = new ClassicalRungeKuttaIntegrator(step); double[] y = new double[2]; i.integrate(new FirstOrderConverter(new Equations(1, omega)), t0, y0, t, y); return y[0]; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode; import junit.framework.*; import java.util.Random; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math.ode.nonstiff.TestProblem3; import org.apache.commons.math.ode.sampling.DummyStepInterpolator; import org.apache.commons.math.ode.sampling.StepInterpolator; public class ContinuousOutputModelTest extends TestCase { public ContinuousOutputModelTest(String name) { super(name); pb = null; integ = null; } public void testBoundaries() throws DerivativeException, IntegratorException { integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next(); cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime()); cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime()); cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime())); } public void testRandomAccess() throws DerivativeException, IntegratorException { ContinuousOutputModel cm = new ContinuousOutputModel(); integ.addStepHandler(cm); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError < 1.0e-9); } public void testModelsMerging() throws DerivativeException, IntegratorException { // theoretical solution: y[0] = cos(t), y[1] = sin(t) FirstOrderDifferentialEquations problem = new FirstOrderDifferentialEquations() { private static final long serialVersionUID = 2472449657345878299L; public void computeDerivatives(double t, double[] y, double[] dot) throws DerivativeException { dot[0] = -y[1]; dot[1] = y[0]; } public int getDimension() { return 2; } }; // integrate backward from &pi; to 0; ContinuousOutputModel cm1 = new ContinuousOutputModel(); FirstOrderIntegrator integ1 = new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8); integ1.addStepHandler(cm1); integ1.integrate(problem, Math.PI, new double[] { -1.0, 0.0 }, 0, new double[2]); // integrate backward from 2&pi; to &pi; ContinuousOutputModel cm2 = new ContinuousOutputModel(); FirstOrderIntegrator integ2 = new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12); integ2.addStepHandler(cm2); integ2.integrate(problem, 2.0 * Math.PI, new double[] { 1.0, 0.0 }, Math.PI, new double[2]); // merge the two half circles ContinuousOutputModel cm = new ContinuousOutputModel(); cm.append(cm2); cm.append(new ContinuousOutputModel()); cm.append(cm1); // check circle assertEquals(2.0 * Math.PI, cm.getInitialTime(), 1.0e-12); assertEquals(0, cm.getFinalTime(), 1.0e-12); assertEquals(cm.getFinalTime(), cm.getInterpolatedTime(), 1.0e-12); for (double t = 0; t < 2.0 * Math.PI; t += 0.1) { cm.setInterpolatedTime(t); double[] y = cm.getInterpolatedState(); assertEquals(Math.cos(t), y[0], 1.0e-7); assertEquals(Math.sin(t), y[1], 1.0e-7); } } public void testErrorConditions() throws DerivativeException { ContinuousOutputModel cm = new ContinuousOutputModel(); cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true); // dimension mismatch assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0)); // hole between time ranges assertTrue(checkAppendError(cm, 10.0, new double[] { 0.0, 1.0, -2.0 }, 20.0)); // propagation direction mismatch assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 0.0)); // no errors assertFalse(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0, -2.0 }, 2.0)); } private boolean checkAppendError(ContinuousOutputModel cm, double t0, double[] y0, double t1) throws DerivativeException { try { ContinuousOutputModel otherCm = new ContinuousOutputModel(); otherCm.handleStep(buildInterpolator(t0, y0, t1), true); cm.append(otherCm); } catch(IllegalArgumentException iae) { //expected behavior return true; } return false; } private StepInterpolator buildInterpolator(double t0, double[] y0, double t1) { DummyStepInterpolator interpolator = new DummyStepInterpolator(y0, t1 >= t0); interpolator.storeTime(t0); interpolator.shift(); interpolator.storeTime(t1); return interpolator; } public void checkValue(double value, double reference) { assertTrue(Math.abs(value - reference) < 1.0e-10); } public static Test suite() { return new TestSuite(ContinuousOutputModelTest.class); } public void setUp() { pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); integ = new DormandPrince54Integrator(minStep, maxStep, 1.0e-8, 1.0e-8); } public void tearDown() { pb = null; integ = null; } TestProblem3 pb; FirstOrderIntegrator integ; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.sampling; import junit.framework.*; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.IOException; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.sampling.AbstractStepInterpolator; import org.apache.commons.math.ode.sampling.DummyStepInterpolator; public class DummyStepInterpolatorTest extends TestCase { public DummyStepInterpolatorTest(String name) { super(name); } public void testNoReset() { double[] y = { 0.0, 1.0, -2.0 }; DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); double[] result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10); } } public void testFixedState() throws DerivativeException { double[] y = { 1.0, 3.0, -4.0 }; DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); interpolator.setInterpolatedTime(0.1); double[] result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10); } interpolator.setInterpolatedTime(0.5); result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10); } } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { double[] y = { 0.0, 1.0, -2.0 }; DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(interpolator); assertTrue(bos.size () > 150); assertTrue(bos.size () < 250); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject(); dsi.setInterpolatedTime(0.5); double[] result = dsi.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10); } } public void testImpossibleSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { double[] y = { 0.0, 1.0, -2.0 }; AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); try { oos.writeObject(interpolator); fail("an exception should have been thrown"); } catch (IOException ioe) { // expected behavior assertEquals(0, ioe.getMessage().length()); } catch (Exception e) { fail("wrong exception caught"); } } private static class BadStepInterpolator extends DummyStepInterpolator { public BadStepInterpolator() { super(); } public BadStepInterpolator(double[] y, boolean forward) { super(y, forward); } protected void doFinalize() throws DerivativeException { throw new DerivativeException(null); } }; public void testSerializationError() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { double[] y = { 0.0, 1.0, -2.0 }; ErrorGeneratingInterpolator interpolator = new ErrorGeneratingInterpolator(y, true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(interpolator); assertTrue(bos.size () > 300); assertTrue(bos.size () < 350); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); try { ois.readObject(); fail("an exception should have been thrown"); } catch (IOException ioe) { // expected behavior assertEquals(0, ioe.getMessage().length()); } catch (Exception e) { fail("wrong exception caught"); } } private static class ErrorGeneratingInterpolator extends DummyStepInterpolator { public ErrorGeneratingInterpolator() { super(); } protected ErrorGeneratingInterpolator(double[] y, boolean forward) { super(y, forward); } public void computeInterpolatedState(double theta, double oneMinusThetaH) throws DerivativeException { throw new DerivativeException(null); } private static final long serialVersionUID = 0x3f6ab636f0c93571L; } public static Test suite() { return new TestSuite(DummyStepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.sampling; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math.ode.nonstiff.TestProblem3; import org.apache.commons.math.ode.sampling.FixedStepHandler; import org.apache.commons.math.ode.sampling.StepNormalizer; import junit.framework.*; public class StepNormalizerTest extends TestCase { public StepNormalizerTest(String name) { super(name); pb = null; integ = null; } public void testBoundaries() throws DerivativeException, IntegratorException { double range = pb.getFinalTime() - pb.getInitialTime(); setLastSeen(false); integ.addStepHandler(new StepNormalizer(range / 10.0, new FixedStepHandler() { private static final long serialVersionUID = 1650337364641626444L; private boolean firstCall = true; public void handleStep(double t, double[] y, double[] yDot, boolean isLast) { if (firstCall) { checkValue(t, pb.getInitialTime()); firstCall = false; } if (isLast) { setLastSeen(true); checkValue(t, pb.getFinalTime()); } } })); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(lastSeen); } public void testBeforeEnd() throws DerivativeException, IntegratorException { final double range = pb.getFinalTime() - pb.getInitialTime(); setLastSeen(false); integ.addStepHandler(new StepNormalizer(range / 10.5, new FixedStepHandler() { private static final long serialVersionUID = 2228457391561277298L; public void handleStep(double t, double[] y, double[] yDot, boolean isLast) { if (isLast) { setLastSeen(true); checkValue(t, pb.getFinalTime() - range / 21.0); } } })); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(lastSeen); } public void checkValue(double value, double reference) { assertTrue(Math.abs(value - reference) < 1.0e-10); } public void setLastSeen(boolean lastSeen) { this.lastSeen = lastSeen; } public static Test suite() { return new TestSuite(StepNormalizerTest.class); } public void setUp() { pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8); lastSeen = false; } public void tearDown() { pb = null; integ = null; } TestProblem3 pb; FirstOrderIntegrator integ; boolean lastSeen; }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; import junit.framework.*; public class GraggBulirschStoerIntegratorTest extends TestCase { public GraggBulirschStoerIntegratorTest(String name) { super(name); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); AdaptiveStepsizeIntegrator integrator = new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testNullIntervalCheck() { try { TestProblem1 pb = new TestProblem1(); GraggBulirschStoerIntegrator integrator = new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testMinStep() throws DerivativeException, IntegratorException { try { TestProblem5 pb = new TestProblem5(); double minStep = 0.1 * Math.abs(pb.getFinalTime() - pb.getInitialTime()); double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime()); double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 }; double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 }; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 9.0e-10); assertTrue(handler.getMaximalValueError() < 9.0e-10); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Gragg-Bulirsch-Stoer", integ.getName()); } public void testIncreasingTolerance() throws DerivativeException, IntegratorException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -4; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = Math.pow(10.0, i); double relTolerance = absTolerance; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); // the coefficients are only valid for this test // and have been obtained from trial and error // there is no general relation between local and global errors double ratio = handler.getMaximalValueError() / absTolerance; assertTrue(ratio < 2.4); assertTrue(ratio > 0.02); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); int calls = pb.getCalls(); assertTrue(calls <= previousCalls); previousCalls = calls; } } public void testIntegratorControls() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.999); GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(), 1.0e-8, 1.0e-10); double errorWithDefaultSettings = getMaxError(integ, pb); // stability control integ.setStabilityCheck(true, 2, 1, 0.99); assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); integ.setStabilityCheck(true, -1, -1, -1); integ.setStepsizeControl(0.5, 0.99, 0.1, 2.5); assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); integ.setStepsizeControl(-1, -1, -1, -1); integ.setOrderControl(10, 0.7, 0.95); assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); integ.setOrderControl(-1, -1, -1); integ.setInterpolationControl(true, 3); assertTrue(errorWithDefaultSettings < getMaxError(integ, pb)); integ.setInterpolationControl(true, -1); } private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb) throws DerivativeException, IntegratorException { TestProblemHandler handler = new TestProblemHandler(pb, integrator); integrator.addStepHandler(handler); integrator.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); return handler.getMaximalValueError(); } public void testEvents() throws DerivativeException, IntegratorException { TestProblem4 pb = new TestProblem4(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-10; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000); } assertEquals(functions.length, integ.getEventHandlers().size()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getMaximalValueError() < 5.0e-8); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep); integ.clearEventHandlers(); assertEquals(0, integ.getEventHandlers().size()); } public void testKepler() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = 1.0e-6; double relTolerance = 1.0e-6; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); integ.addStepHandler(new KeplerStepHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(pb.getCalls() < 2150); } public void testVariableSteps() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = 1.0e-8; double relTolerance = 1.0e-8; FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); integ.addStepHandler(new VariableStepHandler()); double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); assertEquals("Gragg-Bulirsch-Stoer", integ.getName()); } public void testUnstableDerivative() throws DerivativeException, IntegratorException { final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0); FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0); integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000); double[] y = { Double.NaN }; integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y); assertEquals(8.0, y[0], 1.0e-12); } private static class KeplerStepHandler implements StepHandler { private static final long serialVersionUID = -8231434585284002546L; public KeplerStepHandler(TestProblem3 pb) { this.pb = pb; reset(); } public boolean requiresDenseOutput() { return true; } public void reset() { nbSteps = 0; maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { ++nbSteps; for (int a = 1; a < 100; ++a) { double prev = interpolator.getPreviousTime(); double curr = interpolator.getCurrentTime(); double interp = ((100 - a) * prev + a * curr) / 100; interpolator.setInterpolatedTime(interp); double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } if (isLast) { assertTrue(maxError < 2.7e-6); assertTrue(nbSteps < 80); } } private int nbSteps; private double maxError; private TestProblem3 pb; } public static class VariableStepHandler implements StepHandler { private static final long serialVersionUID = -5955452449048688985L; public VariableStepHandler() { reset(); } public boolean requiresDenseOutput() { return false; } public void reset() { firstTime = true; minStep = 0; maxStep = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double step = Math.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); if (firstTime) { minStep = Math.abs(step); maxStep = minStep; firstTime = false; } else { if (step < minStep) { minStep = step; } if (step > maxStep) { maxStep = step; } } if (isLast) { assertTrue(minStep < 8.2e-3); assertTrue(maxStep > 1.7); } } private boolean firstTime; private double minStep; private double maxStep; } public static Test suite() { return new TestSuite(GraggBulirschStoerIntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import java.util.Random; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.IOException; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class GraggBulirschStoerStepInterpolatorTest extends StepInterpolatorAbstractTest { public GraggBulirschStoerStepInterpolatorTest(String name) { super(name); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = 1.0e-8; double relTolerance = 1.0e-8; GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); checkDerivativesConsistency(integ, pb, 1.0e-8); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double absTolerance = 1.0e-8; double relTolerance = 1.0e-8; GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, absTolerance, relTolerance); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 34000); assertTrue(bos.size () < 35000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError < 5.0e-11); } public void testClone() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = -5947183291381232297L; public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { StepInterpolator cloned = interpolator.copy(); double tA = cloned.getPreviousTime(); double tB = cloned.getCurrentTime(); double halfStep = Math.abs(tB - tA) / 2; assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12); assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12); for (int i = 0; i < 10; ++i) { double t = (i * tB + (9 - i) * tA) / 9; interpolator.setInterpolatedTime(t); assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10)); cloned.setInterpolatedTime(t); assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12); double[] referenceState = interpolator.getInterpolatedState(); double[] cloneState = cloned.getInterpolatedState(); for (int j = 0; j < referenceState.length; ++j) { assertEquals(referenceState[j], cloneState[j], 1.0e-12); } } } public boolean requiresDenseOutput() { return true; } public void reset() { } }); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } public static Test suite() { return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderDifferentialEquations; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.GillIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class GillIntegratorTest extends TestCase { public GillIntegratorTest(String name) { super(name); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); new GillIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testDecreasingSteps() throws DerivativeException, IntegratorException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousError = Double.NaN; for (int i = 5; i < 10; ++i) { TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone(); double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i); FirstOrderIntegrator integ = new GillIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 5) { assertTrue(error < Math.abs(previousError)); } previousError = error; assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } } } public void testSmallStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new GillIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 2.0e-13); assertTrue(handler.getMaximalValueError() < 4.0e-12); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Gill", integ.getName()); } public void testBigStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new GillIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() > 0.0004); assertTrue(handler.getMaximalValueError() > 0.005); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new GillIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 5.0e-10); assertTrue(handler.getMaximalValueError() < 7.0e-10); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Gill", integ.getName()); } public void testKepler() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; FirstOrderIntegrator integ = new GillIntegrator(step); integ.addStepHandler(new KeplerStepHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } public void testUnstableDerivative() throws DerivativeException, IntegratorException { final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0); FirstOrderIntegrator integ = new GillIntegrator(0.3); integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000); double[] y = { Double.NaN }; integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y); assertEquals(8.0, y[0], 1.0e-12); } private static class KeplerStepHandler implements StepHandler { private static final long serialVersionUID = 1250933165809631538L; public KeplerStepHandler(TestProblem3 pb) { this.pb = pb; reset(); } public boolean requiresDenseOutput() { return false; } public void reset() { maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } if (isLast) { // even with more than 1000 evaluations per period, // RK4 is not able to integrate such an eccentric // orbit with a good accuracy assertTrue(maxError > 0.001); } } private double maxError; private TestProblem3 pb; } public void testStepSize() throws DerivativeException, IntegratorException { final double step = 1.23456; FirstOrderIntegrator integ = new GillIntegrator(step); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = 0L; public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public boolean requiresDenseOutput() { return false; } public void reset() { } }); integ.integrate(new FirstOrderDifferentialEquations() { private static final long serialVersionUID = 0L; public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } public static Test suite() { return new TestSuite(GillIntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderDifferentialEquations; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class ThreeEighthesIntegratorTest extends TestCase { public ThreeEighthesIntegratorTest(String name) { super(name); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); new ThreeEighthesIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testDecreasingSteps() throws DerivativeException, IntegratorException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousError = Double.NaN; for (int i = 4; i < 10; ++i) { TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone(); double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i); FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 4) { assertTrue(error < Math.abs(previousError)); } previousError = error; assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } } } public void testSmallStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 2.0e-13); assertTrue(handler.getMaximalValueError() < 4.0e-12); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("3/8", integ.getName()); } public void testBigStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() > 0.0004); assertTrue(handler.getMaximalValueError() > 0.005); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 5.0e-10); assertTrue(handler.getMaximalValueError() < 7.0e-10); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("3/8", integ.getName()); } public void testKepler() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } private static class KeplerHandler implements StepHandler { private static final long serialVersionUID = 4400497468419540899L; public KeplerHandler(TestProblem3 pb) { this.pb = pb; maxError = 0; } public boolean requiresDenseOutput() { return false; } public void reset() { maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } if (isLast) { // even with more than 1000 evaluations per period, // RK4 is not able to integrate such an eccentric // orbit with a good accuracy assertTrue(maxError > 0.005); } } private TestProblem3 pb; private double maxError = 0; } public void testStepSize() throws DerivativeException, IntegratorException { final double step = 1.23456; FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = 0L; public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public boolean requiresDenseOutput() { return false; } public void reset() { } }); integ.integrate(new FirstOrderDifferentialEquations() { private static final long serialVersionUID = 0L; public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } public static Test suite() { return new TestSuite(ThreeEighthesIntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderDifferentialEquations; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.EulerIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class EulerIntegratorTest extends TestCase { public EulerIntegratorTest(String name) { super(name); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); new EulerIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testDecreasingSteps() throws DerivativeException, IntegratorException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousError = Double.NaN; for (int i = 4; i < 10; ++i) { TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone(); double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i); FirstOrderIntegrator integ = new EulerIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 4) { assertTrue(error < Math.abs(previousError)); } previousError = error; assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } } } public void testSmallStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new EulerIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 2.0e-4); assertTrue(handler.getMaximalValueError() < 1.0e-3); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Euler", integ.getName()); } public void testBigStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new EulerIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() > 0.01); assertTrue(handler.getMaximalValueError() > 0.2); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new EulerIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 0.45); assertTrue(handler.getMaximalValueError() < 0.45); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Euler", integ.getName()); } public void testStepSize() throws DerivativeException, IntegratorException { final double step = 1.23456; FirstOrderIntegrator integ = new EulerIntegrator(step); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = 0L; public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public boolean requiresDenseOutput() { return false; } public void reset() { } }); integ.integrate(new FirstOrderDifferentialEquations() { private static final long serialVersionUID = 0L; public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } public static Test suite() { return new TestSuite(EulerIntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import java.util.Random; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.IOException; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class DormandPrince54StepInterpolatorTest extends StepInterpolatorAbstractTest { public DormandPrince54StepInterpolatorTest(String name) { super(name); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.1); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); checkDerivativesConsistency(integ, pb, 1.0e-10); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 119500); assertTrue(bos.size () < 120500); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError < 7.0e-10); } public void testClone() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = -6768136169276197L; public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { StepInterpolator cloned = interpolator.copy(); double tA = cloned.getPreviousTime(); double tB = cloned.getCurrentTime(); double halfStep = Math.abs(tB - tA) / 2; assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12); assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12); for (int i = 0; i < 10; ++i) { double t = (i * tB + (9 - i) * tA) / 9; interpolator.setInterpolatedTime(t); assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10)); cloned.setInterpolatedTime(t); assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12); double[] referenceState = interpolator.getInterpolatedState(); double[] cloneState = cloned.getInterpolatedState(); for (int j = 0; j < referenceState.length; ++j) { assertEquals(referenceState[j], cloneState[j], 1.0e-12); } } } public boolean requiresDenseOutput() { return true; } public void reset() { } }); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } public static Test suite() { return new TestSuite(DormandPrince54StepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderDifferentialEquations; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class ClassicalRungeKuttaIntegratorTest extends TestCase { public ClassicalRungeKuttaIntegratorTest(String name) { super(name); } public void testSanityChecks() { try { TestProblem1 pb = new TestProblem1(); new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } try { TestProblem1 pb = new TestProblem1(); new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } try { TestProblem1 pb = new TestProblem1(); new ClassicalRungeKuttaIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testDecreasingSteps() throws DerivativeException, IntegratorException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousError = Double.NaN; for (int i = 4; i < 10; ++i) { TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone(); double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i); FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } assertEquals(functions.length, integ.getEventHandlers().size()); double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 4) { assertTrue(error < Math.abs(previousError)); } previousError = error; assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); integ.clearEventHandlers(); assertEquals(0, integ.getEventHandlers().size()); } } } public void testSmallStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 2.0e-13); assertTrue(handler.getMaximalValueError() < 4.0e-12); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("classical Runge-Kutta", integ.getName()); } public void testBigStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() > 0.0004); assertTrue(handler.getMaximalValueError() > 0.005); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 5.0e-10); assertTrue(handler.getMaximalValueError() < 7.0e-10); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("classical Runge-Kutta", integ.getName()); } public void testKepler() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } private static class KeplerHandler implements StepHandler { private static final long serialVersionUID = 7510061424396717277L; public KeplerHandler(TestProblem3 pb) { this.pb = pb; reset(); } public boolean requiresDenseOutput() { return false; } public void reset() { maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } if (isLast) { // even with more than 1000 evaluations per period, // RK4 is not able to integrate such an eccentric // orbit with a good accuracy assertTrue(maxError > 0.005); } } private double maxError = 0; private TestProblem3 pb; } public void testStepSize() throws DerivativeException, IntegratorException { final double step = 1.23456; FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = 0L; public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public boolean requiresDenseOutput() { return false; } public void reset() { } }); integ.integrate(new FirstOrderDifferentialEquations() { private static final long serialVersionUID = 0L; public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } public static Test suite() { return new TestSuite(ClassicalRungeKuttaIntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.sampling.StepHandler; public class ClassicalRungeKuttaStepInterpolatorTest extends StepInterpolatorAbstractTest { public ClassicalRungeKuttaStepInterpolatorTest(String name) { super(name); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step); checkDerivativesConsistency(integ, pb, 1.0e-10); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 700000); assertTrue(bos.size () < 701000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError > 0.005); } public static Test suite() { return new TestSuite(ClassicalRungeKuttaStepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; import junit.framework.TestCase; public class StepInterpolatorAbstractTest extends TestCase { protected StepInterpolatorAbstractTest(String name) { super(name); } protected void checkDerivativesConsistency(final FirstOrderIntegrator integrator, final TestProblemAbstract problem, final double threshold) throws DerivativeException, IntegratorException { integrator.addStepHandler(new StepHandler() { private static final long serialVersionUID = 2462564234755682953L; public boolean requiresDenseOutput() { return true; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { final double h = 0.001 * (interpolator.getCurrentTime() - interpolator.getPreviousTime()); final double t = interpolator.getCurrentTime() - 300 * h; if (Math.abs(h) < 10 * Math.ulp(t)) { return; } interpolator.setInterpolatedTime(t - 4 * h); final double[] yM4h = interpolator.getInterpolatedState().clone(); interpolator.setInterpolatedTime(t - 3 * h); final double[] yM3h = interpolator.getInterpolatedState().clone(); interpolator.setInterpolatedTime(t - 2 * h); final double[] yM2h = interpolator.getInterpolatedState().clone(); interpolator.setInterpolatedTime(t - h); final double[] yM1h = interpolator.getInterpolatedState().clone(); interpolator.setInterpolatedTime(t + h); final double[] yP1h = interpolator.getInterpolatedState().clone(); interpolator.setInterpolatedTime(t + 2 * h); final double[] yP2h = interpolator.getInterpolatedState().clone(); interpolator.setInterpolatedTime(t + 3 * h); final double[] yP3h = interpolator.getInterpolatedState().clone(); interpolator.setInterpolatedTime(t + 4 * h); final double[] yP4h = interpolator.getInterpolatedState().clone(); interpolator.setInterpolatedTime(t); final double[] yDot = interpolator.getInterpolatedDerivatives(); for (int i = 0; i < yDot.length; ++i) { final double approYDot = ( -3 * (yP4h[i] - yM4h[i]) + 32 * (yP3h[i] - yM3h[i]) + -168 * (yP2h[i] - yM2h[i]) + 672 * (yP1h[i] - yM1h[i])) / (840 * h); if (Math.abs(approYDot - yDot[i]) >= threshold) { System.out.println("gotcha!"); } assertEquals(approYDot, yDot[i], threshold); } } public void reset() { } }); integrator.integrate(problem, problem.getInitialTime(), problem.getInitialState(), problem.getFinalTime(), new double[problem.getDimension()]); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import java.util.Random; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.IOException; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.nonstiff.HighamHall54Integrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class HighamHall54StepInterpolatorTest extends StepInterpolatorAbstractTest { public HighamHall54StepInterpolatorTest(String name) { super(name); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.1); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); checkDerivativesConsistency(integ, pb, 1.0e-10); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 158000); assertTrue(bos.size () < 159000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError < 1.6e-10); } public void testClone() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = 9111679755950880352L; public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { StepInterpolator cloned = interpolator.copy(); double tA = cloned.getPreviousTime(); double tB = cloned.getCurrentTime(); double halfStep = Math.abs(tB - tA) / 2; assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12); assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12); for (int i = 0; i < 10; ++i) { double t = (i * tB + (9 - i) * tA) / 9; interpolator.setInterpolatedTime(t); assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10)); cloned.setInterpolatedTime(t); assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12); double[] referenceState = interpolator.getInterpolatedState(); double[] cloneState = cloned.getInterpolatedState(); for (int j = 0; j < referenceState.length; ++j) { assertEquals(referenceState[j], cloneState[j], 1.0e-12); } } } public boolean requiresDenseOutput() { return true; } public void reset() { } }); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } public static Test suite() { return new TestSuite(HighamHall54StepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator; import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; import junit.framework.*; public class DormandPrince54IntegratorTest extends TestCase { public DormandPrince54IntegratorTest(String name) { super(name); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testMinStep() throws DerivativeException, IntegratorException { try { TestProblem1 pb = new TestProblem1(); double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testSmallLastStep() throws DerivativeException, IntegratorException { TestProblemAbstract pb = new TestProblem5(); double minStep = 1.25; double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime()); double scalAbsoluteTolerance = 6.0e-4; double scalRelativeTolerance = 6.0e-4; AdaptiveStepsizeIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep); integ.addStepHandler(handler); integ.setInitialStepSize(1.7); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.wasLastSeen()); assertEquals("Dormand-Prince 5(4)", integ.getName()); } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 2.0e-7); assertTrue(handler.getMaximalValueError() < 2.0e-7); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Dormand-Prince 5(4)", integ.getName()); } private static class DP54SmallLastHandler implements StepHandler { private static final long serialVersionUID = -8168590945325629799L; public DP54SmallLastHandler(double minStep) { lastSeen = false; this.minStep = minStep; } public boolean requiresDenseOutput() { return false; } public void reset() { } public void handleStep(StepInterpolator interpolator, boolean isLast) { if (isLast) { lastSeen = true; double h = interpolator.getCurrentTime() - interpolator.getPreviousTime(); assertTrue(Math.abs(h) < minStep); } } public boolean wasLastSeen() { return lastSeen; } private boolean lastSeen; private double minStep; } public void testIncreasingTolerance() throws DerivativeException, IntegratorException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -2; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = Math.pow(10.0, i); double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; EmbeddedRungeKuttaIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.setSafety(0.8); integ.setMaxGrowth(5.0); integ.setMinReduction(0.3); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertEquals(0.8, integ.getSafety(), 1.0e-12); assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12); assertEquals(0.3, integ.getMinReduction(), 1.0e-12); // the 0.7 factor is only valid for this test // and has been obtained from trial and error // there is no general relation between local and global errors assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance)); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); int calls = pb.getCalls(); assertTrue(calls <= previousCalls); previousCalls = calls; } } public void testEvents() throws DerivativeException, IntegratorException { TestProblem4 pb = new TestProblem4(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000); } assertEquals(functions.length, integ.getEventHandlers().size()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getMaximalValueError() < 5.0e-6); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep); integ.clearEventHandlers(); assertEquals(0, integ.getEventHandlers().size()); } public void testKepler() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(pb.getCalls() < 2800); } public void testVariableSteps() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new VariableHandler()); double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } private static class KeplerHandler implements StepHandler { private static final long serialVersionUID = -1645853847806655456L; public KeplerHandler(TestProblem3 pb) { this.pb = pb; reset(); } public boolean requiresDenseOutput() { return true; } public void reset() { nbSteps = 0; maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { ++nbSteps; for (int a = 1; a < 10; ++a) { double prev = interpolator.getPreviousTime(); double curr = interpolator.getCurrentTime(); double interp = ((10 - a) * prev + a * curr) / 10; interpolator.setInterpolatedTime(interp); double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } if (isLast) { assertTrue(maxError < 7.0e-10); assertTrue(nbSteps < 400); } } private int nbSteps; private double maxError; private TestProblem3 pb; } private static class VariableHandler implements StepHandler { private static final long serialVersionUID = -5196650833828379228L; public VariableHandler() { firstTime = true; minStep = 0; maxStep = 0; } public boolean requiresDenseOutput() { return false; } public void reset() { firstTime = true; minStep = 0; maxStep = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double step = Math.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); if (firstTime) { minStep = Math.abs(step); maxStep = minStep; firstTime = false; } else { if (step < minStep) { minStep = step; } if (step > maxStep) { maxStep = step; } } if (isLast) { assertTrue(minStep < (1.0 / 450.0)); assertTrue(maxStep > (1.0 / 4.2)); } } private boolean firstTime; private double minStep; private double maxStep; } public static Test suite() { return new TestSuite(DormandPrince54IntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.ConvergenceException; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderDifferentialEquations; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.HighamHall54Integrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class HighamHall54IntegratorTest extends TestCase { public HighamHall54IntegratorTest(String name) { super(name); } public void testWrongDerivative() { try { HighamHall54Integrator integrator = new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); FirstOrderDifferentialEquations equations = new FirstOrderDifferentialEquations() { private static final long serialVersionUID = -1157081786301178032L; public void computeDerivatives(double t, double[] y, double[] dot) throws DerivativeException { if (t < -0.5) { throw new DerivativeException("{0}", new String[] { "oops" }); } else { throw new DerivativeException(new RuntimeException("oops")); } } public int getDimension() { return 1; } }; try { integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]); fail("an exception should have been thrown"); } catch(DerivativeException de) { // expected behavior } try { integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]); fail("an exception should have been thrown"); } catch(DerivativeException de) { // expected behavior } } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } public void testMinStep() throws DerivativeException, IntegratorException { try { TestProblem1 pb = new TestProblem1(); double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testIncreasingTolerance() throws DerivativeException, IntegratorException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -2; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = Math.pow(10.0, i); double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); // the 1.3 factor is only valid for this test // and has been obtained from trial and error // there is no general relation between local and global errors assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance)); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); int calls = pb.getCalls(); assertTrue(calls <= previousCalls); previousCalls = calls; } } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 5.0e-7); assertTrue(handler.getMaximalValueError() < 5.0e-7); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Higham-Hall 5(4)", integ.getName()); } public void testEvents() throws DerivativeException, IntegratorException { TestProblem4 pb = new TestProblem4(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000); } assertEquals(functions.length, integ.getEventHandlers().size()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getMaximalValueError() < 1.0e-7); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep); integ.clearEventHandlers(); assertEquals(0, integ.getEventHandlers().size()); } public void testEventsErrors() throws DerivativeException, IntegratorException { final TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.addEventHandler(new EventHandler() { public int eventOccurred(double t, double[] y) { return EventHandler.CONTINUE; } public double g(double t, double[] y) throws EventException { double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2; double offset = t - middle; if (offset > 0) { throw new EventException("Evaluation failed for argument = {0}", new Object[] { Double.valueOf(t) }); } return offset; } public void resetState(double t, double[] y) { } private static final long serialVersionUID = 935652725339916361L; }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000); try { integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch (IntegratorException ie) { // expected behavior } catch (Exception e) { fail("wrong exception type caught"); } } public void testEventsNoConvergence() throws DerivativeException, IntegratorException { final TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.addEventHandler(new EventHandler() { public int eventOccurred(double t, double[] y) { return EventHandler.CONTINUE; } public double g(double t, double[] y) { double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2; double offset = t - middle; return (offset > 0) ? (offset + 0.5) : (offset - 0.5); } public void resetState(double t, double[] y) { } private static final long serialVersionUID = 935652725339916361L; }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3); try { integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch (IntegratorException ie) { assertTrue(ie.getCause() != null); assertTrue(ie.getCause() instanceof ConvergenceException); } catch (Exception e) { fail("wrong exception type caught"); } } public void testSanityChecks() { try { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); integ.integrate(pb, pb.getInitialTime(), new double[6], pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch (IntegratorException ie) { // expected behavior } try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[6]); fail("an exception should have been thrown"); } catch (IntegratorException ie) { // expected behavior } try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch (IntegratorException ie) { // expected behavior } try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch (IntegratorException ie) { // expected behavior } try { FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getInitialTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch (IntegratorException ie) { // expected behavior } } catch (Exception e) { fail("wrong exception caught: " + e.getMessage()); } } public void testKepler() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 }; double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 }; FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertEquals("Higham-Hall 5(4)", integ.getName()); } private static class KeplerHandler implements StepHandler { private static final long serialVersionUID = 3200246026175251943L; public KeplerHandler(TestProblem3 pb) { this.pb = pb; nbSteps = 0; maxError = 0; } public boolean requiresDenseOutput() { return false; } public void reset() { nbSteps = 0; maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { ++nbSteps; double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getCurrentTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } if (isLast) { assertTrue(maxError < 4e-11); assertTrue(nbSteps < 670); } } private TestProblem3 pb; private int nbSteps; private double maxError; } public static Test suite() { return new TestSuite(HighamHall54IntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.sampling.StepHandler; public class MidpointStepInterpolatorTest extends StepInterpolatorAbstractTest { public MidpointStepInterpolatorTest(String name) { super(name); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; MidpointIntegrator integ = new MidpointIntegrator(step); checkDerivativesConsistency(integ, pb, 1.0e-10); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; MidpointIntegrator integ = new MidpointIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 98000); assertTrue(bos.size () < 99000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError < 1.0e-6); } public static Test suite() { return new TestSuite(MidpointStepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; public class AdamsBashforthIntegratorTest extends TestCase { public AdamsBashforthIntegratorTest(String name) { super(name); } public void testCoefficients() { double[] coeffs1 = new AdamsBashforthIntegrator(1, 0.01).getCoeffs(); assertEquals(1, coeffs1.length); assertEquals(1.0, coeffs1[0], 1.0e-16); double[] coeffs2 = new AdamsBashforthIntegrator(2, 0.01).getCoeffs(); assertEquals(2, coeffs2.length); assertEquals( 3.0 / 2.0, coeffs2[0], 1.0e-16); assertEquals(-1.0 / 2.0, coeffs2[1], 1.0e-16); double[] coeffs3 = new AdamsBashforthIntegrator(3, 0.01).getCoeffs(); assertEquals(3, coeffs3.length); assertEquals( 23.0 / 12.0, coeffs3[0], 1.0e-16); assertEquals(-16.0 / 12.0, coeffs3[1], 1.0e-16); assertEquals( 5.0 / 12.0, coeffs3[2], 1.0e-16); double[] coeffs4 = new AdamsBashforthIntegrator(4, 0.01).getCoeffs(); assertEquals(4, coeffs4.length); assertEquals( 55.0 / 24.0, coeffs4[0], 1.0e-16); assertEquals(-59.0 / 24.0, coeffs4[1], 1.0e-16); assertEquals( 37.0 / 24.0, coeffs4[2], 1.0e-16); assertEquals( -9.0 / 24.0, coeffs4[3], 1.0e-16); double[] coeffs5 = new AdamsBashforthIntegrator(5, 0.01).getCoeffs(); assertEquals(5, coeffs5.length); assertEquals( 1901.0 / 720.0, coeffs5[0], 1.0e-16); assertEquals(-2774.0 / 720.0, coeffs5[1], 1.0e-16); assertEquals( 2616.0 / 720.0, coeffs5[2], 1.0e-16); assertEquals(-1274.0 / 720.0, coeffs5[3], 1.0e-16); assertEquals( 251.0 / 720.0, coeffs5[4], 1.0e-16); double[] coeffs6 = new AdamsBashforthIntegrator(6, 0.01).getCoeffs(); assertEquals(6, coeffs6.length); assertEquals( 4277.0 / 1440.0, coeffs6[0], 1.0e-16); assertEquals(-7923.0 / 1440.0, coeffs6[1], 1.0e-16); assertEquals( 9982.0 / 1440.0, coeffs6[2], 1.0e-16); assertEquals(-7298.0 / 1440.0, coeffs6[3], 1.0e-16); assertEquals( 2877.0 / 1440.0, coeffs6[4], 1.0e-16); assertEquals( -475.0 / 1440.0, coeffs6[5], 1.0e-16); double[] coeffs7 = new AdamsBashforthIntegrator(7, 0.01).getCoeffs(); assertEquals(7, coeffs7.length); assertEquals( 198721.0 / 60480.0, coeffs7[0], 1.0e-16); assertEquals(-447288.0 / 60480.0, coeffs7[1], 1.0e-16); assertEquals( 705549.0 / 60480.0, coeffs7[2], 1.0e-16); assertEquals(-688256.0 / 60480.0, coeffs7[3], 1.0e-16); assertEquals( 407139.0 / 60480.0, coeffs7[4], 1.0e-16); assertEquals(-134472.0 / 60480.0, coeffs7[5], 1.0e-16); assertEquals( 19087.0 / 60480.0, coeffs7[6], 1.0e-16); double[] coeffs8 = new AdamsBashforthIntegrator(8, 0.01).getCoeffs(); assertEquals(8, coeffs8.length); assertEquals( 434241.0 / 120960.0, coeffs8[0], 1.0e-16); assertEquals(-1152169.0 / 120960.0, coeffs8[1], 1.0e-16); assertEquals( 2183877.0 / 120960.0, coeffs8[2], 1.0e-16); assertEquals(-2664477.0 / 120960.0, coeffs8[3], 1.0e-16); assertEquals( 2102243.0 / 120960.0, coeffs8[4], 1.0e-16); assertEquals(-1041723.0 / 120960.0, coeffs8[5], 1.0e-16); assertEquals( 295767.0 / 120960.0, coeffs8[6], 1.0e-16); assertEquals( -36799.0 / 120960.0, coeffs8[7], 1.0e-16); double[] coeffs9 = new AdamsBashforthIntegrator(9, 0.01).getCoeffs(); assertEquals(9, coeffs9.length); assertEquals( 14097247.0 / 3628800.0, coeffs9[0], 1.0e-16); assertEquals( -43125206.0 / 3628800.0, coeffs9[1], 1.0e-16); assertEquals( 95476786.0 / 3628800.0, coeffs9[2], 1.0e-16); assertEquals(-139855262.0 / 3628800.0, coeffs9[3], 1.0e-16); assertEquals( 137968480.0 / 3628800.0, coeffs9[4], 1.0e-16); assertEquals( -91172642.0 / 3628800.0, coeffs9[5], 1.0e-16); assertEquals( 38833486.0 / 3628800.0, coeffs9[6], 1.0e-16); assertEquals( -9664106.0 / 3628800.0, coeffs9[7], 1.0e-16); assertEquals( 1070017.0 / 3628800.0, coeffs9[8], 1.0e-16); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); new AdamsBashforthIntegrator(3, 0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testDecreasingSteps() throws DerivativeException, IntegratorException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousError = Double.NaN; for (int i = 6; i < 10; ++i) { TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone(); double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i); FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 6) { assertTrue(error < Math.abs(previousError)); } previousError = error; } } } public void testSmallStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 2.0e-9); assertTrue(handler.getMaximalValueError() < 3.0e-8); assertEquals(0, handler.getMaximalTimeError(), 1.0e-14); assertEquals("Adams-Bashforth", integ.getName()); } public void testBigStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() > 0.05); assertTrue(handler.getMaximalValueError() > 0.1); assertEquals(0, handler.getMaximalTimeError(), 1.0e-14); } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 8.0e-11); assertTrue(handler.getMaximalValueError() < 8.0e-11); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Adams-Bashforth", integ.getName()); } public static Test suite() { return new TestSuite(AdamsBashforthIntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderDifferentialEquations; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.MidpointIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class MidpointIntegratorTest extends TestCase { public MidpointIntegratorTest(String name) { super(name); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); new MidpointIntegrator(0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testDecreasingSteps() throws DerivativeException, IntegratorException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousError = Double.NaN; for (int i = 4; i < 10; ++i) { TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone(); double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i); FirstOrderIntegrator integ = new MidpointIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 4) { assertTrue(error < Math.abs(previousError)); } previousError = error; assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } } } public void testSmallStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new MidpointIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 2.0e-7); assertTrue(handler.getMaximalValueError() < 1.0e-6); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("midpoint", integ.getName()); } public void testBigStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new MidpointIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() > 0.01); assertTrue(handler.getMaximalValueError() > 0.05); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new MidpointIntegrator(step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 6.0e-4); assertTrue(handler.getMaximalValueError() < 6.0e-4); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("midpoint", integ.getName()); } public void testStepSize() throws DerivativeException, IntegratorException { final double step = 1.23456; FirstOrderIntegrator integ = new MidpointIntegrator(step); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = 0L; public void handleStep(StepInterpolator interpolator, boolean isLast) { if (! isLast) { assertEquals(step, interpolator.getCurrentTime() - interpolator.getPreviousTime(), 1.0e-12); } } public boolean requiresDenseOutput() { return false; } public void reset() { } }); integ.integrate(new FirstOrderDifferentialEquations() { private static final long serialVersionUID = 0L; public void computeDerivatives(double t, double[] y, double[] dot) { dot[0] = 1.0; } public int getDimension() { return 1; } }, 0.0, new double[] { 0.0 }, 5.0, new double[1]); } public static Test suite() { return new TestSuite(MidpointIntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math.ode.sampling.DummyStepHandler; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; import junit.framework.*; public class DormandPrince853IntegratorTest extends TestCase { public DormandPrince853IntegratorTest(String name) { super(name); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testNullIntervalCheck() { try { TestProblem1 pb = new TestProblem1(); DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0, 1.0e-10, 1.0e-10); integrator.integrate(pb, 0.0, new double[pb.getDimension()], 0.0, new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testMinStep() throws DerivativeException, IntegratorException { try { TestProblem1 pb = new TestProblem1(); double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime()); double maxStep = pb.getFinalTime() - pb.getInitialTime(); double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 }; double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 }; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testIncreasingTolerance() throws DerivativeException, IntegratorException { int previousCalls = Integer.MAX_VALUE; for (int i = -12; i < -2; ++i) { TestProblem1 pb = new TestProblem1(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = Math.pow(10.0, i); double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); // the 1.3 factor is only valid for this test // and has been obtained from trial and error // there is no general relation between local and global errors assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance)); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); int calls = pb.getCalls(); assertTrue(calls <= previousCalls); previousCalls = calls; } } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 8.0e-8); assertTrue(handler.getMaximalValueError() < 2.0e-7); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Dormand-Prince 8 (5, 3)", integ.getName()); } public void testEvents() throws DerivativeException, IntegratorException { TestProblem4 pb = new TestProblem4(); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-9; double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000); } assertEquals(functions.length, integ.getEventHandlers().size()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getMaximalValueError() < 5.0e-8); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep); integ.clearEventHandlers(); assertEquals(0, integ.getEventHandlers().size()); } public void testKepler() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new KeplerHandler(pb)); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(pb.getCalls() < 3300); } public void testVariableSteps() throws DerivativeException, IntegratorException { final TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new VariableHandler()); double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); assertEquals("Dormand-Prince 8 (5, 3)", integ.getName()); } public void testNoDenseOutput() throws DerivativeException, IntegratorException { TestProblem1 pb1 = new TestProblem1(); TestProblem1 pb2 = (TestProblem1) pb1.clone(); double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime()); double maxStep = pb1.getFinalTime() - pb1.getInitialTime(); double scalAbsoluteTolerance = 1.0e-4; double scalRelativeTolerance = 1.0e-4; FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(DummyStepHandler.getInstance()); integ.integrate(pb1, pb1.getInitialTime(), pb1.getInitialState(), pb1.getFinalTime(), new double[pb1.getDimension()]); int callsWithoutDenseOutput = pb1.getCalls(); integ.addStepHandler(new InterpolatingStepHandler()); integ.integrate(pb2, pb2.getInitialTime(), pb2.getInitialState(), pb2.getFinalTime(), new double[pb2.getDimension()]); int callsWithDenseOutput = pb2.getCalls(); assertTrue(callsWithDenseOutput > callsWithoutDenseOutput); } public void testUnstableDerivative() throws DerivativeException, IntegratorException { final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0); FirstOrderIntegrator integ = new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0); integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000); double[] y = { Double.NaN }; integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y); assertEquals(8.0, y[0], 1.0e-12); } private static class KeplerHandler implements StepHandler { private static final long serialVersionUID = -1752092987112788459L; public KeplerHandler(TestProblem3 pb) { this.pb = pb; reset(); } public boolean requiresDenseOutput() { return true; } public void reset() { nbSteps = 0; maxError = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { ++nbSteps; for (int a = 1; a < 10; ++a) { double prev = interpolator.getPreviousTime(); double curr = interpolator.getCurrentTime(); double interp = ((10 - a) * prev + a * curr) / 10; interpolator.setInterpolatedTime(interp); double[] interpolatedY = interpolator.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(interpolator.getInterpolatedTime()); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } if (isLast) { assertTrue(maxError < 2.4e-10); assertTrue(nbSteps < 150); } } private int nbSteps; private double maxError; private TestProblem3 pb; } private static class VariableHandler implements StepHandler { private static final long serialVersionUID = 5542665697103383623L; public VariableHandler() { reset(); } public boolean requiresDenseOutput() { return false; } public void reset() { firstTime = true; minStep = 0; maxStep = 0; } public void handleStep(StepInterpolator interpolator, boolean isLast) { double step = Math.abs(interpolator.getCurrentTime() - interpolator.getPreviousTime()); if (firstTime) { minStep = Math.abs(step); maxStep = minStep; firstTime = false; } else { if (step < minStep) { minStep = step; } if (step > maxStep) { maxStep = step; } } if (isLast) { assertTrue(minStep < (1.0 / 100.0)); assertTrue(maxStep > (1.0 / 2.0)); } } private boolean firstTime = true; private double minStep = 0; private double maxStep = 0; } private static class InterpolatingStepHandler implements StepHandler { private static final long serialVersionUID = -5272695044664350727L; public boolean requiresDenseOutput() { return true; } public void reset() { } public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { double prev = interpolator.getPreviousTime(); double curr = interpolator.getCurrentTime(); interpolator.setInterpolatedTime(0.5*(prev + curr)); } } public static Test suite() { return new TestSuite(DormandPrince853IntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderIntegrator; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.events.EventHandler; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class AdamsMoultonIntegratorTest extends TestCase { public AdamsMoultonIntegratorTest(String name) { super(name); } public void testPredictorCoefficients() { for (int order = 1; order < 10; ++order) { double[] moulton = new AdamsMoultonIntegrator(order, 0.01).getPredictorCoeffs(); double[] bashforth = new AdamsBashforthIntegrator(order, 0.01).getCoeffs(); assertEquals(bashforth.length, moulton.length); for (int i = 0; i < moulton.length; ++i) { assertEquals(bashforth[i], moulton[i], 1.0e-16); } } } public void testCorrectorCoefficients() { double[] coeffs1 = new AdamsMoultonIntegrator(1, 0.01).getCorrectorCoeffs(); assertEquals(2, coeffs1.length); assertEquals(1.0 / 2.0, coeffs1[0], 1.0e-16); assertEquals(1.0 / 2.0, coeffs1[1], 1.0e-16); double[] coeffs2 = new AdamsMoultonIntegrator(2, 0.01).getCorrectorCoeffs(); assertEquals(3, coeffs2.length); assertEquals( 5.0 / 12.0, coeffs2[0], 1.0e-16); assertEquals( 8.0 / 12.0, coeffs2[1], 1.0e-16); assertEquals(-1.0 / 12.0, coeffs2[2], 1.0e-16); double[] coeffs3 = new AdamsMoultonIntegrator(3, 0.01).getCorrectorCoeffs(); assertEquals(4, coeffs3.length); assertEquals( 9.0 / 24.0, coeffs3[0], 1.0e-16); assertEquals(19.0 / 24.0, coeffs3[1], 1.0e-16); assertEquals(-5.0 / 24.0, coeffs3[2], 1.0e-16); assertEquals( 1.0 / 24.0, coeffs3[3], 1.0e-16); double[] coeffs4 = new AdamsMoultonIntegrator(4, 0.01).getCorrectorCoeffs(); assertEquals(5, coeffs4.length); assertEquals( 251.0 / 720.0, coeffs4[0], 1.0e-16); assertEquals( 646.0 / 720.0, coeffs4[1], 1.0e-16); assertEquals(-264.0 / 720.0, coeffs4[2], 1.0e-16); assertEquals( 106.0 / 720.0, coeffs4[3], 1.0e-16); assertEquals( -19.0 / 720.0, coeffs4[4], 1.0e-16); double[] coeffs5 = new AdamsMoultonIntegrator(5, 0.01).getCorrectorCoeffs(); assertEquals(6, coeffs5.length); assertEquals( 475.0 / 1440.0, coeffs5[0], 1.0e-16); assertEquals(1427.0 / 1440.0, coeffs5[1], 1.0e-16); assertEquals(-798.0 / 1440.0, coeffs5[2], 1.0e-16); assertEquals( 482.0 / 1440.0, coeffs5[3], 1.0e-16); assertEquals(-173.0 / 1440.0, coeffs5[4], 1.0e-16); assertEquals( 27.0 / 1440.0, coeffs5[5], 1.0e-16); double[] coeffs6 = new AdamsMoultonIntegrator(6, 0.01).getCorrectorCoeffs(); assertEquals(7, coeffs6.length); assertEquals( 19087.0 / 60480.0, coeffs6[0], 1.0e-16); assertEquals( 65112.0 / 60480.0, coeffs6[1], 1.0e-16); assertEquals(-46461.0 / 60480.0, coeffs6[2], 1.0e-16); assertEquals( 37504.0 / 60480.0, coeffs6[3], 1.0e-16); assertEquals(-20211.0 / 60480.0, coeffs6[4], 1.0e-16); assertEquals( 6312.0 / 60480.0, coeffs6[5], 1.0e-16); assertEquals( -863.0 / 60480.0, coeffs6[6], 1.0e-16); double[] coeffs7 = new AdamsMoultonIntegrator(7, 0.01).getCorrectorCoeffs(); assertEquals(8, coeffs7.length); assertEquals( 36799.0 / 120960.0, coeffs7[0], 1.0e-16); assertEquals( 139849.0 / 120960.0, coeffs7[1], 1.0e-16); assertEquals(-121797.0 / 120960.0, coeffs7[2], 1.0e-16); assertEquals( 123133.0 / 120960.0, coeffs7[3], 1.0e-16); assertEquals( -88547.0 / 120960.0, coeffs7[4], 1.0e-16); assertEquals( 41499.0 / 120960.0, coeffs7[5], 1.0e-16); assertEquals( -11351.0 / 120960.0, coeffs7[6], 1.0e-16); assertEquals( 1375.0 / 120960.0, coeffs7[7], 1.0e-16); double[] coeffs8 = new AdamsMoultonIntegrator(8, 0.01).getCorrectorCoeffs(); assertEquals(9, coeffs8.length); assertEquals( 1070017.0 / 3628800.0, coeffs8[0], 1.0e-16); assertEquals( 4467094.0 / 3628800.0, coeffs8[1], 1.0e-16); assertEquals(-4604594.0 / 3628800.0, coeffs8[2], 1.0e-16); assertEquals( 5595358.0 / 3628800.0, coeffs8[3], 1.0e-16); assertEquals(-5033120.0 / 3628800.0, coeffs8[4], 1.0e-16); assertEquals( 3146338.0 / 3628800.0, coeffs8[5], 1.0e-16); assertEquals(-1291214.0 / 3628800.0, coeffs8[6], 1.0e-16); assertEquals( 312874.0 / 3628800.0, coeffs8[7], 1.0e-16); assertEquals( -33953.0 / 3628800.0, coeffs8[8], 1.0e-16); } public void testDimensionCheck() { try { TestProblem1 pb = new TestProblem1(); new AdamsMoultonIntegrator(3, 0.01).integrate(pb, 0.0, new double[pb.getDimension()+10], 1.0, new double[pb.getDimension()+10]); fail("an exception should have been thrown"); } catch(DerivativeException de) { fail("wrong exception caught"); } catch(IntegratorException ie) { } } public void testDecreasingSteps() throws DerivativeException, IntegratorException { TestProblemAbstract[] problems = TestProblemFactory.getProblems(); for (int k = 0; k < problems.length; ++k) { double previousError = Double.NaN; for (int i = 6; i < 10; ++i) { TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone(); double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i); if (pb instanceof TestProblem3) { step /= 8; } FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); EventHandler[] functions = pb.getEventsHandlers(); for (int l = 0; l < functions.length; ++l) { integ.addEventHandler(functions[l], Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000); } double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); if (functions.length == 0) { assertEquals(pb.getFinalTime(), stopTime, 1.0e-10); } double error = handler.getMaximalValueError(); if (i > 6) { assertTrue(error < Math.abs(previousError)); } previousError = error; } } } public void testSmallStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 7.0e-12); assertTrue(handler.getMaximalValueError() < 4.0e-11); assertEquals(0, handler.getMaximalTimeError(), 1.0e-14); assertEquals("Adams-Moulton", integ.getName()); } public void testBigStep() throws DerivativeException, IntegratorException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2; FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() > 0.01); assertTrue(handler.getMaximalValueError() > 0.03); assertEquals(0, handler.getMaximalTimeError(), 1.0e-14); } public void testBackward() throws DerivativeException, IntegratorException { TestProblem5 pb = new TestProblem5(); double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001; FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step); TestProblemHandler handler = new TestProblemHandler(pb, integ); integ.addStepHandler(handler); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); assertTrue(handler.getLastError() < 5.0e-10); assertTrue(handler.getMaximalValueError() < 7.0e-10); assertEquals(0, handler.getMaximalTimeError(), 1.0e-12); assertEquals("Adams-Moulton", integ.getName()); } public static Test suite() { return new TestSuite(AdamsMoultonIntegratorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import java.util.Random; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.IOException; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.nonstiff.GillIntegrator; import org.apache.commons.math.ode.sampling.StepHandler; public class GillStepInterpolatorTest extends StepInterpolatorAbstractTest { public GillStepInterpolatorTest(String name) { super(name); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; GillIntegrator integ = new GillIntegrator(step); checkDerivativesConsistency(integ, pb, 1.0e-10); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; GillIntegrator integ = new GillIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 700000); assertTrue(bos.size () < 701000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError < 0.003); } public static Test suite() { return new TestSuite(GillStepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.FirstOrderDifferentialEquations; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.sampling.StepHandler; public class EulerStepInterpolatorTest extends StepInterpolatorAbstractTest { public EulerStepInterpolatorTest(String name) { super(name); } public void testNoReset() { double[] y = { 0.0, 1.0, -2.0 }; double[][] yDot = { { 1.0, 2.0, -2.0 } }; EulerStepInterpolator interpolator = new EulerStepInterpolator(); interpolator.reinitialize(new DummyEquations(), y, yDot, true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); double[] result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10); } } public void testInterpolationAtBounds() throws DerivativeException { double t0 = 0; double[] y0 = {0.0, 1.0, -2.0}; double[] y = (double[]) y0.clone(); double[][] yDot = { new double[y0.length] }; EulerStepInterpolator interpolator = new EulerStepInterpolator(); interpolator.reinitialize(new DummyEquations(), y, yDot, true); interpolator.storeTime(t0); double dt = 1.0; y[0] = 1.0; y[1] = 3.0; y[2] = -4.0; yDot[0][0] = (y[0] - y0[0]) / dt; yDot[0][1] = (y[1] - y0[1]) / dt; yDot[0][2] = (y[2] - y0[2]) / dt; interpolator.shift(); interpolator.storeTime(t0 + dt); interpolator.setInterpolatedTime(interpolator.getPreviousTime()); double[] result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10); } interpolator.setInterpolatedTime(interpolator.getCurrentTime()); result = interpolator.getInterpolatedState(); for (int i = 0; i < result.length; ++i) { assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10); } } public void testInterpolationInside() throws DerivativeException { double[] y = { 1.0, 3.0, -4.0 }; double[][] yDot = { { 1.0, 2.0, -2.0 } }; EulerStepInterpolator interpolator = new EulerStepInterpolator(); interpolator.reinitialize(new DummyEquations(), y, yDot, true); interpolator.storeTime(0); interpolator.shift(); interpolator.storeTime(1); interpolator.setInterpolatedTime(0.1); double[] result = interpolator.getInterpolatedState(); assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10); assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10); assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10); interpolator.setInterpolatedTime(0.5); result = interpolator.getInterpolatedState(); assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10); assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10); assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; EulerIntegrator integ = new EulerIntegrator(step); checkDerivativesConsistency(integ, pb, 1.0e-10); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem1 pb = new TestProblem1(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; EulerIntegrator integ = new EulerIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 82000); assertTrue(bos.size () < 83000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError < 0.001); } private static class DummyEquations implements FirstOrderDifferentialEquations { private static final long serialVersionUID = 291437140744677100L; public int getDimension() { return 0; } public void computeDerivatives(double t, double[] y, double[] yDot) { } } public static Test suite() { return new TestSuite(EulerStepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import junit.framework.*; import java.util.Random; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; import java.io.ObjectOutputStream; import java.io.ObjectInputStream; import java.io.IOException; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator; import org.apache.commons.math.ode.sampling.StepHandler; import org.apache.commons.math.ode.sampling.StepInterpolator; public class DormandPrince853StepInterpolatorTest extends StepInterpolatorAbstractTest { public DormandPrince853StepInterpolatorTest(String name) { super(name); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.1); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); checkDerivativesConsistency(integ, pb, 1.0e-10); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 86000); assertTrue(bos.size () < 87000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError < 2.4e-10); } public void testClone() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(0.9); double minStep = 0; double maxStep = pb.getFinalTime() - pb.getInitialTime(); double scalAbsoluteTolerance = 1.0e-8; double scalRelativeTolerance = scalAbsoluteTolerance; DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance); integ.addStepHandler(new StepHandler() { private static final long serialVersionUID = 2209212559670665268L; public void handleStep(StepInterpolator interpolator, boolean isLast) throws DerivativeException { StepInterpolator cloned = interpolator.copy(); double tA = cloned.getPreviousTime(); double tB = cloned.getCurrentTime(); double halfStep = Math.abs(tB - tA) / 2; assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12); assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12); for (int i = 0; i < 10; ++i) { double t = (i * tB + (9 - i) * tA) / 9; interpolator.setInterpolatedTime(t); assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10)); cloned.setInterpolatedTime(t); assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12); double[] referenceState = interpolator.getInterpolatedState(); double[] cloneState = cloned.getInterpolatedState(); for (int j = 0; j < referenceState.length; ++j) { assertEquals(referenceState[j], cloneState[j], 1.0e-12); } } } public boolean requiresDenseOutput() { return true; } public void reset() { } }); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); } public static Test suite() { return new TestSuite(DormandPrince853StepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.ode.nonstiff; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.util.Random; import junit.framework.Test; import junit.framework.TestSuite; import org.apache.commons.math.ode.ContinuousOutputModel; import org.apache.commons.math.ode.DerivativeException; import org.apache.commons.math.ode.IntegratorException; import org.apache.commons.math.ode.sampling.StepHandler; public class ThreeEighthesStepInterpolatorTest extends StepInterpolatorAbstractTest { public ThreeEighthesStepInterpolatorTest(String name) { super(name); } public void testDerivativesConsistency() throws DerivativeException, IntegratorException { TestProblem3 pb = new TestProblem3(); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001; ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step); checkDerivativesConsistency(integ, pb, 1.0e-10); } public void testSerialization() throws DerivativeException, IntegratorException, IOException, ClassNotFoundException { TestProblem3 pb = new TestProblem3(0.9); double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003; ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step); integ.addStepHandler(new ContinuousOutputModel()); integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(), pb.getFinalTime(), new double[pb.getDimension()]); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); for (StepHandler handler : integ.getStepHandlers()) { oos.writeObject(handler); } assertTrue(bos.size () > 700000); assertTrue(bos.size () < 701000); ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); ContinuousOutputModel cm = (ContinuousOutputModel) ois.readObject(); Random random = new Random(347588535632l); double maxError = 0.0; for (int i = 0; i < 1000; ++i) { double r = random.nextDouble(); double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime(); cm.setInterpolatedTime(time); double[] interpolatedY = cm.getInterpolatedState (); double[] theoreticalY = pb.computeTheoreticalState(time); double dx = interpolatedY[0] - theoreticalY[0]; double dy = interpolatedY[1] - theoreticalY[1]; double error = dx * dx + dy * dy; if (error > maxError) { maxError = error; } } assertTrue(maxError > 0.005); } public static Test suite() { return new TestSuite(ThreeEighthesStepInterpolatorTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; import java.math.BigDecimal; /** * Test cases for the {@link BigMatrixImpl} class. * * @version $Revision$ $Date$ */ public final class BigMatrixImplTest extends TestCase { // Test data for String constructors protected String[][] testDataString = { {"1","2","3"}, {"2","5","3"}, {"1","0","8"} }; // 3 x 3 identity matrix protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} }; // Test data for group operations protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} }; protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}}; protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} }; protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, {-1d,0d,-8d} }; protected double[] testDataRow1 = {1d,2d,3d}; protected double[] testDataCol3 = {3d,3d,8d}; protected double[][] testDataInv = { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} }; protected double[] preMultTest = {8,12,33}; protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}}; protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}}; protected double[][] testDataPlusInv = { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} }; // lu decomposition tests protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} }; protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d}, {0.33333333333333,0d,0.33333333333333} }; // singular matrices protected double[][] singular = { {2d,3d}, {2d,3d} }; protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d}, {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} }; protected double[][] detData2 = { {1d, 3d}, {2d, 4d}}; // vectors protected double[] testVector = {1,2,3}; protected double[] testVector2 = {1,2,3,4}; // submatrix accessor tests protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5}, {2, 4, 6, 8}, {4, 5, 6, 7}}; // array selections protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}}; protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}}; protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}}; // effective permutations protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}}; protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}}; // contiguous ranges protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}}; protected double[][] subRows23Cols00 = {{2} , {4}}; protected double[][] subRows00Cols33 = {{4}}; // row matrices protected double[][] subRow0 = {{1,2,3,4}}; protected double[][] subRow3 = {{4,5,6,7}}; // column matrices protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}}; protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}}; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; public BigMatrixImplTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(BigMatrixImplTest.class); suite.setName("BigMatrixImpl Tests"); return suite; } public static final double[] asDouble(BigDecimal[] data) { double d[] = new double[data.length]; for (int i=0;i<d.length;i++) { d[i] = data[i].doubleValue(); } return d; } public static final double[][] asDouble(BigDecimal[][] data) { double d[][] = new double[data.length][data[0].length]; for (int i=0;i<d.length;i++) { for (int j=0;j<d[i].length;j++) d[i][j] = data[i][j].doubleValue(); } return d; } public static final BigDecimal[] asBigDecimal(double [] data) { BigDecimal d[] = new BigDecimal[data.length]; for (int i=0;i<d.length;i++) { d[i] = new BigDecimal(data[i]); } return d; } public static final BigDecimal[][] asBigDecimal(double [][] data) { BigDecimal d[][] = new BigDecimal[data.length][data[0].length]; for (int i=0;i<d.length;i++) { for (int j=0;j<data[i].length;j++) { d[i][j] = new BigDecimal(data[i][j]); } } return d; } /** test dimensions */ public void testDimensions() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrixImpl m2 = new BigMatrixImpl(testData2); assertEquals("testData row dimension",3,m.getRowDimension()); assertEquals("testData column dimension",3,m.getColumnDimension()); assertTrue("testData is square",m.isSquare()); assertEquals("testData2 row dimension",m2.getRowDimension(),2); assertEquals("testData2 column dimension",m2.getColumnDimension(),3); assertTrue("testData2 is not square",!m2.isSquare()); } /** test copy functions */ public void testCopyFunctions() { BigMatrixImpl m1 = new BigMatrixImpl(testData); BigMatrixImpl m2 = new BigMatrixImpl(m1.getData()); assertEquals(m2,m1); BigMatrixImpl m3 = new BigMatrixImpl(testData); BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false); assertEquals(m4,m3); } /** test constructors */ public void testConstructors() { BigMatrix m1 = new BigMatrixImpl(testData); BigMatrix m2 = new BigMatrixImpl(testDataString); BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData)); BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true); BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false); assertClose("double, string", m1, m2, Double.MIN_VALUE); assertClose("double, BigDecimal", m1, m3, Double.MIN_VALUE); assertClose("string, BigDecimal", m2, m3, Double.MIN_VALUE); assertClose("double, BigDecimal/true", m1, m4, Double.MIN_VALUE); assertClose("double, BigDecimal/false", m1, m5, Double.MIN_VALUE); try { new BigMatrixImpl(new String[][] {{"0", "hello", "1"}}); fail("Expecting NumberFormatException"); } catch (NumberFormatException ex) { // expected } try { new BigMatrixImpl(new String[][] {}); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { new BigMatrixImpl(new String[][] {{},{}}); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { new BigMatrixImpl(new String[][] {{"a", "b"},{"c"}}); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { new BigMatrixImpl(0, 1); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { new BigMatrixImpl(1, 0); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } } /** test add */ public void testAdd() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrixImpl mInv = new BigMatrixImpl(testDataInv); BigMatrix mPlusMInv = m.add(mInv); double[][] sumEntries = asDouble(mPlusMInv.getData()); for (int row = 0; row < m.getRowDimension(); row++) { for (int col = 0; col < m.getColumnDimension(); col++) { assertEquals("sum entry entry", testDataPlusInv[row][col],sumEntries[row][col], entryTolerance); } } } /** test add failure */ public void testAddFail() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrixImpl m2 = new BigMatrixImpl(testData2); try { m.add(m2); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } } /** test norm */ public void testNorm() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrixImpl m2 = new BigMatrixImpl(testData2); assertEquals("testData norm",14d,m.getNorm().doubleValue(),entryTolerance); assertEquals("testData2 norm",7d,m2.getNorm().doubleValue(),entryTolerance); } /** test m-n = m + -n */ public void testPlusMinus() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrixImpl m2 = new BigMatrixImpl(testDataInv); assertClose("m-n = m + -n",m.subtract(m2), m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance); try { m.subtract(new BigMatrixImpl(testData2)); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } /** test multiply */ public void testMultiply() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrixImpl mInv = new BigMatrixImpl(testDataInv); BigMatrixImpl identity = new BigMatrixImpl(id); BigMatrixImpl m2 = new BigMatrixImpl(testData2); assertClose("inverse multiply",m.multiply(mInv), identity,entryTolerance); assertClose("inverse multiply",mInv.multiply(m), identity,entryTolerance); assertClose("identity multiply",m.multiply(identity), m,entryTolerance); assertClose("identity multiply",identity.multiply(mInv), mInv,entryTolerance); assertClose("identity multiply",m2.multiply(identity), m2,entryTolerance); try { m.multiply(new BigMatrixImpl(bigSingular)); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } //Additional Test for BigMatrixImplTest.testMultiply private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}}; private double[][] d4 = new double[][] {{1},{2},{3},{4}}; private double[][] d5 = new double[][] {{30},{70}}; public void testMultiply2() { BigMatrix m3 = new BigMatrixImpl(d3); BigMatrix m4 = new BigMatrixImpl(d4); BigMatrix m5 = new BigMatrixImpl(d5); assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance); } /** test isSingular */ public void testIsSingular() { BigMatrixImpl m = new BigMatrixImpl(singular); assertTrue("singular",m.isSingular()); m = new BigMatrixImpl(bigSingular); assertTrue("big singular",m.isSingular()); m = new BigMatrixImpl(id); assertTrue("identity nonsingular",!m.isSingular()); m = new BigMatrixImpl(testData); assertTrue("testData nonsingular",!m.isSingular()); } /** test inverse */ public void testInverse() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrix mInv = new BigMatrixImpl(testDataInv); assertClose("inverse",mInv,m.inverse(),normTolerance); assertClose("inverse^2",m,m.inverse().inverse(),10E-12); // Not square m = new BigMatrixImpl(testData2); try { m.inverse(); fail("Expecting InvalidMatrixException"); } catch (InvalidMatrixException ex) { // expected } // Singular m = new BigMatrixImpl(singular); try { m.inverse(); fail("Expecting InvalidMatrixException"); } catch (InvalidMatrixException ex) { // expected } } /** test solve */ public void testSolve() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrix mInv = new BigMatrixImpl(testDataInv); // being a bit slothful here -- actually testing that X = A^-1 * B assertClose("inverse-operate", asDouble(mInv.operate(asBigDecimal(testVector))), asDouble(m.solve(asBigDecimal(testVector))), normTolerance); try { asDouble(m.solve(asBigDecimal(testVector2))); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } BigMatrix bs = new BigMatrixImpl(bigSingular); try { bs.solve(bs); fail("Expecting InvalidMatrixException"); } catch (InvalidMatrixException ex) { ; } try { m.solve(bs); fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } try { new BigMatrixImpl(testData2).solve(bs); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } try { (new BigMatrixImpl(testData2)).luDecompose(); fail("Expecting InvalidMatrixException"); } catch (InvalidMatrixException ex) { ; } } /** test determinant */ public void testDeterminant() { BigMatrix m = new BigMatrixImpl(bigSingular); assertEquals("singular determinant",0,m.getDeterminant().doubleValue(),0); m = new BigMatrixImpl(detData); assertEquals("nonsingular test",-3d,m.getDeterminant().doubleValue(),normTolerance); // Examples verified against R (version 1.8.1, Red Hat Linux 9) m = new BigMatrixImpl(detData2); assertEquals("nonsingular R test 1",-2d,m.getDeterminant().doubleValue(),normTolerance); m = new BigMatrixImpl(testData); assertEquals("nonsingular R test 2",-1d,m.getDeterminant().doubleValue(),normTolerance); try { new BigMatrixImpl(testData2).getDeterminant().doubleValue(); fail("Expecting InvalidMatrixException"); } catch (InvalidMatrixException ex) { ; } } /** test trace */ public void testTrace() { BigMatrix m = new BigMatrixImpl(id); assertEquals("identity trace",3d,m.getTrace().doubleValue(),entryTolerance); m = new BigMatrixImpl(testData2); try { m.getTrace().doubleValue(); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } /** test sclarAdd */ public void testScalarAdd() { BigMatrix m = new BigMatrixImpl(testData); assertClose("scalar add",new BigMatrixImpl(testDataPlus2), m.scalarAdd(new BigDecimal(2d)),entryTolerance); } /** test operate */ public void testOperate() { BigMatrix m = new BigMatrixImpl(id); double[] x = asDouble(m.operate(asBigDecimal(testVector))); assertClose("identity operate",testVector,x,entryTolerance); m = new BigMatrixImpl(bigSingular); try { asDouble(m.operate(asBigDecimal(testVector))); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } /** test issue MATH-209 */ public void testMath209() { BigMatrix a = new BigMatrixImpl(new BigDecimal[][] { { new BigDecimal(1), new BigDecimal(2) }, { new BigDecimal(3), new BigDecimal(4) }, { new BigDecimal(5), new BigDecimal(6) } }, false); BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) }); assertEquals(a.getRowDimension(), b.length); assertEquals( 3.0, b[0].doubleValue(), 1.0e-12); assertEquals( 7.0, b[1].doubleValue(), 1.0e-12); assertEquals(11.0, b[2].doubleValue(), 1.0e-12); } /** test transpose */ public void testTranspose() { BigMatrix m = new BigMatrixImpl(testData); assertClose("inverse-transpose",m.inverse().transpose(), m.transpose().inverse(),normTolerance); m = new BigMatrixImpl(testData2); BigMatrix mt = new BigMatrixImpl(testData2T); assertClose("transpose",mt,m.transpose(),normTolerance); } /** test preMultiply by vector */ public void testPremultiplyVector() { BigMatrix m = new BigMatrixImpl(testData); assertClose("premultiply",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance); m = new BigMatrixImpl(bigSingular); try { m.preMultiply(asBigDecimal(testVector)); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } public void testPremultiply() { BigMatrix m3 = new BigMatrixImpl(d3); BigMatrix m4 = new BigMatrixImpl(d4); BigMatrix m5 = new BigMatrixImpl(d5); assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance); BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrixImpl mInv = new BigMatrixImpl(testDataInv); BigMatrixImpl identity = new BigMatrixImpl(id); new BigMatrixImpl(testData2); assertClose("inverse multiply",m.preMultiply(mInv), identity,entryTolerance); assertClose("inverse multiply",mInv.preMultiply(m), identity,entryTolerance); assertClose("identity multiply",m.preMultiply(identity), m,entryTolerance); assertClose("identity multiply",identity.preMultiply(mInv), mInv,entryTolerance); try { m.preMultiply(new BigMatrixImpl(bigSingular)); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } public void testGetVectors() { BigMatrix m = new BigMatrixImpl(testData); assertClose("get row",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance); assertClose("get col",m.getColumnAsDoubleArray(2),testDataCol3,entryTolerance); try { m.getRowAsDoubleArray(10); fail("expecting MatrixIndexException"); } catch (MatrixIndexException ex) { ; } try { m.getColumnAsDoubleArray(-1); fail("expecting MatrixIndexException"); } catch (MatrixIndexException ex) { ; } } public void testLUDecomposition() throws Exception { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrix lu = m.getLUMatrix(); assertClose("LU decomposition", lu, (BigMatrix) new BigMatrixImpl(testDataLU), normTolerance); verifyDecomposition(m, lu); m = new BigMatrixImpl(luData); lu = m.getLUMatrix(); assertClose("LU decomposition", lu, (BigMatrix) new BigMatrixImpl(luDataLUDecomposition), normTolerance); verifyDecomposition(m, lu); m = new BigMatrixImpl(testDataMinus); lu = m.getLUMatrix(); verifyDecomposition(m, lu); m = new BigMatrixImpl(id); lu = m.getLUMatrix(); verifyDecomposition(m, lu); try { m = new BigMatrixImpl(bigSingular); // singular lu = m.getLUMatrix(); fail("Expecting InvalidMatrixException"); } catch (InvalidMatrixException ex) { // expected } try { m = new BigMatrixImpl(testData2); // not square lu = m.getLUMatrix(); fail("Expecting InvalidMatrixException"); } catch (InvalidMatrixException ex) { // expected } } /** * test submatrix accessors */ public void testSubMatrix() { BigMatrix m = new BigMatrixImpl(subTestData); BigMatrix mRows23Cols00 = new BigMatrixImpl(subRows23Cols00); BigMatrix mRows00Cols33 = new BigMatrixImpl(subRows00Cols33); BigMatrix mRows01Cols23 = new BigMatrixImpl(subRows01Cols23); BigMatrix mRows02Cols13 = new BigMatrixImpl(subRows02Cols13); BigMatrix mRows03Cols12 = new BigMatrixImpl(subRows03Cols12); BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123); BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123); BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31); assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2 , 3 , 0, 0)); assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0 , 0 , 3, 3)); assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0 , 1 , 2, 3)); assertEquals("Rows02Cols13", mRows02Cols13, m.getSubMatrix(new int[] {0,2}, new int[] {1,3})); assertEquals("Rows03Cols12", mRows03Cols12, m.getSubMatrix(new int[] {0,3}, new int[] {1,2})); assertEquals("Rows03Cols123", mRows03Cols123, m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3})); assertEquals("Rows20Cols123", mRows20Cols123, m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3})); assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); try { m.getSubMatrix(1,0,2,4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(-1,1,2,2); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(1,0,2,2); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(1,0,2,4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(new int[] {}, new int[] {0}); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(new int[] {0}, new int[] {4}); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } public void testGetColumnMatrix() { BigMatrix m = new BigMatrixImpl(subTestData); BigMatrix mColumn1 = new BigMatrixImpl(subColumn1); BigMatrix mColumn3 = new BigMatrixImpl(subColumn3); assertEquals("Column1", mColumn1, m.getColumnMatrix(1)); assertEquals("Column3", mColumn3, m.getColumnMatrix(3)); try { m.getColumnMatrix(-1); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getColumnMatrix(4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } public void testGetRowMatrix() { BigMatrix m = new BigMatrixImpl(subTestData); BigMatrix mRow0 = new BigMatrixImpl(subRow0); BigMatrix mRow3 = new BigMatrixImpl(subRow3); assertEquals("Row0", mRow0, m.getRowMatrix(0)); assertEquals("Row3", mRow3, m.getRowMatrix(3)); try { m.getRowMatrix(-1); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getRowMatrix(4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } public void testEqualsAndHashCode() { BigMatrixImpl m = new BigMatrixImpl(testData); BigMatrixImpl m1 = (BigMatrixImpl) m.copy(); BigMatrixImpl mt = (BigMatrixImpl) m.transpose(); assertTrue(m.hashCode() != mt.hashCode()); assertEquals(m.hashCode(), m1.hashCode()); assertEquals(m, m); assertEquals(m, m1); assertFalse(m.equals(null)); assertFalse(m.equals(mt)); assertFalse(m.equals(new BigMatrixImpl(bigSingular))); // Different scales make BigDecimals, so matrices unequal m = new BigMatrixImpl(new String[][] {{"2.0"}}); m1 = new BigMatrixImpl(new String[][] {{"2.00"}}); assertTrue(m.hashCode() != m1.hashCode()); assertFalse(m.equals(m1)); } public void testToString() { BigMatrixImpl m = new BigMatrixImpl(testData); assertEquals("BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}", m.toString()); m = new BigMatrixImpl(); assertEquals("BigMatrixImpl{}", m.toString()); } public void testSetSubMatrix() throws Exception { BigDecimal[][] detData3 = MatrixUtils.createBigMatrix(detData2).getData(); BigMatrixImpl m = new BigMatrixImpl(testData); m.setSubMatrix(detData3,1,1); BigMatrix expected = MatrixUtils.createBigMatrix (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}}); assertEquals(expected, m); m.setSubMatrix(detData3,0,0); expected = MatrixUtils.createBigMatrix (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}}); assertEquals(expected, m); BigDecimal[][] testDataPlus3 = MatrixUtils.createBigMatrix(testDataPlus2).getData(); m.setSubMatrix(testDataPlus3,0,0); expected = MatrixUtils.createBigMatrix (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}}); assertEquals(expected, m); // javadoc example BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}}); matrix.setSubMatrix(new BigDecimal[][] {{new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(6)}}, 1, 1); expected = MatrixUtils.createBigMatrix (new BigDecimal[][] {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3), new BigDecimal(4)}, {new BigDecimal(5), new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)}, {new BigDecimal(9), new BigDecimal(5) , new BigDecimal(6), new BigDecimal(2)}}); assertEquals(expected, matrix); // dimension overflow try { m.setSubMatrix(matrix.getData(),1,1); fail("expecting MatrixIndexException"); } catch (MatrixIndexException e) { // expected } // null try { m.setSubMatrix(null,1,1); fail("expecting NullPointerException"); } catch (NullPointerException e) { // expected } // ragged try { m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)}, {new BigDecimal(2), new BigDecimal(3)}}, 0, 0); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException e) { // expected } // empty try { m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException e) { // expected } } //--------------- -----------------Protected methods /** verifies that two matrices are close (1-norm) */ protected void assertClose(String msg, BigMatrix m, BigMatrix n, double tolerance) { assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance); } /** verifies that two vectors are close (sup norm) */ protected void assertClose(String msg, double[] m, double[] n, double tolerance) { if (m.length != n.length) { fail("vectors not same length"); } for (int i = 0; i < m.length; i++) { assertEquals(msg + " " + i + " elements differ", m[i],n[i],tolerance); } } /** extracts the l and u matrices from compact lu representation */ protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException { if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length || lowerData.length != upperData.length || lowerData.length != lu.getRowDimension()) { throw new InvalidMatrixException("incorrect dimensions", null); } int n = lu.getRowDimension(); for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (j < i) { lowerData[i][j] = lu.getEntry(i, j); upperData[i][j] = new BigDecimal(0); } else if (i == j) { lowerData[i][j] = new BigDecimal(1); upperData[i][j] = lu.getEntry(i, j); } else { lowerData[i][j] = new BigDecimal(0); upperData[i][j] = lu.getEntry(i, j); } } } } /** Returns the result of applying the given row permutation to the matrix */ protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) { if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) { throw new IllegalArgumentException("dimension mismatch"); } int n = matrix.getRowDimension(); int m = matrix.getColumnDimension(); BigDecimal out[][] = new BigDecimal[m][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { out[i][j] = matrix.getEntry(permutation[i], j); } } return new BigMatrixImpl(out); } /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */ protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{ int n = matrix.getRowDimension(); BigDecimal[][] lowerData = new BigDecimal[n][n]; BigDecimal[][] upperData = new BigDecimal[n][n]; splitLU(lu, lowerData, upperData); BigMatrix lower =new BigMatrixImpl(lowerData); BigMatrix upper = new BigMatrixImpl(upperData); int[] permutation = ((BigMatrixImpl) matrix).getPermutation(); BigMatrix permuted = permuteRows(matrix, permutation); assertClose("lu decomposition does not work", permuted, lower.multiply(upper), normTolerance); } // /** Useful for debugging */ // private void dumpMatrix(BigMatrix m) { // for (int i = 0; i < m.getRowDimension(); i++) { // String os = ""; // for (int j = 0; j < m.getColumnDimension(); j++) { // os += m.getEntry(i, j) + " "; // } // System.out.println(os); // } // } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import java.util.Locale; public class RealVectorFormatTest extends RealVectorFormatAbstractTest { protected char getDecimalCharacter() { return '.'; } protected Locale getLocale() { return Locale.US; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import java.util.Arrays; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class TriDiagonalTransformerTest extends TestCase { private double[][] testSquare5 = { { 1, 2, 3, 1, 1 }, { 2, 1, 1, 3, 1 }, { 3, 1, 1, 1, 2 }, { 1, 3, 1, 2, 1 }, { 1, 1, 2, 1, 3 } }; private double[][] testSquare3 = { { 1, 3, 4 }, { 3, 2, 2 }, { 4, 2, 0 } }; public TriDiagonalTransformerTest(String name) { super(name); } public void testNonSquare() { try { new TriDiagonalTransformer(new RealMatrixImpl(new double[3][2], false)); fail("an exception should have been thrown"); } catch (InvalidMatrixException ime) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } public void testAEqualQTQt() { checkAEqualQTQt(new RealMatrixImpl(testSquare5, false)); checkAEqualQTQt(new RealMatrixImpl(testSquare3, false)); } private void checkAEqualQTQt(RealMatrix matrix) { TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix); RealMatrix q = transformer.getQ(); RealMatrix qT = transformer.getQT(); RealMatrix t = transformer.getT(); double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm(); assertEquals(0, norm, 4.0e-15); } public void testNoAccessBelowDiagonal() { checkNoAccessBelowDiagonal(testSquare5); checkNoAccessBelowDiagonal(testSquare3); } private void checkNoAccessBelowDiagonal(double[][] data) { double[][] modifiedData = new double[data.length][]; for (int i = 0; i < data.length; ++i) { modifiedData[i] = data[i].clone(); Arrays.fill(modifiedData[i], 0, i, Double.NaN); } RealMatrix matrix = new RealMatrixImpl(modifiedData, false); TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix); RealMatrix q = transformer.getQ(); RealMatrix qT = transformer.getQT(); RealMatrix t = transformer.getT(); double norm = q.multiply(t).multiply(qT).subtract(new RealMatrixImpl(data, false)).getNorm(); assertEquals(0, norm, 4.0e-15); } public void testQOrthogonal() { checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getQ()); checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getQ()); } public void testQTOrthogonal() { checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getQT()); checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getQT()); } private void checkOrthogonal(RealMatrix m) { RealMatrix mTm = m.transpose().multiply(m); RealMatrix id = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension()); assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15); } public void testTTriDiagonal() { checkTriDiagonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getT()); checkTriDiagonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getT()); } private void checkTriDiagonal(RealMatrix m) { final int rows = m.getRowDimension(); final int cols = m.getColumnDimension(); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { if ((i < j - 1) || (i > j + 1)) { assertEquals(0, m.getEntry(i, j), 1.0e-16); } } } } public void testMatricesValues5() { checkMatricesValues(testSquare5, new double[][] { { 1.0, 0.0, 0.0, 0.0, 0.0 }, { 0.0, -0.5163977794943222, 0.016748280772542083, 0.839800693771262, 0.16669620021405473 }, { 0.0, -0.7745966692414833, -0.4354553000860955, -0.44989322880603355, -0.08930153582895772 }, { 0.0, -0.2581988897471611, 0.6364346693566014, -0.30263204032131164, 0.6608313651342882 }, { 0.0, -0.2581988897471611, 0.6364346693566009, -0.027289660803112598, -0.7263191580755246 } }, new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 }, new double[] { -Math.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 }); } public void testMatricesValues3() { checkMatricesValues(testSquare3, new double[][] { { 1.0, 0.0, 0.0 }, { 0.0, -0.6, 0.8 }, { 0.0, -0.8, -0.6 }, }, new double[] { 1, 2.64, -0.64 }, new double[] { -5, -1.52 }); } private void checkMatricesValues(double[][] matrix, double[][] qRef, double[] mainDiagnonal, double[] secondaryDiagonal) { TriDiagonalTransformer transformer = new TriDiagonalTransformer(new RealMatrixImpl(matrix, false)); // check values against known references RealMatrix q = transformer.getQ(); assertEquals(0, q.subtract(new RealMatrixImpl(qRef, false)).getNorm(), 1.0e-14); RealMatrix t = transformer.getT(); double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length]; for (int i = 0; i < mainDiagnonal.length; ++i) { tData[i][i] = mainDiagnonal[i]; if (i > 0) { tData[i][i - 1] = secondaryDiagonal[i - 1]; } if (i < secondaryDiagonal.length) { tData[i][i + 1] = secondaryDiagonal[i]; } } assertEquals(0, t.subtract(new RealMatrixImpl(tData, false)).getNorm(), 1.0e-14); // check the same cached instance is returned the second time assertTrue(q == transformer.getQ()); assertTrue(t == transformer.getT()); } public static Test suite() { return new TestSuite(TriDiagonalTransformerTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class QRDecompositionImplTest extends TestCase { double[][] testData3x3NonSingular = { { 12, -51, 4 }, { 6, 167, -68 }, { -4, 24, -41 }, }; double[][] testData3x3Singular = { { 1, 4, 7, }, { 2, 5, 8, }, { 3, 6, 9, }, }; double[][] testData3x4 = { { 12, -51, 4, 1 }, { 6, 167, -68, 2 }, { -4, 24, -41, 3 }, }; double[][] testData4x3 = { { 12, -51, 4, }, { 6, 167, -68, }, { -4, 24, -41, }, { -5, 34, 7, }, }; private static final double entryTolerance = 10e-16; private static final double normTolerance = 10e-14; public QRDecompositionImplTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(QRDecompositionImplTest.class); suite.setName("QRDecompositionImpl Tests"); return suite; } /** test dimensions */ public void testDimensions() { RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false); QRDecomposition qr = new QRDecompositionImpl(matrix); assertEquals("3x3 Q size", qr.getQ().getRowDimension(), 3); assertEquals("3x3 Q size", qr.getQ().getColumnDimension(), 3); assertEquals("3x3 R size", qr.getR().getRowDimension(), 3); assertEquals("3x3 R size", qr.getR().getColumnDimension(), 3); matrix = new RealMatrixImpl(testData4x3, false); qr = new QRDecompositionImpl(matrix); assertEquals("4x3 Q size", qr.getQ().getRowDimension(), 4); assertEquals("4x3 Q size", qr.getQ().getColumnDimension(), 4); assertEquals("4x3 R size", qr.getR().getRowDimension(), 4); assertEquals("4x3 R size", qr.getR().getColumnDimension(), 3); matrix = new RealMatrixImpl(testData3x4, false); qr = new QRDecompositionImpl(matrix); assertEquals("3x4 Q size", qr.getQ().getRowDimension(), 3); assertEquals("3x4 Q size", qr.getQ().getColumnDimension(), 3); assertEquals("3x4 R size", qr.getR().getRowDimension(), 3); assertEquals("3x4 R size", qr.getR().getColumnDimension(), 4); } /** test A = QR */ public void testAEqualQR() { RealMatrix A = new RealMatrixImpl(testData3x3NonSingular, false); QRDecomposition qr = new QRDecompositionImpl(A); RealMatrix Q = qr.getQ(); RealMatrix R = qr.getR(); double norm = Q.multiply(R).subtract(A).getNorm(); assertEquals("3x3 nonsingular A = QR", 0, norm, normTolerance); RealMatrix matrix = new RealMatrixImpl(testData3x3Singular, false); qr = new QRDecompositionImpl(matrix); norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm(); assertEquals("3x3 singular A = QR", 0, norm, normTolerance); matrix = new RealMatrixImpl(testData3x4, false); qr = new QRDecompositionImpl(matrix); norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm(); assertEquals("3x4 A = QR", 0, norm, normTolerance); matrix = new RealMatrixImpl(testData4x3, false); qr = new QRDecompositionImpl(matrix); norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm(); assertEquals("4x3 A = QR", 0, norm, normTolerance); } /** test the orthogonality of Q */ public void testQOrthogonal() { RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular, false); RealMatrix q = new QRDecompositionImpl(matrix).getQ(); RealMatrix qT = new QRDecompositionImpl(matrix).getQT(); RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3); double norm = qT.multiply(q).subtract(eye).getNorm(); assertEquals("3x3 nonsingular Q'Q = I", 0, norm, normTolerance); matrix = new RealMatrixImpl(testData3x3Singular, false); q = new QRDecompositionImpl(matrix).getQ(); qT = new QRDecompositionImpl(matrix).getQT(); eye = MatrixUtils.createRealIdentityMatrix(3); norm = qT.multiply(q).subtract(eye).getNorm(); assertEquals("3x3 singular Q'Q = I", 0, norm, normTolerance); matrix = new RealMatrixImpl(testData3x4, false); q = new QRDecompositionImpl(matrix).getQ(); qT = new QRDecompositionImpl(matrix).getQT(); eye = MatrixUtils.createRealIdentityMatrix(3); norm = qT.multiply(q).subtract(eye).getNorm(); assertEquals("3x4 Q'Q = I", 0, norm, normTolerance); matrix = new RealMatrixImpl(testData4x3, false); q = new QRDecompositionImpl(matrix).getQ(); qT = new QRDecompositionImpl(matrix).getQT(); eye = MatrixUtils.createRealIdentityMatrix(4); norm = qT.multiply(q).subtract(eye).getNorm(); assertEquals("4x3 Q'Q = I", 0, norm, normTolerance); } /** test that R is upper triangular */ public void testRUpperTriangular() { RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false); RealMatrix R = new QRDecompositionImpl(matrix).getR(); for (int i = 0; i < R.getRowDimension(); i++) for (int j = 0; j < i; j++) assertEquals("R lower triangle", R.getEntry(i, j), 0, entryTolerance); matrix = new RealMatrixImpl(testData3x3Singular, false); R = new QRDecompositionImpl(matrix).getR(); for (int i = 0; i < R.getRowDimension(); i++) for (int j = 0; j < i; j++) assertEquals("R lower triangle", R.getEntry(i, j), 0, entryTolerance); matrix = new RealMatrixImpl(testData3x4, false); R = new QRDecompositionImpl(matrix).getR(); for (int i = 0; i < R.getRowDimension(); i++) for (int j = 0; j < i; j++) assertEquals("R lower triangle", R.getEntry(i, j), 0, entryTolerance); matrix = new RealMatrixImpl(testData4x3, false); R = new QRDecompositionImpl(matrix).getR(); for (int i = 0; i < R.getRowDimension(); i++) for (int j = 0; j < i; j++) assertEquals("R lower triangle", R.getEntry(i, j), 0, entryTolerance); } /** test that H is trapezoidal */ public void testHTrapezoidal() { RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false); RealMatrix H = new QRDecompositionImpl(matrix).getH(); for (int i = 0; i < H.getRowDimension(); i++) for (int j = i + 1; j < H.getColumnDimension(); j++) assertEquals(H.getEntry(i, j), 0, entryTolerance); matrix = new RealMatrixImpl(testData3x3Singular, false); H = new QRDecompositionImpl(matrix).getH(); for (int i = 0; i < H.getRowDimension(); i++) for (int j = i + 1; j < H.getColumnDimension(); j++) assertEquals(H.getEntry(i, j), 0, entryTolerance); matrix = new RealMatrixImpl(testData3x4, false); H = new QRDecompositionImpl(matrix).getH(); for (int i = 0; i < H.getRowDimension(); i++) for (int j = i + 1; j < H.getColumnDimension(); j++) assertEquals(H.getEntry(i, j), 0, entryTolerance); matrix = new RealMatrixImpl(testData4x3, false); H = new QRDecompositionImpl(matrix).getH(); for (int i = 0; i < H.getRowDimension(); i++) for (int j = i + 1; j < H.getColumnDimension(); j++) assertEquals(H.getEntry(i, j), 0, entryTolerance); } /** test rank */ public void testRank() { QRDecomposition qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)); assertTrue(qr.isNonSingular()); qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false)); assertFalse(qr.isNonSingular()); qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x4, false)); assertFalse(qr.isNonSingular()); qr = new QRDecompositionImpl(new RealMatrixImpl(testData4x3, false)); assertTrue(qr.isNonSingular()); } /** test solve dimension errors */ public void testSolveDimensionErrors() { QRDecomposition qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)); RealMatrix b = new RealMatrixImpl(new double[2][2]); try { qr.solve(b); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { qr.solve(b.getColumn(0)); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { qr.solve(b.getColumnVector(0)); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** test solve rank errors */ public void testSolveRankErrors() { QRDecomposition qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false)); RealMatrix b = new RealMatrixImpl(new double[3][2]); try { qr.solve(b); fail("an exception should have been thrown"); } catch (InvalidMatrixException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { qr.solve(b.getColumn(0)); fail("an exception should have been thrown"); } catch (InvalidMatrixException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { qr.solve(b.getColumnVector(0)); fail("an exception should have been thrown"); } catch (InvalidMatrixException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** test solve */ public void testSolve() { QRDecomposition qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)); RealMatrix b = new RealMatrixImpl(new double[][] { { -102, 12250 }, { 544, 24500 }, { 167, -36750 } }); RealMatrix xRef = new RealMatrixImpl(new double[][] { { 1, 2515 }, { 2, 422 }, { -3, 898 } }); // using RealMatrix assertEquals(0, qr.solve(b).subtract(xRef).getNorm(), 1.0e-13); // using double[] for (int i = 0; i < b.getColumnDimension(); ++i) { assertEquals(0, new RealVectorImpl(qr.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } // using RealVectorImpl for (int i = 0; i < b.getColumnDimension(); ++i) { assertEquals(0, qr.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } // using RealVector with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { RealVectorImplTest.RealVectorTestImpl v = new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i)); assertEquals(0, qr.solve(v).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } } /** test matrices values */ public void testMatricesValues() { QRDecomposition qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false)); RealMatrix qRef = new RealMatrixImpl(new double[][] { { -12.0 / 14.0, 69.0 / 175.0, -58.0 / 175.0 }, { -6.0 / 14.0, -158.0 / 175.0, 6.0 / 175.0 }, { 4.0 / 14.0, -30.0 / 175.0, -165.0 / 175.0 } }); RealMatrix rRef = new RealMatrixImpl(new double[][] { { -14.0, -21.0, 14.0 }, { 0.0, -175.0, 70.0 }, { 0.0, 0.0, 35.0 } }); RealMatrix hRef = new RealMatrixImpl(new double[][] { { 26.0 / 14.0, 0.0, 0.0 }, { 6.0 / 14.0, 648.0 / 325.0, 0.0 }, { -4.0 / 14.0, 36.0 / 325.0, 2.0 } }); // check values against known references RealMatrix q = qr.getQ(); assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13); RealMatrix qT = qr.getQT(); assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13); RealMatrix r = qr.getR(); assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13); RealMatrix h = qr.getH(); assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13); // check the same cached instance is returned the second time assertTrue(q == qr.getQ()); assertTrue(r == qr.getR()); assertTrue(h == qr.getH()); } /** test no call to decompose */ public void testNoDecompose() { try { new QRDecompositionImpl().isNonSingular(); fail("an exception should have been caught"); } catch (IllegalStateException ise) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class InvalidMatrixExceptionTest extends TestCase { /** * */ public void testConstructorMessage(){ String msg = "message"; InvalidMatrixException ex = new InvalidMatrixException(msg, null); assertEquals(msg, ex.getMessage()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import java.text.NumberFormat; import java.text.ParseException; import java.text.ParsePosition; import java.util.Locale; import junit.framework.TestCase; import org.apache.commons.math.util.CompositeFormat; public abstract class RealVectorFormatAbstractTest extends TestCase { RealVectorFormat realVectorFormat = null; RealVectorFormat realVectorFormatSquare = null; protected abstract Locale getLocale(); protected abstract char getDecimalCharacter(); protected void setUp() throws Exception { realVectorFormat = RealVectorFormat.getInstance(getLocale()); final NumberFormat nf = NumberFormat.getInstance(getLocale()); nf.setMaximumFractionDigits(2); realVectorFormatSquare = new RealVectorFormat("[", "]", " : ", nf); } public void testSimpleNoDecimals() { RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1}); String expected = "{1; 1; 1}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void testSimpleWithDecimals() { RealVectorImpl c = new RealVectorImpl(new double[] {1.23, 1.43, 1.63}); String expected = "{1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void testSimpleWithDecimalsTrunc() { RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333}); String expected = "{1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void testNegativeX() { RealVectorImpl c = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333}); String expected = "{-1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void testNegativeY() { RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333}); String expected = "{1" + getDecimalCharacter() + "23; -1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void testNegativeZ() { RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333}); String expected = "{1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; -1" + getDecimalCharacter() + "63}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void testNonDefaultSetting() { RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1}); String expected = "[1 : 1 : 1]"; String actual = realVectorFormatSquare.format(c); assertEquals(expected, actual); } public void testStaticFormatRealVectorImpl() { Locale defaultLocal = Locale.getDefault(); Locale.setDefault(getLocale()); RealVectorImpl c = new RealVectorImpl(new double[] {232.222, -342.33, 432.444}); String expected = "{232" + getDecimalCharacter() + "22; -342" + getDecimalCharacter() + "33; 432" + getDecimalCharacter() + "44}"; String actual = RealVectorFormat.formatRealVector(c); assertEquals(expected, actual); Locale.setDefault(defaultLocal); } public void testNan() { RealVectorImpl c = new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN}); String expected = "{(NaN); (NaN); (NaN)}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void testPositiveInfinity() { RealVectorImpl c = new RealVectorImpl(new double[] { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY }); String expected = "{(Infinity); (Infinity); (Infinity)}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void tesNegativeInfinity() { RealVectorImpl c = new RealVectorImpl(new double[] { Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY }); String expected = "{(-Infinity); (-Infinity); (-Infinity)}"; String actual = realVectorFormat.format(c); assertEquals(expected, actual); } public void testParseSimpleNoDecimals() { String source = "{1; 1; 1}"; RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseIgnoredWhitespace() { RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1}); ParsePosition pos1 = new ParsePosition(0); String source1 = "{1;1;1}"; assertEquals(expected, realVectorFormat.parseObject(source1, pos1)); assertEquals(source1.length(), pos1.getIndex()); ParsePosition pos2 = new ParsePosition(0); String source2 = " { 1 ; 1 ; 1 } "; assertEquals(expected, realVectorFormat.parseObject(source2, pos2)); assertEquals(source2.length() - 1, pos2.getIndex()); } public void testParseSimpleWithDecimals() { String source = "{1" + getDecimalCharacter() + "23; 1" + getDecimalCharacter() + "43; 1" + getDecimalCharacter() + "63}"; RealVectorImpl expected = new RealVectorImpl(new double[] {1.23, 1.43, 1.63}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseSimpleWithDecimalsTrunc() { String source = "{1" + getDecimalCharacter() + "2323; 1" + getDecimalCharacter() + "4343; 1" + getDecimalCharacter() + "6333}"; RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeX() { String source = "{-1" + getDecimalCharacter() + "2323; 1" + getDecimalCharacter() + "4343; 1" + getDecimalCharacter() + "6333}"; RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeY() { String source = "{1" + getDecimalCharacter() + "2323; -1" + getDecimalCharacter() + "4343; 1" + getDecimalCharacter() + "6333}"; RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeZ() { String source = "{1" + getDecimalCharacter() + "2323; 1" + getDecimalCharacter() + "4343; -1" + getDecimalCharacter() + "6333}"; RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeAll() { String source = "{-1" + getDecimalCharacter() + "2323; -1" + getDecimalCharacter() + "4343; -1" + getDecimalCharacter() + "6333}"; RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, -1.4343, -1.6333}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseZeroX() { String source = "{0" + getDecimalCharacter() + "0; -1" + getDecimalCharacter() + "4343; 1" + getDecimalCharacter() + "6333}"; RealVectorImpl expected = new RealVectorImpl(new double[] {0.0, -1.4343, 1.6333}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNonDefaultSetting() { String source = "[1" + getDecimalCharacter() + "2323 : 1" + getDecimalCharacter() + "4343 : 1" + getDecimalCharacter() + "6333]"; RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333}); try { RealVectorImpl actual = (RealVectorImpl) realVectorFormatSquare.parseObject(source); assertEquals(expected, actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNan() { String source = "{(NaN); (NaN); (NaN)}"; try { RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); assertEquals(new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParsePositiveInfinity() { String source = "{(Infinity); (Infinity); (Infinity)}"; try { RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); assertEquals(new RealVectorImpl(new double[] { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY }), actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNegativeInfinity() { String source = "{(-Infinity); (-Infinity); (-Infinity)}"; try { RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); assertEquals(new RealVectorImpl(new double[] { Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY }), actual); } catch (ParseException ex) { fail(ex.getMessage()); } } public void testParseNoComponents() { try { realVectorFormat.parseObject("{ }"); } catch (ParseException pe) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } public void testParseManyComponents() throws ParseException { RealVectorImpl parsed = (RealVectorImpl) realVectorFormat.parseObject("{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}"); assertEquals(24, parsed.getDimension()); } public void testConstructorSingleFormat() { NumberFormat nf = NumberFormat.getInstance(); RealVectorFormat cf = new RealVectorFormat(nf); assertNotNull(cf); assertEquals(nf, cf.getFormat()); } public void testFormatObject() { try { CompositeFormat cf = new RealVectorFormat(); Object object = new Object(); cf.format(object); fail(); } catch (IllegalArgumentException ex) { // success } } public void testForgottenPrefix() { ParsePosition pos = new ParsePosition(0); assertNull(new RealVectorFormat().parse("1; 1; 1}", pos)); assertEquals(0, pos.getErrorIndex()); } public void testForgottenSeparator() { ParsePosition pos = new ParsePosition(0); assertNull(new RealVectorFormat().parse("{1; 1 1}", pos)); assertEquals(6, pos.getErrorIndex()); } public void testForgottenSuffix() { ParsePosition pos = new ParsePosition(0); assertNull(new RealVectorFormat().parse("{1; 1; 1 ", pos)); assertEquals(8, pos.getErrorIndex()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test cases for the {@link RealMatrixImpl} class. * * @version $Revision$ $Date$ */ public final class RealMatrixImplTest extends TestCase { // 3 x 3 identity matrix protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} }; // Test data for group operations protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} }; protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}}; protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} }; protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, {-1d,0d,-8d} }; protected double[] testDataRow1 = {1d,2d,3d}; protected double[] testDataCol3 = {3d,3d,8d}; protected double[][] testDataInv = { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} }; protected double[] preMultTest = {8,12,33}; protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}}; protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}}; protected double[][] testDataPlusInv = { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} }; // lu decomposition tests protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} }; protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d}, {0.33333333333333,0d,0.33333333333333} }; // singular matrices protected double[][] singular = { {2d,3d}, {2d,3d} }; protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d}, {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} }; protected double[][] detData2 = { {1d, 3d}, {2d, 4d}}; // vectors protected double[] testVector = {1,2,3}; protected double[] testVector2 = {1,2,3,4}; // submatrix accessor tests protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5}, {2, 4, 6, 8}, {4, 5, 6, 7}}; // array selections protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}}; protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}}; protected double[][] subRows03Cols123 = { {2, 3, 4} , {5, 6, 7}}; // effective permutations protected double[][] subRows20Cols123 = { {4, 6, 8} , {2, 3, 4}}; protected double[][] subRows31Cols31 = {{7, 5}, {4.5, 2.5}}; // contiguous ranges protected double[][] subRows01Cols23 = {{3,4} , {3.5, 4.5}}; protected double[][] subRows23Cols00 = {{2} , {4}}; protected double[][] subRows00Cols33 = {{4}}; // row matrices protected double[][] subRow0 = {{1,2,3,4}}; protected double[][] subRow3 = {{4,5,6,7}}; // column matrices protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}}; protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}}; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; public RealMatrixImplTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(RealMatrixImplTest.class); suite.setName("RealMatrixImpl Tests"); return suite; } /** test dimensions */ public void testDimensions() { RealMatrixImpl m = new RealMatrixImpl(testData); RealMatrixImpl m2 = new RealMatrixImpl(testData2); assertEquals("testData row dimension",3,m.getRowDimension()); assertEquals("testData column dimension",3,m.getColumnDimension()); assertTrue("testData is square",m.isSquare()); assertEquals("testData2 row dimension",m2.getRowDimension(),2); assertEquals("testData2 column dimension",m2.getColumnDimension(),3); assertTrue("testData2 is not square",!m2.isSquare()); } /** test copy functions */ public void testCopyFunctions() { RealMatrixImpl m1 = new RealMatrixImpl(testData); RealMatrixImpl m2 = new RealMatrixImpl(m1.getData()); assertEquals(m2,m1); RealMatrixImpl m3 = new RealMatrixImpl(testData); RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false); assertEquals(m4,m3); } /** test add */ public void testAdd() { RealMatrixImpl m = new RealMatrixImpl(testData); RealMatrixImpl mInv = new RealMatrixImpl(testDataInv); RealMatrix mPlusMInv = m.add(mInv); double[][] sumEntries = mPlusMInv.getData(); for (int row = 0; row < m.getRowDimension(); row++) { for (int col = 0; col < m.getColumnDimension(); col++) { assertEquals("sum entry entry", testDataPlusInv[row][col],sumEntries[row][col], entryTolerance); } } } /** test add failure */ public void testAddFail() { RealMatrixImpl m = new RealMatrixImpl(testData); RealMatrixImpl m2 = new RealMatrixImpl(testData2); try { m.add(m2); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { ; } } /** test norm */ public void testNorm() { RealMatrixImpl m = new RealMatrixImpl(testData); RealMatrixImpl m2 = new RealMatrixImpl(testData2); assertEquals("testData norm",14d,m.getNorm(),entryTolerance); assertEquals("testData2 norm",7d,m2.getNorm(),entryTolerance); } /** test m-n = m + -n */ public void testPlusMinus() { RealMatrixImpl m = new RealMatrixImpl(testData); RealMatrixImpl m2 = new RealMatrixImpl(testDataInv); assertClose("m-n = m + -n",m.subtract(m2), m2.scalarMultiply(-1d).add(m),entryTolerance); try { m.subtract(new RealMatrixImpl(testData2)); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } /** test multiply */ public void testMultiply() { RealMatrixImpl m = new RealMatrixImpl(testData); RealMatrixImpl mInv = new RealMatrixImpl(testDataInv); RealMatrixImpl identity = new RealMatrixImpl(id); RealMatrixImpl m2 = new RealMatrixImpl(testData2); assertClose("inverse multiply",m.multiply(mInv), identity,entryTolerance); assertClose("inverse multiply",mInv.multiply(m), identity,entryTolerance); assertClose("identity multiply",m.multiply(identity), m,entryTolerance); assertClose("identity multiply",identity.multiply(mInv), mInv,entryTolerance); assertClose("identity multiply",m2.multiply(identity), m2,entryTolerance); try { m.multiply(new RealMatrixImpl(bigSingular)); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } //Additional Test for RealMatrixImplTest.testMultiply private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}}; private double[][] d4 = new double[][] {{1},{2},{3},{4}}; private double[][] d5 = new double[][] {{30},{70}}; public void testMultiply2() { RealMatrix m3 = new RealMatrixImpl(d3); RealMatrix m4 = new RealMatrixImpl(d4); RealMatrix m5 = new RealMatrixImpl(d5); assertClose("m3*m4=m5", m3.multiply(m4), m5, entryTolerance); } /** test trace */ public void testTrace() { RealMatrix m = new RealMatrixImpl(id); assertEquals("identity trace",3d,m.getTrace(),entryTolerance); m = new RealMatrixImpl(testData2); try { m.getTrace(); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } /** test sclarAdd */ public void testScalarAdd() { RealMatrix m = new RealMatrixImpl(testData); assertClose("scalar add",new RealMatrixImpl(testDataPlus2), m.scalarAdd(2d),entryTolerance); } /** test operate */ public void testOperate() { RealMatrix m = new RealMatrixImpl(id); assertClose("identity operate", testVector, m.operate(testVector), entryTolerance); assertClose("identity operate", testVector, m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance); m = new RealMatrixImpl(bigSingular); try { m.operate(testVector); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } /** test issue MATH-209 */ public void testMath209() { RealMatrix a = new RealMatrixImpl(new double[][] { { 1, 2 }, { 3, 4 }, { 5, 6 } }, false); double[] b = a.operate(new double[] { 1, 1 }); assertEquals(a.getRowDimension(), b.length); assertEquals( 3.0, b[0], 1.0e-12); assertEquals( 7.0, b[1], 1.0e-12); assertEquals(11.0, b[2], 1.0e-12); } /** test transpose */ public void testTranspose() { RealMatrix m = new RealMatrixImpl(testData); RealMatrix mIT = new LUDecompositionImpl(m).getInverse().transpose(); RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getInverse(); assertClose("inverse-transpose", mIT, mTI, normTolerance); m = new RealMatrixImpl(testData2); RealMatrix mt = new RealMatrixImpl(testData2T); assertClose("transpose",mt,m.transpose(),normTolerance); } /** test preMultiply by vector */ public void testPremultiplyVector() { RealMatrix m = new RealMatrixImpl(testData); assertClose("premultiply", m.preMultiply(testVector), preMultTest, normTolerance); assertClose("premultiply", m.preMultiply(new RealVectorImpl(testVector).getData()), preMultTest, normTolerance); m = new RealMatrixImpl(bigSingular); try { m.preMultiply(testVector); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } public void testPremultiply() { RealMatrix m3 = new RealMatrixImpl(d3); RealMatrix m4 = new RealMatrixImpl(d4); RealMatrix m5 = new RealMatrixImpl(d5); assertClose("m3*m4=m5", m4.preMultiply(m3), m5, entryTolerance); RealMatrixImpl m = new RealMatrixImpl(testData); RealMatrixImpl mInv = new RealMatrixImpl(testDataInv); RealMatrixImpl identity = new RealMatrixImpl(id); assertClose("inverse multiply",m.preMultiply(mInv), identity,entryTolerance); assertClose("inverse multiply",mInv.preMultiply(m), identity,entryTolerance); assertClose("identity multiply",m.preMultiply(identity), m,entryTolerance); assertClose("identity multiply",identity.preMultiply(mInv), mInv,entryTolerance); try { m.preMultiply(new RealMatrixImpl(bigSingular)); fail("Expecting illegalArgumentException"); } catch (IllegalArgumentException ex) { ; } } public void testGetVectors() { RealMatrix m = new RealMatrixImpl(testData); assertClose("get row",m.getRow(0),testDataRow1,entryTolerance); assertClose("get col",m.getColumn(2),testDataCol3,entryTolerance); try { m.getRow(10); fail("expecting MatrixIndexException"); } catch (MatrixIndexException ex) { ; } try { m.getColumn(-1); fail("expecting MatrixIndexException"); } catch (MatrixIndexException ex) { ; } } public void testGetEntry() { RealMatrix m = new RealMatrixImpl(testData); assertEquals("get entry",m.getEntry(0,1),2d,entryTolerance); try { m.getEntry(10, 4); fail ("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } /** test examples in user guide */ public void testExamples() { // Create a real matrix with two rows and three columns double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}}; RealMatrix m = new RealMatrixImpl(matrixData); // One more with three rows, two columns double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}}; RealMatrix n = new RealMatrixImpl(matrixData2); // Now multiply m by n RealMatrix p = m.multiply(n); assertEquals(2, p.getRowDimension()); assertEquals(2, p.getColumnDimension()); // Invert p RealMatrix pInverse = new LUDecompositionImpl(p).getInverse(); assertEquals(2, pInverse.getRowDimension()); assertEquals(2, pInverse.getColumnDimension()); // Solve example double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}}; RealMatrix coefficients = new RealMatrixImpl(coefficientsData); double[] constants = {1, -2, 1}; double[] solution = new LUDecompositionImpl(coefficients).solve(constants); assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12); assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12); assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12); } // test submatrix accessors public void testSubMatrix() { RealMatrix m = new RealMatrixImpl(subTestData); RealMatrix mRows23Cols00 = new RealMatrixImpl(subRows23Cols00); RealMatrix mRows00Cols33 = new RealMatrixImpl(subRows00Cols33); RealMatrix mRows01Cols23 = new RealMatrixImpl(subRows01Cols23); RealMatrix mRows02Cols13 = new RealMatrixImpl(subRows02Cols13); RealMatrix mRows03Cols12 = new RealMatrixImpl(subRows03Cols12); RealMatrix mRows03Cols123 = new RealMatrixImpl(subRows03Cols123); RealMatrix mRows20Cols123 = new RealMatrixImpl(subRows20Cols123); RealMatrix mRows31Cols31 = new RealMatrixImpl(subRows31Cols31); assertEquals("Rows23Cols00", mRows23Cols00, m.getSubMatrix(2 , 3 , 0, 0)); assertEquals("Rows00Cols33", mRows00Cols33, m.getSubMatrix(0 , 0 , 3, 3)); assertEquals("Rows01Cols23", mRows01Cols23, m.getSubMatrix(0 , 1 , 2, 3)); assertEquals("Rows02Cols13", mRows02Cols13, m.getSubMatrix(new int[] {0,2}, new int[] {1,3})); assertEquals("Rows03Cols12", mRows03Cols12, m.getSubMatrix(new int[] {0,3}, new int[] {1,2})); assertEquals("Rows03Cols123", mRows03Cols123, m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3})); assertEquals("Rows20Cols123", mRows20Cols123, m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3})); assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); assertEquals("Rows31Cols31", mRows31Cols31, m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); try { m.getSubMatrix(1,0,2,4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(-1,1,2,2); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(1,0,2,2); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(1,0,2,4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(new int[] {}, new int[] {0}); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getSubMatrix(new int[] {0}, new int[] {4}); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } public void testGetRowMatrix() { RealMatrix m = new RealMatrixImpl(subTestData); RealMatrix mRow0 = new RealMatrixImpl(subRow0); RealMatrix mRow3 = new RealMatrixImpl(subRow3); assertEquals("Row0", mRow0, m.getRowMatrix(0)); assertEquals("Row3", mRow3, m.getRowMatrix(3)); try { m.getRowMatrix(-1); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getRowMatrix(4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } public void testGetColumnMatrix() { RealMatrix m = new RealMatrixImpl(subTestData); RealMatrix mColumn1 = new RealMatrixImpl(subColumn1); RealMatrix mColumn3 = new RealMatrixImpl(subColumn3); assertEquals("Column1", mColumn1, m.getColumnMatrix(1)); assertEquals("Column3", mColumn3, m.getColumnMatrix(3)); try { m.getColumnMatrix(-1); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getColumnMatrix(4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } public void testGetRowVector() { RealMatrix m = new RealMatrixImpl(subTestData); RealVector mRow0 = new RealVectorImpl(subRow0[0]); RealVector mRow3 = new RealVectorImpl(subRow3[0]); assertEquals("Row0", mRow0, m.getRowVector(0)); assertEquals("Row3", mRow3, m.getRowVector(3)); try { m.getRowVector(-1); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getRowVector(4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } public void testGetColumnVector() { RealMatrix m = new RealMatrixImpl(subTestData); RealVector mColumn1 = columnToVector(subColumn1); RealVector mColumn3 = columnToVector(subColumn3); assertEquals("Column1", mColumn1, m.getColumnVector(1)); assertEquals("Column3", mColumn3, m.getColumnVector(3)); try { m.getColumnVector(-1); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } try { m.getColumnVector(4); fail("Expecting MatrixIndexException"); } catch (MatrixIndexException ex) { // expected } } private RealVector columnToVector(double[][] column) { double[] data = new double[column.length]; for (int i = 0; i < data.length; ++i) { data[i] = column[i][0]; } return new RealVectorImpl(data, false); } public void testEqualsAndHashCode() { RealMatrixImpl m = new RealMatrixImpl(testData); RealMatrixImpl m1 = (RealMatrixImpl) m.copy(); RealMatrixImpl mt = (RealMatrixImpl) m.transpose(); assertTrue(m.hashCode() != mt.hashCode()); assertEquals(m.hashCode(), m1.hashCode()); assertEquals(m, m); assertEquals(m, m1); assertFalse(m.equals(null)); assertFalse(m.equals(mt)); assertFalse(m.equals(new RealMatrixImpl(bigSingular))); } public void testToString() { RealMatrixImpl m = new RealMatrixImpl(testData); assertEquals("RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}", m.toString()); m = new RealMatrixImpl(); assertEquals("RealMatrixImpl{}", m.toString()); } public void testSetSubMatrix() throws Exception { RealMatrixImpl m = new RealMatrixImpl(testData); m.setSubMatrix(detData2,1,1); RealMatrix expected = MatrixUtils.createRealMatrix (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}}); assertEquals(expected, m); m.setSubMatrix(detData2,0,0); expected = MatrixUtils.createRealMatrix (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}}); assertEquals(expected, m); m.setSubMatrix(testDataPlus2,0,0); expected = MatrixUtils.createRealMatrix (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}}); assertEquals(expected, m); // javadoc example RealMatrixImpl matrix = (RealMatrixImpl) MatrixUtils.createRealMatrix (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}}); matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1); expected = MatrixUtils.createRealMatrix (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}}); assertEquals(expected, matrix); // dimension overflow try { m.setSubMatrix(testData,1,1); fail("expecting MatrixIndexException"); } catch (MatrixIndexException e) { // expected } // dimension underflow try { m.setSubMatrix(testData,-1,1); fail("expecting MatrixIndexException"); } catch (MatrixIndexException e) { // expected } try { m.setSubMatrix(testData,1,-1); fail("expecting MatrixIndexException"); } catch (MatrixIndexException e) { // expected } // null try { m.setSubMatrix(null,1,1); fail("expecting NullPointerException"); } catch (NullPointerException e) { // expected } RealMatrixImpl m2 = new RealMatrixImpl(); try { m2.setSubMatrix(testData,0,1); fail("expecting IllegalStateException"); } catch (IllegalStateException e) { // expected } try { m2.setSubMatrix(testData,1,0); fail("expecting IllegalStateException"); } catch (IllegalStateException e) { // expected } // ragged try { m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException e) { // expected } // empty try { m.setSubMatrix(new double[][] {{}}, 0, 0); fail("expecting IllegalArgumentException"); } catch (IllegalArgumentException e) { // expected } } //--------------- -----------------Protected methods /** verifies that two matrices are close (1-norm) */ protected void assertClose(String msg, RealMatrix m, RealMatrix n, double tolerance) { assertTrue(msg,m.subtract(n).getNorm() < tolerance); } /** verifies that two vectors are close (sup norm) */ protected void assertClose(String msg, double[] m, double[] n, double tolerance) { if (m.length != n.length) { fail("vectors not same length"); } for (int i = 0; i < m.length; i++) { assertEquals(msg + " " + i + " elements differ", m[i],n[i],tolerance); } } /** extracts the l and u matrices from compact lu representation */ protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException { if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length || lowerData.length != upperData.length || lowerData.length != lu.getRowDimension()) { throw new InvalidMatrixException("incorrect dimensions", null); } int n = lu.getRowDimension(); for (int i = 0; i < n; i++) { for (int j = 0; j < n; j++) { if (j < i) { lowerData[i][j] = lu.getEntry(i, j); upperData[i][j] = 0d; } else if (i == j) { lowerData[i][j] = 1d; upperData[i][j] = lu.getEntry(i, j); } else { lowerData[i][j] = 0d; upperData[i][j] = lu.getEntry(i, j); } } } } /** Returns the result of applying the given row permutation to the matrix */ protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) { if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) { throw new IllegalArgumentException("dimension mismatch"); } int n = matrix.getRowDimension(); int m = matrix.getColumnDimension(); double out[][] = new double[m][n]; for (int i = 0; i < n; i++) { for (int j = 0; j < m; j++) { out[i][j] = matrix.getEntry(permutation[i], j); } } return new RealMatrixImpl(out); } // /** Useful for debugging */ // private void dumpMatrix(RealMatrix m) { // for (int i = 0; i < m.getRowDimension(); i++) { // String os = ""; // for (int j = 0; j < m.getColumnDimension(); j++) { // os += m.getEntry(i, j) + " "; // } // System.out.println(os); // } // } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class LUDecompositionImplTest extends TestCase { private double[][] testData = { { 1.0, 2.0, 3.0}, { 2.0, 5.0, 3.0}, { 1.0, 0.0, 8.0} }; private double[][] testDataMinus = { { -1.0, -2.0, -3.0}, { -2.0, -5.0, -3.0}, { -1.0, 0.0, -8.0} }; private double[][] luData = { { 2.0, 3.0, 3.0 }, { 0.0, 5.0, 7.0 }, { 6.0, 9.0, 8.0 } }; // singular matrices private double[][] singular = { { 2.0, 3.0 }, { 2.0, 3.0 } }; private double[][] bigSingular = { { 1.0, 2.0, 3.0, 4.0 }, { 2.0, 5.0, 3.0, 4.0 }, { 7.0, 3.0, 256.0, 1930.0 }, { 3.0, 7.0, 6.0, 8.0 } }; // 4th row = 1st + 2nd private static final double entryTolerance = 10e-16; private static final double normTolerance = 10e-14; public LUDecompositionImplTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(LUDecompositionImplTest.class); suite.setName("LUDecompositionImpl Tests"); return suite; } /** test dimensions */ public void testDimensions() { RealMatrixImpl matrix = new RealMatrixImpl(testData, false); LUDecomposition LU = new LUDecompositionImpl(matrix); assertEquals(testData.length, LU.getL().getRowDimension()); assertEquals(testData.length, LU.getL().getColumnDimension()); assertEquals(testData.length, LU.getU().getRowDimension()); assertEquals(testData.length, LU.getU().getColumnDimension()); assertEquals(testData.length, LU.getP().getRowDimension()); assertEquals(testData.length, LU.getP().getColumnDimension()); } /** test non-square matrix */ public void testNonSquare() { try { new LUDecompositionImpl(new RealMatrixImpl(new double[3][2], false)); } catch (InvalidMatrixException ime) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** test no call to decompose */ public void testNoDecompose() { try { new LUDecompositionImpl().getPivot(); fail("an exception should have been caught"); } catch (IllegalStateException ise) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** test threshold impact */ public void testThreshold() { final RealMatrix matrix = new RealMatrixImpl(new double[][] { { 1.0, 2.0, 3.0}, { 2.0, 5.0, 3.0}, { 4.000001, 9.0, 9.0} }, false); assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).isNonSingular()); assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).isNonSingular()); } /** test PA = LU */ public void testPAEqualLU() { RealMatrix matrix = new RealMatrixImpl(testData, false); LUDecomposition lu = new LUDecompositionImpl(matrix); RealMatrix l = lu.getL(); RealMatrix u = lu.getU(); RealMatrix p = lu.getP(); double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm(); assertEquals(0, norm, normTolerance); matrix = new RealMatrixImpl(testDataMinus, false); lu = new LUDecompositionImpl(matrix); l = lu.getL(); u = lu.getU(); p = lu.getP(); norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm(); assertEquals(0, norm, normTolerance); matrix = MatrixUtils.createRealIdentityMatrix(17); lu = new LUDecompositionImpl(matrix); l = lu.getL(); u = lu.getU(); p = lu.getP(); norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm(); assertEquals(0, norm, normTolerance); matrix = new RealMatrixImpl(singular, false); lu = new LUDecompositionImpl(matrix); assertFalse(lu.isNonSingular()); assertNull(lu.getL()); assertNull(lu.getU()); assertNull(lu.getP()); matrix = new RealMatrixImpl(bigSingular, false); lu = new LUDecompositionImpl(matrix); assertFalse(lu.isNonSingular()); assertNull(lu.getL()); assertNull(lu.getU()); assertNull(lu.getP()); } /** test that L is lower triangular with unit diagonal */ public void testLLowerTriangular() { RealMatrixImpl matrix = new RealMatrixImpl(testData, false); RealMatrix l = new LUDecompositionImpl(matrix).getL(); for (int i = 0; i < l.getRowDimension(); i++) { assertEquals(l.getEntry(i, i), 1, entryTolerance); for (int j = i + 1; j < l.getColumnDimension(); j++) { assertEquals(l.getEntry(i, j), 0, entryTolerance); } } } /** test that U is upper triangular */ public void testUUpperTriangular() { RealMatrixImpl matrix = new RealMatrixImpl(testData, false); RealMatrix u = new LUDecompositionImpl(matrix).getU(); for (int i = 0; i < u.getRowDimension(); i++) { for (int j = 0; j < i; j++) { assertEquals(u.getEntry(i, j), 0, entryTolerance); } } } /** test that P is a permutation matrix */ public void testPPermutation() { RealMatrixImpl matrix = new RealMatrixImpl(testData, false); RealMatrix p = new LUDecompositionImpl(matrix).getP(); RealMatrix ppT = p.multiply(p.transpose()); RealMatrix id = MatrixUtils.createRealIdentityMatrix(p.getRowDimension()); assertEquals(0, ppT.subtract(id).getNorm(), normTolerance); for (int i = 0; i < p.getRowDimension(); i++) { int zeroCount = 0; int oneCount = 0; int otherCount = 0; for (int j = 0; j < p.getColumnDimension(); j++) { final double e = p.getEntry(i, j); if (e == 0) { ++zeroCount; } else if (e == 1) { ++oneCount; } else { ++otherCount; } } assertEquals(p.getColumnDimension() - 1, zeroCount); assertEquals(1, oneCount); assertEquals(0, otherCount); } for (int j = 0; j < p.getColumnDimension(); j++) { int zeroCount = 0; int oneCount = 0; int otherCount = 0; for (int i = 0; i < p.getRowDimension(); i++) { final double e = p.getEntry(i, j); if (e == 0) { ++zeroCount; } else if (e == 1) { ++oneCount; } else { ++otherCount; } } assertEquals(p.getRowDimension() - 1, zeroCount); assertEquals(1, oneCount); assertEquals(0, otherCount); } } /** test singular */ public void testSingular() { LUDecomposition lu = new LUDecompositionImpl(new RealMatrixImpl(testData, false)); assertTrue(lu.isNonSingular()); lu = new LUDecompositionImpl(new RealMatrixImpl(singular, false)); assertFalse(lu.isNonSingular()); lu = new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false)); assertFalse(lu.isNonSingular()); } /** test solve dimension errors */ public void testSolveDimensionErrors() { LUDecomposition lu = new LUDecompositionImpl(new RealMatrixImpl(testData, false)); RealMatrix b = new RealMatrixImpl(new double[2][2]); try { lu.solve(b); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { lu.solve(b.getColumn(0)); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0))); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** test solve singularity errors */ public void testSolveSingularityErrors() { LUDecomposition lu = new LUDecompositionImpl(new RealMatrixImpl(singular, false)); RealMatrix b = new RealMatrixImpl(new double[2][2]); try { lu.solve(b); fail("an exception should have been thrown"); } catch (InvalidMatrixException ime) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { lu.solve(b.getColumn(0)); fail("an exception should have been thrown"); } catch (InvalidMatrixException ime) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { lu.solve(b.getColumnVector(0)); fail("an exception should have been thrown"); } catch (InvalidMatrixException ime) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0))); fail("an exception should have been thrown"); } catch (InvalidMatrixException ime) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** test solve */ public void testSolve() { LUDecomposition lu = new LUDecompositionImpl(new RealMatrixImpl(testData, false)); RealMatrix b = new RealMatrixImpl(new double[][] { { 1, 0 }, { 2, -5 }, { 3, 1 } }); RealMatrix xRef = new RealMatrixImpl(new double[][] { { 19, -71 }, { -6, 22 }, { -2, 9 } }); // using RealMatrix assertEquals(0, lu.solve(b).subtract(xRef).getNorm(), 1.0e-13); // using double[] for (int i = 0; i < b.getColumnDimension(); ++i) { assertEquals(0, new RealVectorImpl(lu.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } // using RealVectorImpl for (int i = 0; i < b.getColumnDimension(); ++i) { assertEquals(0, lu.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } // using RealVector with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { RealVectorImplTest.RealVectorTestImpl v = new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i)); assertEquals(0, lu.solve(v).subtract(xRef.getColumnVector(i)).getNorm(), 1.0e-13); } } /** test matrices values */ public void testMatricesValues1() { LUDecomposition lu = new LUDecompositionImpl(new RealMatrixImpl(testData, false)); RealMatrix lRef = new RealMatrixImpl(new double[][] { { 1.0, 0.0, 0.0 }, { 0.5, 1.0, 0.0 }, { 0.5, 0.2, 1.0 } }); RealMatrix uRef = new RealMatrixImpl(new double[][] { { 2.0, 5.0, 3.0 }, { 0.0, -2.5, 6.5 }, { 0.0, 0.0, 0.2 } }); RealMatrix pRef = new RealMatrixImpl(new double[][] { { 0.0, 1.0, 0.0 }, { 0.0, 0.0, 1.0 }, { 1.0, 0.0, 0.0 } }); int[] pivotRef = { 1, 2, 0 }; // check values against known references RealMatrix l = lu.getL(); assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13); RealMatrix u = lu.getU(); assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13); RealMatrix p = lu.getP(); assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13); int[] pivot = lu.getPivot(); for (int i = 0; i < pivotRef.length; ++i) { assertEquals(pivotRef[i], pivot[i]); } // check the same cached instance is returned the second time assertTrue(l == lu.getL()); assertTrue(u == lu.getU()); assertTrue(p == lu.getP()); } /** test matrices values */ public void testMatricesValues2() { LUDecomposition lu = new LUDecompositionImpl(new RealMatrixImpl(luData, false)); RealMatrix lRef = new RealMatrixImpl(new double[][] { { 1.0, 0.0, 0.0 }, { 0.0, 1.0, 0.0 }, { 1.0 / 3.0, 0.0, 1.0 } }); RealMatrix uRef = new RealMatrixImpl(new double[][] { { 6.0, 9.0, 8.0 }, { 0.0, 5.0, 7.0 }, { 0.0, 0.0, 1.0 / 3.0 } }); RealMatrix pRef = new RealMatrixImpl(new double[][] { { 0.0, 0.0, 1.0 }, { 0.0, 1.0, 0.0 }, { 1.0, 0.0, 0.0 } }); int[] pivotRef = { 2, 1, 0 }; // check values against known references RealMatrix l = lu.getL(); assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13); RealMatrix u = lu.getU(); assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13); RealMatrix p = lu.getP(); assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13); int[] pivot = lu.getPivot(); for (int i = 0; i < pivotRef.length; ++i) { assertEquals(pivotRef[i], pivot[i]); } // check the same cached instance is returned the second time assertTrue(l == lu.getL()); assertTrue(u == lu.getU()); assertTrue(p == lu.getP()); } /** test determinant */ public void testDeterminant() { assertEquals(-1, new LUDecompositionImpl(new RealMatrixImpl(testData, false)).getDeterminant(), 1.0e-15); assertEquals(-10, new LUDecompositionImpl(new RealMatrixImpl(luData, false)).getDeterminant(), 1.0e-14); assertEquals(0, new LUDecompositionImpl(new RealMatrixImpl(singular, false)).getDeterminant(), 1.0e-17); assertEquals(0, new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false)).getDeterminant(), 1.0e-17); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import java.math.BigDecimal; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test cases for the {@link MatrixUtils} class. * * @version $Revision$ $Date$ */ public final class MatrixUtilsTest extends TestCase { protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} }; protected double[][] nullMatrix = null; protected double[] row = {1,2,3}; protected BigDecimal[] bigRow = {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)}; protected String[] stringRow = {"1", "2", "3"}; protected double[][] rowMatrix = {{1,2,3}}; protected BigDecimal[][] bigRowMatrix = {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}}; protected String[][] stringRowMatrix = {{"1", "2", "3"}}; protected double[] col = {0,4,6}; protected BigDecimal[] bigCol = {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)}; protected String[] stringCol = {"0","4","6"}; protected double[] nullDoubleArray = null; protected double[][] colMatrix = {{0},{4},{6}}; protected BigDecimal[][] bigColMatrix = {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}}; protected String[][] stringColMatrix = {{"0"}, {"4"}, {"6"}}; public MatrixUtilsTest(String name) { super(name); } public void setUp() { } public static Test suite() { TestSuite suite = new TestSuite(MatrixUtilsTest.class); suite.setName("MatrixUtils Tests"); return suite; } public void testCreateRealMatrix() { assertEquals(new RealMatrixImpl(testData), MatrixUtils.createRealMatrix(testData)); assertEquals(new RealMatrixImpl(testData, false), MatrixUtils.createRealMatrix(testData, true)); assertEquals(new RealMatrixImpl(testData, true), MatrixUtils.createRealMatrix(testData, false)); try { MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}}); // ragged fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { MatrixUtils.createRealMatrix(new double[][] {{}, {}}); // no columns fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { MatrixUtils.createRealMatrix(null); // null fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // expected } } public void testCreateBigMatrix() { assertEquals(new BigMatrixImpl(testData), MatrixUtils.createBigMatrix(testData)); assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true), MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false)); assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false), MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true)); assertEquals(new BigMatrixImpl(bigColMatrix), MatrixUtils.createBigMatrix(bigColMatrix)); assertEquals(new BigMatrixImpl(stringColMatrix), MatrixUtils.createBigMatrix(stringColMatrix)); try { MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}}); // ragged fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { MatrixUtils.createBigMatrix(new double[][] {{}, {}}); // no columns fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { MatrixUtils.createBigMatrix(nullMatrix); // null fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // expected } } public void testCreateRowRealMatrix() { assertEquals((RealMatrixImpl) MatrixUtils.createRowRealMatrix(row), new RealMatrixImpl(rowMatrix)); try { MatrixUtils.createRowRealMatrix(new double[] {}); // empty fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { MatrixUtils.createRowRealMatrix(null); // null fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // expected } } public void testCreateRowBigMatrix() { assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(row), new BigMatrixImpl(rowMatrix)); assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(bigRow), new BigMatrixImpl(bigRowMatrix)); assertEquals((BigMatrixImpl) MatrixUtils.createRowBigMatrix(stringRow), new BigMatrixImpl(stringRowMatrix)); try { MatrixUtils.createRowBigMatrix(new double[] {}); // empty fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { MatrixUtils.createRowBigMatrix(nullDoubleArray); // null fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // expected } } public void testCreateColumnRealMatrix() { assertEquals((RealMatrixImpl) MatrixUtils.createColumnRealMatrix(col), new RealMatrixImpl(colMatrix)); try { MatrixUtils.createColumnRealMatrix(new double[] {}); // empty fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { MatrixUtils.createColumnRealMatrix(null); // null fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // expected } } public void testCreateColumnBigMatrix() { assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(col), new BigMatrixImpl(colMatrix)); assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(bigCol), new BigMatrixImpl(bigColMatrix)); assertEquals((BigMatrixImpl) MatrixUtils.createColumnBigMatrix(stringCol), new BigMatrixImpl(stringColMatrix)); try { MatrixUtils.createColumnBigMatrix(new double[] {}); // empty fail("Expecting IllegalArgumentException"); } catch (IllegalArgumentException ex) { // expected } try { MatrixUtils.createColumnBigMatrix(nullDoubleArray); // null fail("Expecting NullPointerException"); } catch (NullPointerException ex) { // expected } } /** * Verifies that the matrix is an identity matrix */ protected void checkIdentityMatrix(RealMatrix m) { for (int i = 0; i < m.getRowDimension(); i++) { for (int j =0; j < m.getColumnDimension(); j++) { if (i == j) { assertEquals(m.getEntry(i, j), 1d, 0); } else { assertEquals(m.getEntry(i, j), 0d, 0); } } } } public void testCreateIdentityMatrix() { checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3)); checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2)); checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(1)); try { MatrixUtils.createRealIdentityMatrix(0); } catch (IllegalArgumentException ex) { // expected } } /** * Verifies that the matrix is an identity matrix */ protected void checkIdentityBigMatrix(BigMatrix m) { for (int i = 0; i < m.getRowDimension(); i++) { for (int j =0; j < m.getColumnDimension(); j++) { if (i == j) { assertEquals(m.getEntry(i, j), BigMatrixImpl.ONE); } else { assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO); } } } } public void testCreateBigIdentityMatrix() { checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(3)); checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(2)); checkIdentityBigMatrix(MatrixUtils.createBigIdentityMatrix(1)); try { MatrixUtils.createRealIdentityMatrix(0); } catch (IllegalArgumentException ex) { // expected } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import java.io.Serializable; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; /** * Test cases for the {@link RealVectorImpl} class. * * @version $Revision$ $Date$ */ public class RealVectorImplTest extends TestCase { // protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}}; protected double[] vec1 = {1d, 2d, 3d}; protected double[] vec2 = {4d, 5d, 6d}; protected double[] vec3 = {7d, 8d, 9d}; protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d}; protected double[] vec_null = {0d, 0d, 0d}; protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d}; protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}}; // tolerances protected double entryTolerance = 10E-16; protected double normTolerance = 10E-14; // Testclass to test the RealVector interface // only with enough content to support the test public static class RealVectorTestImpl implements RealVector, Serializable { /** Serializable version identifier. */ private static final long serialVersionUID = 4715341047369582908L; /** Entries of the vector. */ protected double data[]; public RealVectorTestImpl(double[] d) { data = d.clone(); } private UnsupportedOperationException unsupported() { return new UnsupportedOperationException("Not supported, unneeded for test purposes"); } public RealVector copy() { throw unsupported(); } public RealVector add(RealVector v) throws IllegalArgumentException { throw unsupported(); } public RealVector add(double[] v) throws IllegalArgumentException { throw unsupported(); } public RealVector subtract(RealVector v) throws IllegalArgumentException { throw unsupported(); } public RealVector subtract(double[] v) throws IllegalArgumentException { throw unsupported(); } public RealVector mapAdd(double d) { throw unsupported(); } public RealVector mapAddToSelf(double d) { throw unsupported(); } public RealVector mapSubtract(double d) { throw unsupported(); } public RealVector mapSubtractToSelf(double d) { throw unsupported(); } public RealVector mapMultiply(double d) { double[] out = new double[data.length]; for (int i = 0; i < data.length; i++) { out[i] = data[i] * d; } return new RealVectorImpl(out); } public RealVector mapMultiplyToSelf(double d) { throw unsupported(); } public RealVector mapDivide(double d) { throw unsupported(); } public RealVector mapDivideToSelf(double d) { throw unsupported(); } public RealVector mapPow(double d) { throw unsupported(); } public RealVector mapPowToSelf(double d) { throw unsupported(); } public RealVector mapExp() { throw unsupported(); } public RealVector mapExpToSelf() { throw unsupported(); } public RealVector mapExpm1() { throw unsupported(); } public RealVector mapExpm1ToSelf() { throw unsupported(); } public RealVector mapLog() { throw unsupported(); } public RealVector mapLogToSelf() { throw unsupported(); } public RealVector mapLog10() { throw unsupported(); } public RealVector mapLog10ToSelf() { throw unsupported(); } public RealVector mapLog1p() { throw unsupported(); } public RealVector mapLog1pToSelf() { throw unsupported(); } public RealVector mapCosh() { throw unsupported(); } public RealVector mapCoshToSelf() { throw unsupported(); } public RealVector mapSinh() { throw unsupported(); } public RealVector mapSinhToSelf() { throw unsupported(); } public RealVector mapTanh() { throw unsupported(); } public RealVector mapTanhToSelf() { throw unsupported(); } public RealVector mapCos() { throw unsupported(); } public RealVector mapCosToSelf() { throw unsupported(); } public RealVector mapSin() { throw unsupported(); } public RealVector mapSinToSelf() { throw unsupported(); } public RealVector mapTan() { throw unsupported(); } public RealVector mapTanToSelf() { throw unsupported(); } public RealVector mapAcos() { throw unsupported(); } public RealVector mapAcosToSelf() { throw unsupported(); } public RealVector mapAsin() { throw unsupported(); } public RealVector mapAsinToSelf() { throw unsupported(); } public RealVector mapAtan() { throw unsupported(); } public RealVector mapAtanToSelf() { throw unsupported(); } public RealVector mapInv() { throw unsupported(); } public RealVector mapInvToSelf() { throw unsupported(); } public RealVector mapAbs() { throw unsupported(); } public RealVector mapAbsToSelf() { throw unsupported(); } public RealVector mapSqrt() { throw unsupported(); } public RealVector mapSqrtToSelf() { throw unsupported(); } public RealVector mapCbrt() { throw unsupported(); } public RealVector mapCbrtToSelf() { throw unsupported(); } public RealVector mapCeil() { throw unsupported(); } public RealVector mapCeilToSelf() { throw unsupported(); } public RealVector mapFloor() { throw unsupported(); } public RealVector mapFloorToSelf() { throw unsupported(); } public RealVector mapRint() { throw unsupported(); } public RealVector mapRintToSelf() { throw unsupported(); } public RealVector mapSignum() { throw unsupported(); } public RealVector mapSignumToSelf() { throw unsupported(); } public RealVector mapUlp() { throw unsupported(); } public RealVector mapUlpToSelf() { throw unsupported(); } public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException { throw unsupported(); } public RealVector ebeMultiply(double[] v) throws IllegalArgumentException { throw unsupported(); } public RealVector ebeDivide(RealVector v) throws IllegalArgumentException { throw unsupported(); } public RealVector ebeDivide(double[] v) throws IllegalArgumentException { throw unsupported(); } public double[] getData() { return data.clone(); } public double dotProduct(RealVector v) throws IllegalArgumentException { double dot = 0; for (int i = 0; i < data.length; i++) { dot += data[i] * v.getEntry(i); } return dot; } public double dotProduct(double[] v) throws IllegalArgumentException { double dot = 0; for (int i = 0; i < data.length; i++) { dot += data[i] * v[i]; } return dot; } public double getNorm() { throw unsupported(); } public double getL1Norm() { throw unsupported(); } public double getLInfNorm() { throw unsupported(); } public double getDistance(RealVector v) throws IllegalArgumentException { throw unsupported(); } public double getDistance(double[] v) throws IllegalArgumentException { throw unsupported(); } public double getL1Distance(RealVector v) throws IllegalArgumentException { throw unsupported(); } public double getL1Distance(double[] v) throws IllegalArgumentException { throw unsupported(); } public double getLInfDistance(RealVector v) throws IllegalArgumentException { throw unsupported(); } public double getLInfDistance(double[] v) throws IllegalArgumentException { throw unsupported(); } public RealVector unitVector() { throw unsupported(); } public void unitize() { throw unsupported(); } public RealVector projection(RealVector v) throws IllegalArgumentException { throw unsupported(); } public RealVector projection(double[] v) throws IllegalArgumentException { throw unsupported(); } public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException { throw unsupported(); } public RealMatrix outerProduct(double[] v) throws IllegalArgumentException { throw unsupported(); } public double getEntry(int index) throws MatrixIndexException { return data[index]; } public int getDimension() { return data.length; } public RealVector append(RealVector v) { throw unsupported(); } public RealVector append(double d) { throw unsupported(); } public RealVector append(double[] a) { throw unsupported(); } public RealVector get(int index, int n) throws MatrixIndexException { throw unsupported(); } public void set(int index, double value) throws MatrixIndexException { throw unsupported(); } public void set(int index, RealVector v) throws MatrixIndexException { throw unsupported(); } public void set(int index, double[] v) throws MatrixIndexException { throw unsupported(); } public void set(double value) { throw unsupported(); } public double[] toArray() { throw unsupported(); } public boolean isNaN() { throw unsupported(); } public boolean isInfinite() { throw unsupported(); } } public static Test suite() { TestSuite suite = new TestSuite(RealVectorImplTest.class); suite.setName("RealVectorImpl Tests"); return suite; } public void testConstructors() { RealVectorImpl v0 = new RealVectorImpl(); assertEquals("testData len", 0, v0.getDimension()); RealVectorImpl v1 = new RealVectorImpl(7); assertEquals("testData len", 7, v1.getDimension()); assertEquals("testData is 0.0 ", 0.0, v1.getEntry(6)); RealVectorImpl v2 = new RealVectorImpl(5, 1.23); assertEquals("testData len", 5, v2.getDimension()); assertEquals("testData is 1.23 ", 1.23, v2.getEntry(4)); RealVectorImpl v3 = new RealVectorImpl(vec1); assertEquals("testData len", 3, v3.getDimension()); assertEquals("testData is 2.0 ", 2.0, v3.getEntry(1)); RealVectorImpl v4 = new RealVectorImpl(vec4, 3, 2); assertEquals("testData len", 2, v4.getDimension()); assertEquals("testData is 4.0 ", 4.0, v4.getEntry(0)); try { new RealVectorImpl(vec4, 8, 3); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVector v5_i = new RealVectorImpl(dvec1); assertEquals("testData len", 9, v5_i.getDimension()); assertEquals("testData is 9.0 ", 9.0, v5_i.getEntry(8)); RealVectorImpl v5 = new RealVectorImpl(dvec1); assertEquals("testData len", 9, v5.getDimension()); assertEquals("testData is 9.0 ", 9.0, v5.getEntry(8)); RealVectorImpl v6 = new RealVectorImpl(dvec1, 3, 2); assertEquals("testData len", 2, v6.getDimension()); assertEquals("testData is 4.0 ", 4.0, v6.getEntry(0)); try { new RealVectorImpl(dvec1, 8, 3); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVectorImpl v7 = new RealVectorImpl(v1); assertEquals("testData len", 7, v7.getDimension()); assertEquals("testData is 0.0 ", 0.0, v7.getEntry(6)); RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1); RealVectorImpl v7_2 = new RealVectorImpl(v7_i); assertEquals("testData len", 3, v7_2.getDimension()); assertEquals("testData is 0.0 ", 2.0d, v7_2.getEntry(1)); RealVectorImpl v8 = new RealVectorImpl(v1, true); assertEquals("testData len", 7, v8.getDimension()); assertEquals("testData is 0.0 ", 0.0, v8.getEntry(6)); assertNotSame("testData not same object ", v1.data, v8.data); RealVectorImpl v8_2 = new RealVectorImpl(v1, false); assertEquals("testData len", 7, v8_2.getDimension()); assertEquals("testData is 0.0 ", 0.0, v8_2.getEntry(6)); assertEquals("testData same object ", v1.data, v8_2.data); RealVectorImpl v9 = new RealVectorImpl(v1, v3); assertEquals("testData len", 10, v9.getDimension()); assertEquals("testData is 1.0 ", 1.0, v9.getEntry(7)); } public void testDataInOut() { RealVectorImpl v1 = new RealVectorImpl(vec1); RealVectorImpl v2 = new RealVectorImpl(vec2); RealVectorImpl v4 = new RealVectorImpl(vec4); RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); RealVector v_append_1 = v1.append(v2); assertEquals("testData len", 6, v_append_1.getDimension()); assertEquals("testData is 4.0 ", 4.0, v_append_1.getEntry(3)); RealVector v_append_2 = v1.append(2.0); assertEquals("testData len", 4, v_append_2.getDimension()); assertEquals("testData is 2.0 ", 2.0, v_append_2.getEntry(3)); RealVector v_append_3 = v1.append(vec2); assertEquals("testData len", 6, v_append_3.getDimension()); assertEquals("testData is ", 4.0, v_append_3.getEntry(3)); RealVector v_append_4 = v1.append(v2_t); assertEquals("testData len", 6, v_append_4.getDimension()); assertEquals("testData is 4.0 ", 4.0, v_append_4.getEntry(3)); RealVector v_copy = v1.copy(); assertEquals("testData len", 3, v_copy.getDimension()); assertNotSame("testData not same object ", v1.data, v_copy.getData()); double[] a_double = v1.toArray(); assertEquals("testData len", 3, a_double.length); assertNotSame("testData not same object ", v1.data, a_double); // RealVectorImpl vout4 = (RealVectorImpl) v1.clone(); // assertEquals("testData len", 3, vout4.getDimension()); // assertEquals("testData not same object ", v1.data, vout4.data); RealVector vout5 = v4.get(3, 3); assertEquals("testData len", 3, vout5.getDimension()); assertEquals("testData is 4.0 ", 5.0, vout5.getEntry(1)); try { v4.get(3, 7); fail("MatrixIndexException expected"); } catch (MatrixIndexException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVectorImpl v_set1 = (RealVectorImpl) v1.copy(); v_set1.set(1, 11.0); assertEquals("testData is 11.0 ", 11.0, v_set1.getEntry(1)); try { v_set1.set(3, 11.0); fail("MatrixIndexException expected"); } catch (MatrixIndexException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVectorImpl v_set2 = (RealVectorImpl) v4.copy(); v_set2.set(3, v1); assertEquals("testData is 1.0 ", 1.0, v_set2.getEntry(3)); assertEquals("testData is 7.0 ", 7.0, v_set2.getEntry(6)); try { v_set2.set(7, v1); fail("MatrixIndexException expected"); } catch (MatrixIndexException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVectorImpl v_set3 = (RealVectorImpl) v1.copy(); v_set3.set(13.0); assertEquals("testData is 13.0 ", 13.0, v_set3.getEntry(2)); try { v_set3.getEntry(23); fail("ArrayIndexOutOfBoundsException expected"); } catch (ArrayIndexOutOfBoundsException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVectorImpl v_set4 = (RealVectorImpl) v4.copy(); v_set4.set(3, v2_t); assertEquals("testData is 1.0 ", 4.0, v_set4.getEntry(3)); assertEquals("testData is 7.0 ", 7.0, v_set4.getEntry(6)); try { v_set4.set(7, v2_t); fail("MatrixIndexException expected"); } catch (MatrixIndexException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVectorImpl vout10 = (RealVectorImpl) v1.copy(); RealVectorImpl vout10_2 = (RealVectorImpl) v1.copy(); assertEquals(vout10, vout10_2); vout10_2.set(0, 1.1); assertNotSame(vout10, vout10_2); } public void testMapFunctions() { RealVectorImpl v1 = new RealVectorImpl(vec1); //octave = v1 .+ 2.0 RealVector v_mapAdd = v1.mapAdd(2.0d); double[] result_mapAdd = {3d, 4d, 5d}; assertClose("compare vectors" ,result_mapAdd,v_mapAdd.getData(),normTolerance); //octave = v1 .+ 2.0 RealVector v_mapAddToSelf = v1.copy(); v_mapAddToSelf.mapAddToSelf(2.0d); double[] result_mapAddToSelf = {3d, 4d, 5d}; assertClose("compare vectors" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance); //octave = v1 .- 2.0 RealVector v_mapSubtract = v1.mapSubtract(2.0d); double[] result_mapSubtract = {-1d, 0d, 1d}; assertClose("compare vectors" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance); //octave = v1 .- 2.0 RealVector v_mapSubtractToSelf = v1.copy(); v_mapSubtractToSelf.mapSubtractToSelf(2.0d); double[] result_mapSubtractToSelf = {-1d, 0d, 1d}; assertClose("compare vectors" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance); //octave = v1 .* 2.0 RealVector v_mapMultiply = v1.mapMultiply(2.0d); double[] result_mapMultiply = {2d, 4d, 6d}; assertClose("compare vectors" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance); //octave = v1 .* 2.0 RealVector v_mapMultiplyToSelf = v1.copy(); v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d); double[] result_mapMultiplyToSelf = {2d, 4d, 6d}; assertClose("compare vectors" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance); //octave = v1 ./ 2.0 RealVector v_mapDivide = v1.mapDivide(2.0d); double[] result_mapDivide = {.5d, 1d, 1.5d}; assertClose("compare vectors" ,result_mapDivide,v_mapDivide.getData(),normTolerance); //octave = v1 ./ 2.0 RealVector v_mapDivideToSelf = v1.copy(); v_mapDivideToSelf.mapDivideToSelf(2.0d); double[] result_mapDivideToSelf = {.5d, 1d, 1.5d}; assertClose("compare vectors" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance); //octave = v1 .^ 2.0 RealVector v_mapPow = v1.mapPow(2.0d); double[] result_mapPow = {1d, 4d, 9d}; assertClose("compare vectors" ,result_mapPow,v_mapPow.getData(),normTolerance); //octave = v1 .^ 2.0 RealVector v_mapPowToSelf = v1.copy(); v_mapPowToSelf.mapPowToSelf(2.0d); double[] result_mapPowToSelf = {1d, 4d, 9d}; assertClose("compare vectors" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance); //octave = exp(v1) RealVector v_mapExp = v1.mapExp(); double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d}; assertClose("compare vectors" ,result_mapExp,v_mapExp.getData(),normTolerance); //octave = exp(v1) RealVector v_mapExpToSelf = v1.copy(); v_mapExpToSelf.mapExpToSelf(); double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d}; assertClose("compare vectors" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance); //octave = ??? RealVector v_mapExpm1 = v1.mapExpm1(); double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d}; assertClose("compare vectors" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance); //octave = ??? RealVector v_mapExpm1ToSelf = v1.copy(); v_mapExpm1ToSelf.mapExpm1ToSelf(); double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d}; assertClose("compare vectors" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance); //octave = log(v1) RealVector v_mapLog = v1.mapLog(); double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d}; assertClose("compare vectors" ,result_mapLog,v_mapLog.getData(),normTolerance); //octave = log(v1) RealVector v_mapLogToSelf = v1.copy(); v_mapLogToSelf.mapLogToSelf(); double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d}; assertClose("compare vectors" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance); //octave = log10(v1) RealVector v_mapLog10 = v1.mapLog10(); double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d}; assertClose("compare vectors" ,result_mapLog10,v_mapLog10.getData(),normTolerance); //octave = log(v1) RealVector v_mapLog10ToSelf = v1.copy(); v_mapLog10ToSelf.mapLog10ToSelf(); double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d}; assertClose("compare vectors" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance); //octave = ??? RealVector v_mapLog1p = v1.mapLog1p(); double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d}; assertClose("compare vectors" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance); //octave = ??? RealVector v_mapLog1pToSelf = v1.copy(); v_mapLog1pToSelf.mapLog1pToSelf(); double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d}; assertClose("compare vectors" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance); //octave = cosh(v1) RealVector v_mapCosh = v1.mapCosh(); double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d}; assertClose("compare vectors" ,result_mapCosh,v_mapCosh.getData(),normTolerance); //octave = cosh(v1) RealVector v_mapCoshToSelf = v1.copy(); v_mapCoshToSelf.mapCoshToSelf(); double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d}; assertClose("compare vectors" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance); //octave = sinh(v1) RealVector v_mapSinh = v1.mapSinh(); double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d}; assertClose("compare vectors" ,result_mapSinh,v_mapSinh.getData(),normTolerance); //octave = sinh(v1) RealVector v_mapSinhToSelf = v1.copy(); v_mapSinhToSelf.mapSinhToSelf(); double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d}; assertClose("compare vectors" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance); //octave = tanh(v1) RealVector v_mapTanh = v1.mapTanh(); double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d}; assertClose("compare vectors" ,result_mapTanh,v_mapTanh.getData(),normTolerance); //octave = tanh(v1) RealVector v_mapTanhToSelf = v1.copy(); v_mapTanhToSelf.mapTanhToSelf(); double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d}; assertClose("compare vectors" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance); //octave = cos(v1) RealVector v_mapCos = v1.mapCos(); double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d}; assertClose("compare vectors" ,result_mapCos,v_mapCos.getData(),normTolerance); //octave = cos(v1) RealVector v_mapCosToSelf = v1.copy(); v_mapCosToSelf.mapCosToSelf(); double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d}; assertClose("compare vectors" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance); //octave = sin(v1) RealVector v_mapSin = v1.mapSin(); double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d}; assertClose("compare vectors" ,result_mapSin,v_mapSin.getData(),normTolerance); //octave = sin(v1) RealVector v_mapSinToSelf = v1.copy(); v_mapSinToSelf.mapSinToSelf(); double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d}; assertClose("compare vectors" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance); //octave = tan(v1) RealVector v_mapTan = v1.mapTan(); double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d}; assertClose("compare vectors" ,result_mapTan,v_mapTan.getData(),normTolerance); //octave = tan(v1) RealVector v_mapTanToSelf = v1.copy(); v_mapTanToSelf.mapTanToSelf(); double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d}; assertClose("compare vectors" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance); double[] vat_a = {0d, 0.5d, 1.0d}; RealVectorImpl vat = new RealVectorImpl(vat_a); //octave = acos(vat) RealVector v_mapAcos = vat.mapAcos(); double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d}; assertClose("compare vectors" ,result_mapAcos,v_mapAcos.getData(),normTolerance); //octave = acos(vat) RealVector v_mapAcosToSelf = vat.copy(); v_mapAcosToSelf.mapAcosToSelf(); double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d}; assertClose("compare vectors" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance); //octave = asin(vat) RealVector v_mapAsin = vat.mapAsin(); double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d}; assertClose("compare vectors" ,result_mapAsin,v_mapAsin.getData(),normTolerance); //octave = asin(vat) RealVector v_mapAsinToSelf = vat.copy(); v_mapAsinToSelf.mapAsinToSelf(); double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d}; assertClose("compare vectors" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance); //octave = atan(vat) RealVector v_mapAtan = vat.mapAtan(); double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d}; assertClose("compare vectors" ,result_mapAtan,v_mapAtan.getData(),normTolerance); //octave = atan(vat) RealVector v_mapAtanToSelf = vat.copy(); v_mapAtanToSelf.mapAtanToSelf(); double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d}; assertClose("compare vectors" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance); //octave = v1 .^-1 RealVector v_mapInv = v1.mapInv(); double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d}; assertClose("compare vectors" ,result_mapInv,v_mapInv.getData(),normTolerance); //octave = v1 .^-1 RealVector v_mapInvToSelf = v1.copy(); v_mapInvToSelf.mapInvToSelf(); double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d}; assertClose("compare vectors" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance); double[] abs_a = {-1.0d, 0.0d, 1.0d}; RealVectorImpl abs_v = new RealVectorImpl(abs_a); //octave = abs(abs_v) RealVector v_mapAbs = abs_v.mapAbs(); double[] result_mapAbs = {1d,0d,1d}; assertClose("compare vectors" ,result_mapAbs,v_mapAbs.getData(),normTolerance); //octave = abs(abs_v) RealVector v_mapAbsToSelf = abs_v.copy(); v_mapAbsToSelf.mapAbsToSelf(); double[] result_mapAbsToSelf = {1d,0d,1d}; assertClose("compare vectors" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance); //octave = sqrt(v1) RealVector v_mapSqrt = v1.mapSqrt(); double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d}; assertClose("compare vectors" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance); //octave = sqrt(v1) RealVector v_mapSqrtToSelf = v1.copy(); v_mapSqrtToSelf.mapSqrtToSelf(); double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d}; assertClose("compare vectors" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance); double[] cbrt_a = {-2.0d, 0.0d, 2.0d}; RealVectorImpl cbrt_v = new RealVectorImpl(cbrt_a); //octave = ??? RealVector v_mapCbrt = cbrt_v.mapCbrt(); double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d}; assertClose("compare vectors" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance); //octave = ??? RealVector v_mapCbrtToSelf = cbrt_v.copy(); v_mapCbrtToSelf.mapCbrtToSelf(); double[] result_mapCbrtToSelf = {-1.2599210498948732d,0d,1.2599210498948732d}; assertClose("compare vectors" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance); double[] ceil_a = {-1.1d, 0.9d, 1.1d}; RealVectorImpl ceil_v = new RealVectorImpl(ceil_a); //octave = ceil(ceil_v) RealVector v_mapCeil = ceil_v.mapCeil(); double[] result_mapCeil = {-1d,1d,2d}; assertClose("compare vectors" ,result_mapCeil,v_mapCeil.getData(),normTolerance); //octave = ceil(ceil_v) RealVector v_mapCeilToSelf = ceil_v.copy(); v_mapCeilToSelf.mapCeilToSelf(); double[] result_mapCeilToSelf = {-1d,1d,2d}; assertClose("compare vectors" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance); //octave = floor(ceil_v) RealVector v_mapFloor = ceil_v.mapFloor(); double[] result_mapFloor = {-2d,0d,1d}; assertClose("compare vectors" ,result_mapFloor,v_mapFloor.getData(),normTolerance); //octave = floor(ceil_v) RealVector v_mapFloorToSelf = ceil_v.copy(); v_mapFloorToSelf.mapFloorToSelf(); double[] result_mapFloorToSelf = {-2d,0d,1d}; assertClose("compare vectors" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance); //octave = ??? RealVector v_mapRint = ceil_v.mapRint(); double[] result_mapRint = {-1d,1d,1d}; assertClose("compare vectors" ,result_mapRint,v_mapRint.getData(),normTolerance); //octave = ??? RealVector v_mapRintToSelf = ceil_v.copy(); v_mapRintToSelf.mapRintToSelf(); double[] result_mapRintToSelf = {-1d,1d,1d}; assertClose("compare vectors" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance); //octave = ??? RealVector v_mapSignum = ceil_v.mapSignum(); double[] result_mapSignum = {-1d,1d,1d}; assertClose("compare vectors" ,result_mapSignum,v_mapSignum.getData(),normTolerance); //octave = ??? RealVector v_mapSignumToSelf = ceil_v.copy(); v_mapSignumToSelf.mapSignumToSelf(); double[] result_mapSignumToSelf = {-1d,1d,1d}; assertClose("compare vectors" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance); // Is with the used resolutions of limited value as test //octave = ??? RealVector v_mapUlp = ceil_v.mapUlp(); double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d}; assertClose("compare vectors" ,result_mapUlp,v_mapUlp.getData(),normTolerance); //octave = ??? RealVector v_mapUlpToSelf = ceil_v.copy(); v_mapUlpToSelf.mapUlpToSelf(); double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d}; assertClose("compare vectors" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance); } public void testBasicFunctions() { RealVectorImpl v1 = new RealVectorImpl(vec1); RealVectorImpl v2 = new RealVectorImpl(vec2); RealVectorImpl v_null = new RealVectorImpl(vec_null); RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); //octave = sqrt(sumsq(v1)) double d_getNorm = v1.getNorm(); assertEquals("compare values ", 3.7416573867739413,d_getNorm); double d_getL1Norm = v1.getL1Norm(); assertEquals("compare values ",6.0, d_getL1Norm); double d_getLInfNorm = v1.getLInfNorm(); assertEquals("compare values ",6.0, d_getLInfNorm); //octave = sqrt(sumsq(v1-v2)) double dist = v1.getDistance(v2); assertEquals("compare values ",v1.subtract(v2).getNorm(), dist ); //octave = sqrt(sumsq(v1-v2)) double dist_2 = v1.getDistance(v2_t); assertEquals("compare values ", v1.subtract(v2).getNorm(),dist_2 ); //octave = ??? double d_getL1Distance = v1. getL1Distance(v2); assertEquals("compare values ",9d, d_getL1Distance ); double d_getL1Distance_2 = v1. getL1Distance(v2_t); assertEquals("compare values ",9d, d_getL1Distance_2 ); //octave = ??? double d_getLInfDistance = v1. getLInfDistance(v2); assertEquals("compare values ",3d, d_getLInfDistance ); double d_getLInfDistance_2 = v1. getLInfDistance(v2_t); assertEquals("compare values ",3d, d_getLInfDistance_2 ); //octave = v1 + v2 RealVectorImpl v_add = v1.add(v2); double[] result_add = {5d, 7d, 9d}; assertClose("compare vect" ,v_add.getData(),result_add,normTolerance); RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2); RealVector v_add_i = v1.add(vt2); double[] result_add_i = {5d, 7d, 9d}; assertClose("compare vect" ,v_add_i.getData(),result_add_i,normTolerance); //octave = v1 - v2 RealVectorImpl v_subtract = v1.subtract(v2); double[] result_subtract = {-3d, -3d, -3d}; assertClose("compare vect" ,v_subtract.getData(),result_subtract,normTolerance); RealVector v_subtract_i = v1.subtract(vt2); double[] result_subtract_i = {-3d, -3d, -3d}; assertClose("compare vect" ,v_subtract_i.getData(),result_subtract_i,normTolerance); // octave v1 .* v2 RealVectorImpl v_ebeMultiply = v1.ebeMultiply(v2); double[] result_ebeMultiply = {4d, 10d, 18d}; assertClose("compare vect" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance); RealVector v_ebeMultiply_2 = v1.ebeMultiply(v2_t); double[] result_ebeMultiply_2 = {4d, 10d, 18d}; assertClose("compare vect" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance); // octave v1 ./ v2 RealVectorImpl v_ebeDivide = v1.ebeDivide(v2); double[] result_ebeDivide = {0.25d, 0.4d, 0.5d}; assertClose("compare vect" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance); RealVector v_ebeDivide_2 = v1.ebeDivide(v2_t); double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d}; assertClose("compare vect" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance); // octave dot(v1,v2) double dot = v1.dotProduct(v2); assertEquals("compare val ",32d, dot); // octave dot(v1,v2_t) double dot_2 = v1.dotProduct(v2_t); assertEquals("compare val ",32d, dot_2); RealMatrixImpl m_outerProduct = v1.outerProduct(v2); assertEquals("compare val ",4d, m_outerProduct.getEntry(0,0)); RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t); assertEquals("compare val ",4d, m_outerProduct_2.getEntry(0,0)); RealVector v_unitVector = v1.unitVector(); RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); assertClose("compare vect" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance); try { v_null.unitVector(); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVectorImpl v_unitize = (RealVectorImpl)v1.copy(); v_unitize.unitize(); assertClose("compare vect" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance); try { v_null.unitize(); fail("Expecting ArithmeticException"); } catch (ArithmeticException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } RealVectorImpl v_projection = v1.projection(v2); double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493}; assertClose("compare vect", v_projection.getData(), result_projection, normTolerance); RealVector v_projection_2 = v1.projection(v2_t); double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493}; assertClose("compare vect", v_projection_2.getData(), result_projection_2, normTolerance); } public void testMisc() { RealVectorImpl v1 = new RealVectorImpl(vec1); RealVectorImpl v4 = new RealVectorImpl(vec4); RealVector v4_2 = new RealVectorImpl(vec4); String out1 = v1.toString(); assertTrue("some output ", out1.length()!=0); /* double[] dout1 = v1.copyOut(); assertEquals("testData len", 3, dout1.length); assertNotSame("testData not same object ", v1.data, dout1); */ try { v1.checkVectorDimensions(2); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { v1.checkVectorDimensions(v4); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { v1.checkVectorDimensions(v4_2); fail("IllegalArgumentException expected"); } catch (IllegalArgumentException ex) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } public void testPredicates() { RealVectorImpl v = new RealVectorImpl(new double[] { 0, 1, 2 }); assertFalse(v.isNaN()); v.set(1, Double.NaN); assertTrue(v.isNaN()); assertFalse(v.isInfinite()); v.set(0, Double.POSITIVE_INFINITY); assertFalse(v.isInfinite()); v.set(1, 1); assertTrue(v.isInfinite()); v.set(0, 0); assertEquals(v, new RealVectorImpl(new double[] { 0, 1, 2 })); assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2 + Math.ulp(2)})); assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2, 3 })); assertEquals(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode(), new RealVectorImpl(new double[] { 0, Double.NaN, 2 }).hashCode()); assertTrue(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode() != new RealVectorImpl(new double[] { 0, 1, 2 }).hashCode()); } /** verifies that two vectors are close (sup norm) */ protected void assertClose(String msg, double[] m, double[] n, double tolerance) { if (m.length != n.length) { fail("vectors have different lengths"); } for (int i = 0; i < m.length; i++) { assertEquals(msg + " " + i + " elements differ", m[i],n[i],tolerance); } } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import junit.framework.TestCase; /** * @version $Revision$ $Date$ */ public class MatrixIndexExceptionTest extends TestCase { /** * */ public void testConstructorMessage(){ String msg = "message"; MatrixIndexException ex = new MatrixIndexException(msg, null); assertEquals(msg, ex.getMessage()); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class BiDiagonalTransformerTest extends TestCase { private double[][] testSquare = { { 24.0 / 25.0, 43.0 / 25.0 }, { 57.0 / 25.0, 24.0 / 25.0 } }; private double[][] testNonSquare = { { -540.0 / 625.0, 963.0 / 625.0, -216.0 / 625.0 }, { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 }, { -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 }, { -360.0 / 625.0, 192.0 / 625.0, 1756.0 / 625.0 }, }; public BiDiagonalTransformerTest(String name) { super(name); } public void testDimensions() { checkdimensions(new RealMatrixImpl(testSquare, false)); checkdimensions(new RealMatrixImpl(testNonSquare, false)); checkdimensions(new RealMatrixImpl(testNonSquare, false).transpose()); } private void checkdimensions(RealMatrix matrix) { final int m = matrix.getRowDimension(); final int n = matrix.getColumnDimension(); BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix); assertEquals(m, transformer.getU().getRowDimension()); assertEquals(m, transformer.getU().getColumnDimension()); assertEquals(m, transformer.getB().getRowDimension()); assertEquals(n, transformer.getB().getColumnDimension()); assertEquals(n, transformer.getV().getRowDimension()); assertEquals(n, transformer.getV().getColumnDimension()); } public void testAEqualUSVt() { checkAEqualUSVt(new RealMatrixImpl(testSquare, false)); checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false)); checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false).transpose()); } private void checkAEqualUSVt(RealMatrix matrix) { BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix); RealMatrix u = transformer.getU(); RealMatrix b = transformer.getB(); RealMatrix v = transformer.getV(); double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm(); assertEquals(0, norm, 1.0e-14); } public void testUOrthogonal() { checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getU()); checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getU()); checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getU()); } public void testVOrthogonal() { checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getV()); checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getV()); checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getV()); } private void checkOrthogonal(RealMatrix m) { RealMatrix mTm = m.transpose().multiply(m); RealMatrix id = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension()); assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14); } public void testBBiDiagonal() { checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getB()); checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getB()); checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getB()); } private void checkBiDiagonal(RealMatrix m) { final int rows = m.getRowDimension(); final int cols = m.getColumnDimension(); for (int i = 0; i < rows; ++i) { for (int j = 0; j < cols; ++j) { if (rows < cols) { if ((i < j) || (i > j + 1)) { assertEquals(0, m.getEntry(i, j), 1.0e-16); } } else { if ((i < j - 1) || (i > j)) { assertEquals(0, m.getEntry(i, j), 1.0e-16); } } } } } public void testMatricesValues() { BiDiagonalTransformer transformer = new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)); final double s17 = Math.sqrt(17.0); RealMatrix uRef = new RealMatrixImpl(new double[][] { { -8 / (5 * s17), 19 / (5 * s17) }, { -19 / (5 * s17), -8 / (5 * s17) } }); RealMatrix bRef = new RealMatrixImpl(new double[][] { { -3 * s17 / 5, 32 * s17 / 85 }, { 0.0, -5 * s17 / 17 } }); RealMatrix vRef = new RealMatrixImpl(new double[][] { { 1.0, 0.0 }, { 0.0, -1.0 } }); // check values against known references RealMatrix u = transformer.getU(); assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14); RealMatrix b = transformer.getB(); assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14); RealMatrix v = transformer.getV(); assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14); // check the same cached instance is returned the second time assertTrue(u == transformer.getU()); assertTrue(b == transformer.getB()); assertTrue(v == transformer.getV()); } public void testUpperOrLower() { assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).isUpperBiDiagonal()); assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).isUpperBiDiagonal()); assertFalse(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).isUpperBiDiagonal()); } public static Test suite() { return new TestSuite(BiDiagonalTransformerTest.class); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import java.util.Locale; public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest { protected char getDecimalCharacter() { return ','; } protected Locale getLocale() { return Locale.FRENCH; } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math.linear; import java.util.Arrays; import java.util.Random; import junit.framework.Test; import junit.framework.TestCase; import junit.framework.TestSuite; public class EigenDecompositionImplTest extends TestCase { private double[] refValues; private RealMatrix matrix; public EigenDecompositionImplTest(String name) { super(name); } public static Test suite() { TestSuite suite = new TestSuite(EigenDecompositionImplTest.class); suite.setName("EigenDecompositionImpl Tests"); return suite; } public void testDimension1() { RealMatrix matrix = new RealMatrixImpl(new double[][] { { 1.5 } }, false); EigenDecomposition ed = new EigenDecompositionImpl(matrix); assertEquals(1.5, ed.getEigenvalue(0), 1.0e-15); } public void testDimension2() { RealMatrix matrix = new RealMatrixImpl(new double[][] { { 59.0, 12.0 }, { Double.NaN, 66.0 } }, false); EigenDecomposition ed = new EigenDecompositionImpl(matrix); assertEquals(75.0, ed.getEigenvalue(0), 1.0e-15); assertEquals(50.0, ed.getEigenvalue(1), 1.0e-15); } public void testDimension3() { RealMatrix matrix = new RealMatrixImpl(new double[][] { { 39632.0, -4824.0, -16560.0 }, { Double.NaN, 8693.0, 7920.0 }, { Double.NaN, Double.NaN, 17300.0 } }, false); EigenDecomposition ed = new EigenDecompositionImpl(matrix); assertEquals(50000.0, ed.getEigenvalue(0), 3.0e-11); assertEquals(12500.0, ed.getEigenvalue(1), 3.0e-11); assertEquals( 3125.0, ed.getEigenvalue(2), 3.0e-11); } public void testDimension4WithSplit() { RealMatrix matrix = new RealMatrixImpl(new double[][] { { 0.784, -0.288, 0.000, 0.000 }, { Double.NaN, 0.616, 0.000, 0.000 }, { Double.NaN, Double.NaN, 0.164, -0.048 }, { Double.NaN, Double.NaN, Double.NaN, 0.136 } }, false); EigenDecomposition ed = new EigenDecompositionImpl(matrix); assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15); assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15); assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15); assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15); } public void testDimension4WithoutSplit() { RealMatrix matrix = new RealMatrixImpl(new double[][] { { 0.5608, -0.2016, 0.1152, -0.2976 }, { -0.2016, 0.4432, -0.2304, 0.1152 }, { 0.1152, -0.2304, 0.3088, -0.1344 }, { -0.2976, 0.1152, -0.1344, 0.3872 } }, false); EigenDecomposition ed = new EigenDecompositionImpl(matrix); assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15); assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15); assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15); assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15); } /** test dimensions */ public void testDimensions() { final int m = matrix.getRowDimension(); EigenDecomposition ed = new EigenDecompositionImpl(matrix); assertEquals(m, ed.getV().getRowDimension()); assertEquals(m, ed.getV().getColumnDimension()); assertEquals(m, ed.getD().getColumnDimension()); assertEquals(m, ed.getD().getColumnDimension()); assertEquals(m, ed.getVT().getRowDimension()); assertEquals(m, ed.getVT().getColumnDimension()); } /** test eigenvalues */ public void testEigenvalues() { EigenDecomposition ed = new EigenDecompositionImpl(matrix); double[] eigenValues = ed.getEigenvalues(); assertEquals(refValues.length, eigenValues.length); for (int i = 0; i < refValues.length; ++i) { assertEquals(refValues[i], eigenValues[i], 3.0e-15); } } /** test eigenvalues for a big matrix. */ public void testBigMatrix() { Random r = new Random(17748333525117l); double[] bigValues = new double[200]; for (int i = 0; i < bigValues.length; ++i) { bigValues[i] = 2 * r.nextDouble() - 1; } Arrays.sort(bigValues); EigenDecomposition ed = new EigenDecompositionImpl(createTestMatrix(r, bigValues)); double[] eigenValues = ed.getEigenvalues(); assertEquals(bigValues.length, eigenValues.length); for (int i = 0; i < bigValues.length; ++i) { assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14); } } /** test eigenvectors */ public void testEigenvectors() { EigenDecomposition ed = new EigenDecompositionImpl(matrix); for (int i = 0; i < matrix.getRowDimension(); ++i) { double lambda = ed.getEigenvalue(i); RealVector v = ed.getEigenvector(i); RealVector mV = matrix.operate(v); assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13); } } /** test A = VDVt */ public void testAEqualVDVt() { EigenDecomposition ed = new EigenDecompositionImpl(matrix); RealMatrix v = ed.getV(); RealMatrix d = ed.getD(); RealMatrix vT = ed.getVT(); double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm(); assertEquals(0, norm, 6.0e-13); } /** test that V is orthogonal */ public void testVOrthogonal() { RealMatrix v = new EigenDecompositionImpl(matrix).getV(); RealMatrix vTv = v.transpose().multiply(v); RealMatrix id = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension()); assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13); } /** test solve dimension errors */ public void testSolveDimensionErrors() { EigenDecomposition ed = new EigenDecompositionImpl(matrix); RealMatrix b = new RealMatrixImpl(new double[2][2]); try { ed.solve(b); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { ed.solve(b.getColumn(0)); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } try { ed.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0))); fail("an exception should have been thrown"); } catch (IllegalArgumentException iae) { // expected behavior } catch (Exception e) { fail("wrong exception caught"); } } /** test solve */ public void testSolve() { RealMatrix m = new RealMatrixImpl(new double[][] { { 91, 5, 29, 32, 40, 14 }, { 5, 34, -1, 0, 2, -1 }, { 29, -1, 12, 9, 21, 8 }, { 32, 0, 9, 14, 9, 0 }, { 40, 2, 21, 9, 51, 19 }, { 14, -1, 8, 0, 19, 14 } }); EigenDecomposition ed = new EigenDecompositionImpl(m); assertEquals(184041, ed.getDeterminant(), 2.0e-8); RealMatrix b = new RealMatrixImpl(new double[][] { { 1561, 269, 188 }, { 69, -21, 70 }, { 739, 108, 63 }, { 324, 86, 59 }, { 1624, 194, 107 }, { 796, 69, 36 } }); RealMatrix xRef = new RealMatrixImpl(new double[][] { { 1, 2, 1 }, { 2, -1, 2 }, { 4, 2, 3 }, { 8, -1, 0 }, { 16, 2, 0 }, { 32, -1, 0 } }); // using RealMatrix assertEquals(0, ed.solve(b).subtract(xRef).getNorm(), 2.0e-12); // using double[] for (int i = 0; i < b.getColumnDimension(); ++i) { assertEquals(0, new RealVectorImpl(ed.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(), 2.0e-11); } // using RealMatrixImpl for (int i = 0; i < b.getColumnDimension(); ++i) { assertEquals(0, ed.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(), 2.0e-11); } // using RealMatrix with an alternate implementation for (int i = 0; i < b.getColumnDimension(); ++i) { RealVectorImplTest.RealVectorTestImpl v = new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i)); assertEquals(0, ed.solve(v).subtract(xRef.getColumnVector(i)).getNorm(), 2.0e-11); } } /** * Matrix with eigenvalues {8, -1, -1} */ public void testRepeatedEigenvalue() { RealMatrix repeated = new RealMatrixImpl(new double[][] { {3, 2, 4}, {2, 0, 2}, {4, 2, 3} }); EigenDecomposition ed = new EigenDecompositionImpl(repeated); checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12); checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12); } /** * Matrix with eigenvalues {2, 0, 12} */ public void testDistinctEigenvalues() { RealMatrix distinct = new RealMatrixImpl(new double[][] { {3, 1, -4}, {1, 3, -4}, {-4, -4, 8} }); EigenDecomposition ed = new EigenDecompositionImpl(distinct); checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12); checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12); checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12); checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12); } /** * Verifies that the given EigenDecomposition has eigenvalues equivalent to * the targetValues, ignoring the order of the values and allowing * values to differ by tolerance. */ protected void checkEigenValues(double[] targetValues, EigenDecomposition ed, double tolerance) { double[] observed = ed.getEigenvalues(); for (int i = 0; i < observed.length; i++) { assertTrue(isIncludedValue(observed[i], targetValues, tolerance)); assertTrue(isIncludedValue(targetValues[i], observed, tolerance)); } } /** * Returns true iff there is an entry within tolerance of value in * searchArray. */ private boolean isIncludedValue(double value, double[] searchArray, double tolerance) { boolean found = false; int i = 0; while (!found && i < searchArray.length) { if (Math.abs(value - searchArray[i]) < tolerance) { found = true; } i++; } return found; } /** * Returns true iff eigenVector is a scalar multiple of one of the columns * of ed.getV(). Does not try linear combinations - i.e., should only be * used to find vectors in one-dimensional eigenspaces. */ protected void checkEigenVector(double[] eigenVector, EigenDecomposition ed, double tolerance) { assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance)); } /** * Returns true iff there is a column that is a scalar multiple of column * in searchMatrix (modulo tolerance) */ private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix, double tolerance) { boolean found = false; int i = 0; while (!found && i < searchMatrix.getColumnDimension()) { double multiplier = 1d; boolean matching = true; int j = 0; while (matching && j < searchMatrix.getRowDimension()) { double colEntry = searchMatrix.getEntry(j, i); // Use the first entry where both are non-zero as scalar if (multiplier == 1d && Math.abs(colEntry) > 1E-14 && Math.abs(column[j]) > 1e-14) { multiplier = colEntry / column[j]; } if (Math.abs(column[j] * multiplier - colEntry) > tolerance) { matching = false; } j++; } found = matching; i++; } return found; } public void setUp() { refValues = new double[] { 2.003, 2.002, 2.001, 1.001, 1.000, 0.001 }; matrix = createTestMatrix(new Random(35992629946426l), refValues); } public void tearDown() { refValues = null; matrix = null; } private RealMatrix createTestMatrix(final Random r, final double[] eigenValues) { final int n = eigenValues.length; final RealMatrix v = createOrthogonalMatrix(r, n); final RealMatrix d = createDiagonalMatrix(eigenValues, n, n); return v.multiply(d).multiply(v.transpose()); } public static RealMatrix createOrthogonalMatrix(final Random r, final int size) { final double[][] data = new double[size][size]; for (int i = 0; i < size; ++i) { final double[] dataI = data[i]; double norm2 = 0; do { // generate randomly row I for (int j = 0; j < size; ++j) { dataI[j] = 2 * r.nextDouble() - 1; } // project the row in the subspace orthogonal to previous rows for (int k = 0; k < i; ++k) { final double[] dataK = data[k]; double dotProduct = 0; for (int j = 0; j < size; ++j) { dotProduct += dataI[j] * dataK[j]; } for (int j = 0; j < size; ++j) { dataI[j] -= dotProduct * dataK[j]; } } // normalize the row norm2 = 0; for (final double dataIJ : dataI) { norm2 += dataIJ * dataIJ; } final double inv = 1.0 / Math.sqrt(norm2); for (int j = 0; j < size; ++j) { dataI[j] *= inv; } } while (norm2 * size < 0.01); } return new RealMatrixImpl(data, false); } public static RealMatrix createDiagonalMatrix(final double[] diagonal, final int rows, final int columns) { final double[][] dData = new double[rows][columns]; for (int i = 0; i < Math.min(rows, columns); ++i) { dData[i][i] = diagonal[i]; } return new RealMatrixImpl(dData, false); } }
/* * Licensed to the Apache Software Foundation (ASF) under one or more * contributor license agreements. See the NOTICE file distributed with * this work for additional information regarding copyright ownership. * The ASF licenses this file to You under the Apache License, Version 2.0 * (the "License"); you may not use this file except in compliance with * the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.apache.commons.math; import junit.framework.AssertionFailedError; import junit.framework.TestCase; /** * A TestCase that retries tests when assertions fail. * <p> * If one or more tests throw an AssertionFailedError, all tests are * repeated one time. * <p> * Errors or exceptions other than AssertionFailedError do not lead to retries. * * @version $Revision$ $Date$ */ public abstract class RetryTestCase extends TestCase { public RetryTestCase() { super(); } public RetryTestCase(String arg0) { super(arg0); } /** * Override runTest() to catch AssertionFailedError and retry */ protected void runTest() throws Throwable { try { super.runTest(); } catch (AssertionFailedError err) { // System.out.println("Retrying " + this.getName()); super.runTest(); } } }
